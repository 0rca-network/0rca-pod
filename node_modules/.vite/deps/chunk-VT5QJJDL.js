import {
  __commonJS,
  __esm,
  __export,
  __reExport,
  __require,
  __toCommonJS,
  __toESM
} from "./chunk-RZ55PUNP.js";

// node_modules/@walletconnect/window-getters/dist/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/@walletconnect/window-getters/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getLocalStorage = exports.getLocalStorageOrThrow = exports.getCrypto = exports.getCryptoOrThrow = exports.getLocation = exports.getLocationOrThrow = exports.getNavigator = exports.getNavigatorOrThrow = exports.getDocument = exports.getDocumentOrThrow = exports.getFromWindowOrThrow = exports.getFromWindow = void 0;
    function getFromWindow2(name) {
      let res = void 0;
      if (typeof window !== "undefined" && typeof window[name] !== "undefined") {
        res = window[name];
      }
      return res;
    }
    exports.getFromWindow = getFromWindow2;
    function getFromWindowOrThrow2(name) {
      const res = getFromWindow2(name);
      if (!res) {
        throw new Error(`${name} is not defined in Window`);
      }
      return res;
    }
    exports.getFromWindowOrThrow = getFromWindowOrThrow2;
    function getDocumentOrThrow2() {
      return getFromWindowOrThrow2("document");
    }
    exports.getDocumentOrThrow = getDocumentOrThrow2;
    function getDocument2() {
      return getFromWindow2("document");
    }
    exports.getDocument = getDocument2;
    function getNavigatorOrThrow2() {
      return getFromWindowOrThrow2("navigator");
    }
    exports.getNavigatorOrThrow = getNavigatorOrThrow2;
    function getNavigator3() {
      return getFromWindow2("navigator");
    }
    exports.getNavigator = getNavigator3;
    function getLocationOrThrow2() {
      return getFromWindowOrThrow2("location");
    }
    exports.getLocationOrThrow = getLocationOrThrow2;
    function getLocation3() {
      return getFromWindow2("location");
    }
    exports.getLocation = getLocation3;
    function getCryptoOrThrow2() {
      return getFromWindowOrThrow2("crypto");
    }
    exports.getCryptoOrThrow = getCryptoOrThrow2;
    function getCrypto2() {
      return getFromWindow2("crypto");
    }
    exports.getCrypto = getCrypto2;
    function getLocalStorageOrThrow2() {
      return getFromWindowOrThrow2("localStorage");
    }
    exports.getLocalStorageOrThrow = getLocalStorageOrThrow2;
    function getLocalStorage3() {
      return getFromWindow2("localStorage");
    }
    exports.getLocalStorage = getLocalStorage3;
  }
});

// node_modules/@walletconnect/window-metadata/dist/cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/@walletconnect/window-metadata/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getWindowMetadata = void 0;
    var window_getters_1 = require_cjs();
    function getWindowMetadata2() {
      let doc;
      let loc;
      try {
        doc = window_getters_1.getDocumentOrThrow();
        loc = window_getters_1.getLocationOrThrow();
      } catch (e2) {
        return null;
      }
      function getIcons() {
        const links = doc.getElementsByTagName("link");
        const icons2 = [];
        for (let i2 = 0; i2 < links.length; i2++) {
          const link = links[i2];
          const rel = link.getAttribute("rel");
          if (rel) {
            if (rel.toLowerCase().indexOf("icon") > -1) {
              const href = link.getAttribute("href");
              if (href) {
                if (href.toLowerCase().indexOf("https:") === -1 && href.toLowerCase().indexOf("http:") === -1 && href.indexOf("//") !== 0) {
                  let absoluteHref = loc.protocol + "//" + loc.host;
                  if (href.indexOf("/") === 0) {
                    absoluteHref += href;
                  } else {
                    const path = loc.pathname.split("/");
                    path.pop();
                    const finalPath = path.join("/");
                    absoluteHref += finalPath + "/" + href;
                  }
                  icons2.push(absoluteHref);
                } else if (href.indexOf("//") === 0) {
                  const absoluteUrl = loc.protocol + href;
                  icons2.push(absoluteUrl);
                } else {
                  icons2.push(href);
                }
              }
            }
          }
        }
        return icons2;
      }
      function getWindowMetadataOfAny(...args) {
        const metaTags = doc.getElementsByTagName("meta");
        for (let i2 = 0; i2 < metaTags.length; i2++) {
          const tag = metaTags[i2];
          const attributes = ["itemprop", "property", "name"].map((target) => tag.getAttribute(target)).filter((attr) => {
            if (attr) {
              return args.includes(attr);
            }
            return false;
          });
          if (attributes.length && attributes) {
            const content = tag.getAttribute("content");
            if (content) {
              return content;
            }
          }
        }
        return "";
      }
      function getName() {
        let name2 = getWindowMetadataOfAny("name", "og:site_name", "og:title", "twitter:title");
        if (!name2) {
          name2 = doc.title;
        }
        return name2;
      }
      function getDescription() {
        const description2 = getWindowMetadataOfAny("description", "og:description", "twitter:description", "keywords");
        return description2;
      }
      const name = getName();
      const description = getDescription();
      const url = loc.origin;
      const icons = getIcons();
      const meta = {
        description,
        url,
        icons,
        name
      };
      return meta;
    }
    exports.getWindowMetadata = getWindowMetadata2;
  }
});

// browser-external:buffer
var require_buffer = __commonJS({
  "browser-external:buffer"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "buffer" has been externalized for browser compatibility. Cannot access "buffer.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/bn.js/lib/bn.js
var require_bn = __commonJS({
  "node_modules/bn.js/lib/bn.js"(exports, module) {
    (function(module2, exports2) {
      "use strict";
      function assert2(val, msg) {
        if (!val) throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN2(number, base, endian) {
        if (BN2.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number || 0, base || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN2;
      } else {
        exports2.BN = BN2;
      }
      BN2.BN = BN2;
      BN2.wordSize = 26;
      var Buffer2;
      try {
        Buffer2 = require_buffer().Buffer;
      } catch (e2) {
      }
      BN2.isBN = function isBN(num) {
        if (num instanceof BN2) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);
      };
      BN2.max = function max(left, right) {
        if (left.cmp(right) > 0) return left;
        return right;
      };
      BN2.min = function min(left, right) {
        if (left.cmp(right) < 0) return left;
        return right;
      };
      BN2.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert2(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
        }
        if (base === 16) {
          this._parseHex(number, start);
        } else {
          this._parseBase(number, base, start);
        }
        if (number[0] === "-") {
          this.negative = 1;
        }
        this.strip();
        if (endian !== "le") return;
        this._initArray(this.toArray(), base, endian);
      };
      BN2.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert2(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le") return;
        this._initArray(this.toArray(), base, endian);
      };
      BN2.prototype._initArray = function _initArray(number, base, endian) {
        assert2(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i2 = 0; i2 < this.length; i2++) {
          this.words[i2] = 0;
        }
        var j2, w2;
        var off = 0;
        if (endian === "be") {
          for (i2 = number.length - 1, j2 = 0; i2 >= 0; i2 -= 3) {
            w2 = number[i2] | number[i2 - 1] << 8 | number[i2 - 2] << 16;
            this.words[j2] |= w2 << off & 67108863;
            this.words[j2 + 1] = w2 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j2++;
            }
          }
        } else if (endian === "le") {
          for (i2 = 0, j2 = 0; i2 < number.length; i2 += 3) {
            w2 = number[i2] | number[i2 + 1] << 8 | number[i2 + 2] << 16;
            this.words[j2] |= w2 << off & 67108863;
            this.words[j2 + 1] = w2 >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j2++;
            }
          }
        }
        return this.strip();
      };
      function parseHex(str, start, end) {
        var r3 = 0;
        var len = Math.min(str.length, end);
        for (var i2 = start; i2 < len; i2++) {
          var c2 = str.charCodeAt(i2) - 48;
          r3 <<= 4;
          if (c2 >= 49 && c2 <= 54) {
            r3 |= c2 - 49 + 10;
          } else if (c2 >= 17 && c2 <= 22) {
            r3 |= c2 - 17 + 10;
          } else {
            r3 |= c2 & 15;
          }
        }
        return r3;
      }
      BN2.prototype._parseHex = function _parseHex(number, start) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i2 = 0; i2 < this.length; i2++) {
          this.words[i2] = 0;
        }
        var j2, w2;
        var off = 0;
        for (i2 = number.length - 6, j2 = 0; i2 >= start; i2 -= 6) {
          w2 = parseHex(number, i2, i2 + 6);
          this.words[j2] |= w2 << off & 67108863;
          this.words[j2 + 1] |= w2 >>> 26 - off & 4194303;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j2++;
          }
        }
        if (i2 + 6 !== start) {
          w2 = parseHex(number, start, i2 + 6);
          this.words[j2] |= w2 << off & 67108863;
          this.words[j2 + 1] |= w2 >>> 26 - off & 4194303;
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r3 = 0;
        var len = Math.min(str.length, end);
        for (var i2 = start; i2 < len; i2++) {
          var c2 = str.charCodeAt(i2) - 48;
          r3 *= mul;
          if (c2 >= 49) {
            r3 += c2 - 49 + 10;
          } else if (c2 >= 17) {
            r3 += c2 - 17 + 10;
          } else {
            r3 += c2;
          }
        }
        return r3;
      }
      BN2.prototype._parseBase = function _parseBase(number, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i2 = start; i2 < end; i2 += limbLen) {
          word = parseBase(number, i2, i2 + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i2, number.length, base);
          for (i2 = 0; i2 < mod; i2++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
      };
      BN2.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i2 = 0; i2 < this.length; i2++) {
          dest.words[i2] = this.words[i2];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN2.prototype.clone = function clone() {
        var r3 = new BN2(null);
        this.copy(r3);
        return r3;
      };
      BN2.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN2.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN2.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN2.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN2.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i2 = 0; i2 < this.length; i2++) {
            var w2 = this.words[i2];
            var word = ((w2 << off | carry) & 16777215).toString(16);
            carry = w2 >>> 24 - off & 16777215;
            if (carry !== 0 || i2 !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off += 2;
            if (off >= 26) {
              off -= 26;
              i2--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c2 = this.clone();
          c2.negative = 0;
          while (!c2.isZero()) {
            var r3 = c2.modn(groupBase).toString(base);
            c2 = c2.idivn(groupBase);
            if (!c2.isZero()) {
              out = zeros[groupSize - r3.length] + r3 + out;
            } else {
              out = r3 + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert2(false, "Base should be between 2 and 36");
      };
      BN2.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert2(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN2.prototype.toJSON = function toJSON() {
        return this.toString(16);
      };
      BN2.prototype.toBuffer = function toBuffer(endian, length) {
        assert2(typeof Buffer2 !== "undefined");
        return this.toArrayLike(Buffer2, endian, length);
      };
      BN2.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert2(byteLength <= reqLength, "byte array longer than desired length");
        assert2(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b2, i2;
        var q2 = this.clone();
        if (!littleEndian) {
          for (i2 = 0; i2 < reqLength - byteLength; i2++) {
            res[i2] = 0;
          }
          for (i2 = 0; !q2.isZero(); i2++) {
            b2 = q2.andln(255);
            q2.iushrn(8);
            res[reqLength - i2 - 1] = b2;
          }
        } else {
          for (i2 = 0; !q2.isZero(); i2++) {
            b2 = q2.andln(255);
            q2.iushrn(8);
            res[i2] = b2;
          }
          for (; i2 < reqLength; i2++) {
            res[i2] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN2.prototype._countBits = function _countBits(w2) {
          return 32 - Math.clz32(w2);
        };
      } else {
        BN2.prototype._countBits = function _countBits(w2) {
          var t = w2;
          var r3 = 0;
          if (t >= 4096) {
            r3 += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r3 += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r3 += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r3 += 2;
            t >>>= 2;
          }
          return r3 + t;
        };
      }
      BN2.prototype._zeroBits = function _zeroBits(w2) {
        if (w2 === 0) return 26;
        var t = w2;
        var r3 = 0;
        if ((t & 8191) === 0) {
          r3 += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r3 += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r3 += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r3 += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r3++;
        }
        return r3;
      };
      BN2.prototype.bitLength = function bitLength() {
        var w2 = this.words[this.length - 1];
        var hi = this._countBits(w2);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w2 = new Array(num.bitLength());
        for (var bit = 0; bit < w2.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w2[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w2;
      }
      BN2.prototype.zeroBits = function zeroBits() {
        if (this.isZero()) return 0;
        var r3 = 0;
        for (var i2 = 0; i2 < this.length; i2++) {
          var b2 = this._zeroBits(this.words[i2]);
          r3 += b2;
          if (b2 !== 26) break;
        }
        return r3;
      };
      BN2.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN2.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN2.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN2.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN2.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN2.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN2.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i2 = 0; i2 < num.length; i2++) {
          this.words[i2] = this.words[i2] | num.words[i2];
        }
        return this.strip();
      };
      BN2.prototype.ior = function ior(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN2.prototype.or = function or(num) {
        if (this.length > num.length) return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN2.prototype.uor = function uor(num) {
        if (this.length > num.length) return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN2.prototype.iuand = function iuand(num) {
        var b2;
        if (this.length > num.length) {
          b2 = num;
        } else {
          b2 = this;
        }
        for (var i2 = 0; i2 < b2.length; i2++) {
          this.words[i2] = this.words[i2] & num.words[i2];
        }
        this.length = b2.length;
        return this.strip();
      };
      BN2.prototype.iand = function iand(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN2.prototype.and = function and(num) {
        if (this.length > num.length) return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN2.prototype.uand = function uand(num) {
        if (this.length > num.length) return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN2.prototype.iuxor = function iuxor(num) {
        var a2;
        var b2;
        if (this.length > num.length) {
          a2 = this;
          b2 = num;
        } else {
          a2 = num;
          b2 = this;
        }
        for (var i2 = 0; i2 < b2.length; i2++) {
          this.words[i2] = a2.words[i2] ^ b2.words[i2];
        }
        if (this !== a2) {
          for (; i2 < a2.length; i2++) {
            this.words[i2] = a2.words[i2];
          }
        }
        this.length = a2.length;
        return this.strip();
      };
      BN2.prototype.ixor = function ixor(num) {
        assert2((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN2.prototype.xor = function xor(num) {
        if (this.length > num.length) return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN2.prototype.uxor = function uxor(num) {
        if (this.length > num.length) return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN2.prototype.inotn = function inotn(width) {
        assert2(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i2 = 0; i2 < bytesNeeded; i2++) {
          this.words[i2] = ~this.words[i2] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i2] = ~this.words[i2] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN2.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN2.prototype.setn = function setn(bit, val) {
        assert2(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN2.prototype.iadd = function iadd(num) {
        var r3;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r3 = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r3 = this.isub(num);
          num.negative = 1;
          return r3._normSign();
        }
        var a2, b2;
        if (this.length > num.length) {
          a2 = this;
          b2 = num;
        } else {
          a2 = num;
          b2 = this;
        }
        var carry = 0;
        for (var i2 = 0; i2 < b2.length; i2++) {
          r3 = (a2.words[i2] | 0) + (b2.words[i2] | 0) + carry;
          this.words[i2] = r3 & 67108863;
          carry = r3 >>> 26;
        }
        for (; carry !== 0 && i2 < a2.length; i2++) {
          r3 = (a2.words[i2] | 0) + carry;
          this.words[i2] = r3 & 67108863;
          carry = r3 >>> 26;
        }
        this.length = a2.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a2 !== this) {
          for (; i2 < a2.length; i2++) {
            this.words[i2] = a2.words[i2];
          }
        }
        return this;
      };
      BN2.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length) return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN2.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r3 = this.iadd(num);
          num.negative = 1;
          return r3._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a2, b2;
        if (cmp > 0) {
          a2 = this;
          b2 = num;
        } else {
          a2 = num;
          b2 = this;
        }
        var carry = 0;
        for (var i2 = 0; i2 < b2.length; i2++) {
          r3 = (a2.words[i2] | 0) - (b2.words[i2] | 0) + carry;
          carry = r3 >> 26;
          this.words[i2] = r3 & 67108863;
        }
        for (; carry !== 0 && i2 < a2.length; i2++) {
          r3 = (a2.words[i2] | 0) + carry;
          carry = r3 >> 26;
          this.words[i2] = r3 & 67108863;
        }
        if (carry === 0 && i2 < a2.length && a2 !== this) {
          for (; i2 < a2.length; i2++) {
            this.words[i2] = a2.words[i2];
          }
        }
        this.length = Math.max(this.length, i2);
        if (a2 !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN2.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a2 = self2.words[0] | 0;
        var b2 = num.words[0] | 0;
        var r3 = a2 * b2;
        var lo = r3 & 67108863;
        var carry = r3 / 67108864 | 0;
        out.words[0] = lo;
        for (var k2 = 1; k2 < len; k2++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k2, num.length - 1);
          for (var j2 = Math.max(0, k2 - self2.length + 1); j2 <= maxJ; j2++) {
            var i2 = k2 - j2 | 0;
            a2 = self2.words[i2] | 0;
            b2 = num.words[j2] | 0;
            r3 = a2 * b2 + rword;
            ncarry += r3 / 67108864 | 0;
            rword = r3 & 67108863;
          }
          out.words[k2] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k2] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a2 = self2.words;
        var b2 = num.words;
        var o3 = out.words;
        var c2 = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a2[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a2[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a22 = a2[2] | 0;
        var al2 = a22 & 8191;
        var ah2 = a22 >>> 13;
        var a3 = a2[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a2[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a2[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a2[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a2[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a2[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a2[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b2[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b2[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b22 = b2[2] | 0;
        var bl2 = b22 & 8191;
        var bh2 = b22 >>> 13;
        var b3 = b2[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b2[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b2[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b2[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b2[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b2[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b2[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c2 + lo | 0) + ((mid & 8191) << 13) | 0;
        c2 = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o3[0] = w0;
        o3[1] = w1;
        o3[2] = w2;
        o3[3] = w3;
        o3[4] = w4;
        o3[5] = w5;
        o3[6] = w6;
        o3[7] = w7;
        o3[8] = w8;
        o3[9] = w9;
        o3[10] = w10;
        o3[11] = w11;
        o3[12] = w12;
        o3[13] = w13;
        o3[14] = w14;
        o3[15] = w15;
        o3[16] = w16;
        o3[17] = w17;
        o3[18] = w18;
        if (c2 !== 0) {
          o3[19] = c2;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k2 = 0; k2 < out.length - 1; k2++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k2, num.length - 1);
          for (var j2 = Math.max(0, k2 - self2.length + 1); j2 <= maxJ; j2++) {
            var i2 = k2 - j2;
            var a2 = self2.words[i2] | 0;
            var b2 = num.words[j2] | 0;
            var r3 = a2 * b2;
            var lo = r3 & 67108863;
            ncarry = ncarry + (r3 / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k2] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k2] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN2.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x2, y2) {
        this.x = x2;
        this.y = y2;
      }
      FFTM.prototype.makeRBT = function makeRBT(N2) {
        var t = new Array(N2);
        var l2 = BN2.prototype._countBits(N2) - 1;
        for (var i2 = 0; i2 < N2; i2++) {
          t[i2] = this.revBin(i2, l2, N2);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x2, l2, N2) {
        if (x2 === 0 || x2 === N2 - 1) return x2;
        var rb = 0;
        for (var i2 = 0; i2 < l2; i2++) {
          rb |= (x2 & 1) << l2 - i2 - 1;
          x2 >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N2) {
        for (var i2 = 0; i2 < N2; i2++) {
          rtws[i2] = rws[rbt[i2]];
          itws[i2] = iws[rbt[i2]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N2, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N2);
        for (var s2 = 1; s2 < N2; s2 <<= 1) {
          var l2 = s2 << 1;
          var rtwdf = Math.cos(2 * Math.PI / l2);
          var itwdf = Math.sin(2 * Math.PI / l2);
          for (var p2 = 0; p2 < N2; p2 += l2) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j2 = 0; j2 < s2; j2++) {
              var re = rtws[p2 + j2];
              var ie = itws[p2 + j2];
              var ro = rtws[p2 + j2 + s2];
              var io = itws[p2 + j2 + s2];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p2 + j2] = re + ro;
              itws[p2 + j2] = ie + io;
              rtws[p2 + j2 + s2] = re - ro;
              itws[p2 + j2 + s2] = ie - io;
              if (j2 !== l2) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n2, m2) {
        var N2 = Math.max(m2, n2) | 1;
        var odd = N2 & 1;
        var i2 = 0;
        for (N2 = N2 / 2 | 0; N2; N2 = N2 >>> 1) {
          i2++;
        }
        return 1 << i2 + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N2) {
        if (N2 <= 1) return;
        for (var i2 = 0; i2 < N2 / 2; i2++) {
          var t = rws[i2];
          rws[i2] = rws[N2 - i2 - 1];
          rws[N2 - i2 - 1] = t;
          t = iws[i2];
          iws[i2] = -iws[N2 - i2 - 1];
          iws[N2 - i2 - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N2) {
        var carry = 0;
        for (var i2 = 0; i2 < N2 / 2; i2++) {
          var w2 = Math.round(ws[2 * i2 + 1] / N2) * 8192 + Math.round(ws[2 * i2] / N2) + carry;
          ws[i2] = w2 & 67108863;
          if (w2 < 67108864) {
            carry = 0;
          } else {
            carry = w2 / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N2) {
        var carry = 0;
        for (var i2 = 0; i2 < len; i2++) {
          carry = carry + (ws[i2] | 0);
          rws[2 * i2] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i2 + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i2 = 2 * len; i2 < N2; ++i2) {
          rws[i2] = 0;
        }
        assert2(carry === 0);
        assert2((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N2) {
        var ph = new Array(N2);
        for (var i2 = 0; i2 < N2; i2++) {
          ph[i2] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x2, y2, out) {
        var N2 = 2 * this.guessLen13b(x2.length, y2.length);
        var rbt = this.makeRBT(N2);
        var _2 = this.stub(N2);
        var rws = new Array(N2);
        var rwst = new Array(N2);
        var iwst = new Array(N2);
        var nrws = new Array(N2);
        var nrwst = new Array(N2);
        var niwst = new Array(N2);
        var rmws = out.words;
        rmws.length = N2;
        this.convert13b(x2.words, x2.length, rws, N2);
        this.convert13b(y2.words, y2.length, nrws, N2);
        this.transform(rws, _2, rwst, iwst, N2, rbt);
        this.transform(nrws, _2, nrwst, niwst, N2, rbt);
        for (var i2 = 0; i2 < N2; i2++) {
          var rx = rwst[i2] * nrwst[i2] - iwst[i2] * niwst[i2];
          iwst[i2] = rwst[i2] * niwst[i2] + iwst[i2] * nrwst[i2];
          rwst[i2] = rx;
        }
        this.conjugate(rwst, iwst, N2);
        this.transform(rwst, iwst, rmws, _2, N2, rbt);
        this.conjugate(rmws, _2, N2);
        this.normalize13b(rmws, N2);
        out.negative = x2.negative ^ y2.negative;
        out.length = x2.length + y2.length;
        return out.strip();
      };
      BN2.prototype.mul = function mul(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN2.prototype.mulf = function mulf(num) {
        var out = new BN2(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN2.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN2.prototype.imuln = function imuln(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        var carry = 0;
        for (var i2 = 0; i2 < this.length; i2++) {
          var w2 = (this.words[i2] | 0) * num;
          var lo = (w2 & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w2 / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i2] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i2] = carry;
          this.length++;
        }
        return this;
      };
      BN2.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN2.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN2.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN2.prototype.pow = function pow(num) {
        var w2 = toBitArray(num);
        if (w2.length === 0) return new BN2(1);
        var res = this;
        for (var i2 = 0; i2 < w2.length; i2++, res = res.sqr()) {
          if (w2[i2] !== 0) break;
        }
        if (++i2 < w2.length) {
          for (var q2 = res.sqr(); i2 < w2.length; i2++, q2 = q2.sqr()) {
            if (w2[i2] === 0) continue;
            res = res.mul(q2);
          }
        }
        return res;
      };
      BN2.prototype.iushln = function iushln(bits) {
        assert2(typeof bits === "number" && bits >= 0);
        var r3 = bits % 26;
        var s2 = (bits - r3) / 26;
        var carryMask = 67108863 >>> 26 - r3 << 26 - r3;
        var i2;
        if (r3 !== 0) {
          var carry = 0;
          for (i2 = 0; i2 < this.length; i2++) {
            var newCarry = this.words[i2] & carryMask;
            var c2 = (this.words[i2] | 0) - newCarry << r3;
            this.words[i2] = c2 | carry;
            carry = newCarry >>> 26 - r3;
          }
          if (carry) {
            this.words[i2] = carry;
            this.length++;
          }
        }
        if (s2 !== 0) {
          for (i2 = this.length - 1; i2 >= 0; i2--) {
            this.words[i2 + s2] = this.words[i2];
          }
          for (i2 = 0; i2 < s2; i2++) {
            this.words[i2] = 0;
          }
          this.length += s2;
        }
        return this.strip();
      };
      BN2.prototype.ishln = function ishln(bits) {
        assert2(this.negative === 0);
        return this.iushln(bits);
      };
      BN2.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert2(typeof bits === "number" && bits >= 0);
        var h2;
        if (hint) {
          h2 = (hint - hint % 26) / 26;
        } else {
          h2 = 0;
        }
        var r3 = bits % 26;
        var s2 = Math.min((bits - r3) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r3 << r3;
        var maskedWords = extended;
        h2 -= s2;
        h2 = Math.max(0, h2);
        if (maskedWords) {
          for (var i2 = 0; i2 < s2; i2++) {
            maskedWords.words[i2] = this.words[i2];
          }
          maskedWords.length = s2;
        }
        if (s2 === 0) {
        } else if (this.length > s2) {
          this.length -= s2;
          for (i2 = 0; i2 < this.length; i2++) {
            this.words[i2] = this.words[i2 + s2];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i2 = this.length - 1; i2 >= 0 && (carry !== 0 || i2 >= h2); i2--) {
          var word = this.words[i2] | 0;
          this.words[i2] = carry << 26 - r3 | word >>> r3;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN2.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert2(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN2.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN2.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN2.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN2.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN2.prototype.testn = function testn(bit) {
        assert2(typeof bit === "number" && bit >= 0);
        var r3 = bit % 26;
        var s2 = (bit - r3) / 26;
        var q2 = 1 << r3;
        if (this.length <= s2) return false;
        var w2 = this.words[s2];
        return !!(w2 & q2);
      };
      BN2.prototype.imaskn = function imaskn(bits) {
        assert2(typeof bits === "number" && bits >= 0);
        var r3 = bits % 26;
        var s2 = (bits - r3) / 26;
        assert2(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s2) {
          return this;
        }
        if (r3 !== 0) {
          s2++;
        }
        this.length = Math.min(s2, this.length);
        if (r3 !== 0) {
          var mask = 67108863 ^ 67108863 >>> r3 << r3;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN2.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN2.prototype.iaddn = function iaddn(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        if (num < 0) return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN2.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i2 = 0; i2 < this.length && this.words[i2] >= 67108864; i2++) {
          this.words[i2] -= 67108864;
          if (i2 === this.length - 1) {
            this.words[i2 + 1] = 1;
          } else {
            this.words[i2 + 1]++;
          }
        }
        this.length = Math.max(this.length, i2 + 1);
        return this;
      };
      BN2.prototype.isubn = function isubn(num) {
        assert2(typeof num === "number");
        assert2(num < 67108864);
        if (num < 0) return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i2 = 0; i2 < this.length && this.words[i2] < 0; i2++) {
            this.words[i2] += 67108864;
            this.words[i2 + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN2.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN2.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN2.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN2.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i2;
        this._expand(len);
        var w2;
        var carry = 0;
        for (i2 = 0; i2 < num.length; i2++) {
          w2 = (this.words[i2 + shift] | 0) + carry;
          var right = (num.words[i2] | 0) * mul;
          w2 -= right & 67108863;
          carry = (w2 >> 26) - (right / 67108864 | 0);
          this.words[i2 + shift] = w2 & 67108863;
        }
        for (; i2 < this.length - shift; i2++) {
          w2 = (this.words[i2 + shift] | 0) + carry;
          carry = w2 >> 26;
          this.words[i2 + shift] = w2 & 67108863;
        }
        if (carry === 0) return this.strip();
        assert2(carry === -1);
        carry = 0;
        for (i2 = 0; i2 < this.length; i2++) {
          w2 = -(this.words[i2] | 0) + carry;
          carry = w2 >> 26;
          this.words[i2] = w2 & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN2.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a2 = this.clone();
        var b2 = num;
        var bhi = b2.words[b2.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b2 = b2.ushln(shift);
          a2.iushln(shift);
          bhi = b2.words[b2.length - 1] | 0;
        }
        var m2 = a2.length - b2.length;
        var q2;
        if (mode !== "mod") {
          q2 = new BN2(null);
          q2.length = m2 + 1;
          q2.words = new Array(q2.length);
          for (var i2 = 0; i2 < q2.length; i2++) {
            q2.words[i2] = 0;
          }
        }
        var diff = a2.clone()._ishlnsubmul(b2, 1, m2);
        if (diff.negative === 0) {
          a2 = diff;
          if (q2) {
            q2.words[m2] = 1;
          }
        }
        for (var j2 = m2 - 1; j2 >= 0; j2--) {
          var qj = (a2.words[b2.length + j2] | 0) * 67108864 + (a2.words[b2.length + j2 - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a2._ishlnsubmul(b2, qj, j2);
          while (a2.negative !== 0) {
            qj--;
            a2.negative = 0;
            a2._ishlnsubmul(b2, 1, j2);
            if (!a2.isZero()) {
              a2.negative ^= 1;
            }
          }
          if (q2) {
            q2.words[j2] = qj;
          }
        }
        if (q2) {
          q2.strip();
        }
        a2.strip();
        if (mode !== "div" && shift !== 0) {
          a2.iushrn(shift);
        }
        return {
          div: q2 || null,
          mod: a2
        };
      };
      BN2.prototype.divmod = function divmod(num, mode, positive) {
        assert2(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN2(0),
            mod: new BN2(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN2(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN2(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN2(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN2.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN2.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN2.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN2.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero()) return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r22 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r22 === 1 && cmp === 0) return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN2.prototype.modn = function modn(num) {
        assert2(num <= 67108863);
        var p2 = (1 << 26) % num;
        var acc = 0;
        for (var i2 = this.length - 1; i2 >= 0; i2--) {
          acc = (p2 * acc + (this.words[i2] | 0)) % num;
        }
        return acc;
      };
      BN2.prototype.idivn = function idivn(num) {
        assert2(num <= 67108863);
        var carry = 0;
        for (var i2 = this.length - 1; i2 >= 0; i2--) {
          var w2 = (this.words[i2] | 0) + carry * 67108864;
          this.words[i2] = w2 / num | 0;
          carry = w2 % num;
        }
        return this.strip();
      };
      BN2.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN2.prototype.egcd = function egcd(p2) {
        assert2(p2.negative === 0);
        assert2(!p2.isZero());
        var x2 = this;
        var y2 = p2.clone();
        if (x2.negative !== 0) {
          x2 = x2.umod(p2);
        } else {
          x2 = x2.clone();
        }
        var A2 = new BN2(1);
        var B2 = new BN2(0);
        var C2 = new BN2(0);
        var D2 = new BN2(1);
        var g2 = 0;
        while (x2.isEven() && y2.isEven()) {
          x2.iushrn(1);
          y2.iushrn(1);
          ++g2;
        }
        var yp = y2.clone();
        var xp = x2.clone();
        while (!x2.isZero()) {
          for (var i2 = 0, im = 1; (x2.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1) ;
          if (i2 > 0) {
            x2.iushrn(i2);
            while (i2-- > 0) {
              if (A2.isOdd() || B2.isOdd()) {
                A2.iadd(yp);
                B2.isub(xp);
              }
              A2.iushrn(1);
              B2.iushrn(1);
            }
          }
          for (var j2 = 0, jm = 1; (y2.words[0] & jm) === 0 && j2 < 26; ++j2, jm <<= 1) ;
          if (j2 > 0) {
            y2.iushrn(j2);
            while (j2-- > 0) {
              if (C2.isOdd() || D2.isOdd()) {
                C2.iadd(yp);
                D2.isub(xp);
              }
              C2.iushrn(1);
              D2.iushrn(1);
            }
          }
          if (x2.cmp(y2) >= 0) {
            x2.isub(y2);
            A2.isub(C2);
            B2.isub(D2);
          } else {
            y2.isub(x2);
            C2.isub(A2);
            D2.isub(B2);
          }
        }
        return {
          a: C2,
          b: D2,
          gcd: y2.iushln(g2)
        };
      };
      BN2.prototype._invmp = function _invmp(p2) {
        assert2(p2.negative === 0);
        assert2(!p2.isZero());
        var a2 = this;
        var b2 = p2.clone();
        if (a2.negative !== 0) {
          a2 = a2.umod(p2);
        } else {
          a2 = a2.clone();
        }
        var x1 = new BN2(1);
        var x2 = new BN2(0);
        var delta = b2.clone();
        while (a2.cmpn(1) > 0 && b2.cmpn(1) > 0) {
          for (var i2 = 0, im = 1; (a2.words[0] & im) === 0 && i2 < 26; ++i2, im <<= 1) ;
          if (i2 > 0) {
            a2.iushrn(i2);
            while (i2-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j2 = 0, jm = 1; (b2.words[0] & jm) === 0 && j2 < 26; ++j2, jm <<= 1) ;
          if (j2 > 0) {
            b2.iushrn(j2);
            while (j2-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a2.cmp(b2) >= 0) {
            a2.isub(b2);
            x1.isub(x2);
          } else {
            b2.isub(a2);
            x2.isub(x1);
          }
        }
        var res;
        if (a2.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p2);
        }
        return res;
      };
      BN2.prototype.gcd = function gcd(num) {
        if (this.isZero()) return num.abs();
        if (num.isZero()) return this.abs();
        var a2 = this.clone();
        var b2 = num.clone();
        a2.negative = 0;
        b2.negative = 0;
        for (var shift = 0; a2.isEven() && b2.isEven(); shift++) {
          a2.iushrn(1);
          b2.iushrn(1);
        }
        do {
          while (a2.isEven()) {
            a2.iushrn(1);
          }
          while (b2.isEven()) {
            b2.iushrn(1);
          }
          var r3 = a2.cmp(b2);
          if (r3 < 0) {
            var t = a2;
            a2 = b2;
            b2 = t;
          } else if (r3 === 0 || b2.cmpn(1) === 0) {
            break;
          }
          a2.isub(b2);
        } while (true);
        return b2.iushln(shift);
      };
      BN2.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN2.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN2.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN2.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN2.prototype.bincn = function bincn(bit) {
        assert2(typeof bit === "number");
        var r3 = bit % 26;
        var s2 = (bit - r3) / 26;
        var q2 = 1 << r3;
        if (this.length <= s2) {
          this._expand(s2 + 1);
          this.words[s2] |= q2;
          return this;
        }
        var carry = q2;
        for (var i2 = s2; carry !== 0 && i2 < this.length; i2++) {
          var w2 = this.words[i2] | 0;
          w2 += carry;
          carry = w2 >>> 26;
          w2 &= 67108863;
          this.words[i2] = w2;
        }
        if (carry !== 0) {
          this.words[i2] = carry;
          this.length++;
        }
        return this;
      };
      BN2.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN2.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative) return -1;
        if (this.negative === 0 && negative) return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert2(num <= 67108863, "Number is too big");
          var w2 = this.words[0] | 0;
          res = w2 === num ? 0 : w2 < num ? -1 : 1;
        }
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN2.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0) return -1;
        if (this.negative === 0 && num.negative !== 0) return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0) return -res | 0;
        return res;
      };
      BN2.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length) return 1;
        if (this.length < num.length) return -1;
        var res = 0;
        for (var i2 = this.length - 1; i2 >= 0; i2--) {
          var a2 = this.words[i2] | 0;
          var b2 = num.words[i2] | 0;
          if (a2 === b2) continue;
          if (a2 < b2) {
            res = -1;
          } else if (a2 > b2) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN2.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN2.prototype.gt = function gt2(num) {
        return this.cmp(num) === 1;
      };
      BN2.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN2.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN2.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN2.prototype.lt = function lt2(num) {
        return this.cmp(num) === -1;
      };
      BN2.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN2.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN2.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN2.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN2.red = function red(num) {
        return new Red(num);
      };
      BN2.prototype.toRed = function toRed(ctx) {
        assert2(!this.red, "Already a number in reduction context");
        assert2(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN2.prototype.fromRed = function fromRed() {
        assert2(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN2.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN2.prototype.forceRed = function forceRed(ctx) {
        assert2(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN2.prototype.redAdd = function redAdd(num) {
        assert2(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN2.prototype.redIAdd = function redIAdd(num) {
        assert2(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN2.prototype.redSub = function redSub(num) {
        assert2(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN2.prototype.redISub = function redISub(num) {
        assert2(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN2.prototype.redShl = function redShl(num) {
        assert2(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN2.prototype.redMul = function redMul(num) {
        assert2(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN2.prototype.redIMul = function redIMul(num) {
        assert2(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN2.prototype.redSqr = function redSqr() {
        assert2(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN2.prototype.redISqr = function redISqr() {
        assert2(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN2.prototype.redSqrt = function redSqrt() {
        assert2(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN2.prototype.redInvm = function redInvm() {
        assert2(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN2.prototype.redNeg = function redNeg() {
        assert2(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN2.prototype.redPow = function redPow(num) {
        assert2(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p2) {
        this.name = name;
        this.p = new BN2(p2, 16);
        this.n = this.p.bitLength();
        this.k = new BN2(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN2(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r3 = num;
        var rlen;
        do {
          this.split(r3, this.tmp);
          r3 = this.imulK(r3);
          r3 = r3.iadd(this.tmp);
          rlen = r3.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r3.ucmp(this.p);
        if (cmp === 0) {
          r3.words[0] = 0;
          r3.length = 1;
        } else if (cmp > 0) {
          r3.isub(this.p);
        } else {
          r3.strip();
        }
        return r3;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i2 = 0; i2 < outLen; i2++) {
          output.words[i2] = input.words[i2];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i2 = 10; i2 < input.length; i2++) {
          var next = input.words[i2] | 0;
          input.words[i2 - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i2 - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i2 = 0; i2 < num.length; i2++) {
          var w2 = num.words[i2] | 0;
          lo += w2 * 977;
          num.words[i2] = lo & 67108863;
          lo = w2 * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i2 = 0; i2 < num.length; i2++) {
          var hi = (num.words[i2] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i2] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN2._prime = function prime(name) {
        if (primes[name]) return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m2) {
        if (typeof m2 === "string") {
          var prime = BN2._prime(m2);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert2(m2.gtn(1), "modulus must be greater than 1");
          this.m = m2;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a2) {
        assert2(a2.negative === 0, "red works only with positives");
        assert2(a2.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a2, b2) {
        assert2((a2.negative | b2.negative) === 0, "red works only with positives");
        assert2(
          a2.red && a2.red === b2.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a2) {
        if (this.prime) return this.prime.ireduce(a2)._forceRed(this);
        return a2.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a2) {
        if (a2.isZero()) {
          return a2.clone();
        }
        return this.m.sub(a2)._forceRed(this);
      };
      Red.prototype.add = function add(a2, b2) {
        this._verify2(a2, b2);
        var res = a2.add(b2);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a2, b2) {
        this._verify2(a2, b2);
        var res = a2.iadd(b2);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a2, b2) {
        this._verify2(a2, b2);
        var res = a2.sub(b2);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a2, b2) {
        this._verify2(a2, b2);
        var res = a2.isub(b2);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a2, num) {
        this._verify1(a2);
        return this.imod(a2.ushln(num));
      };
      Red.prototype.imul = function imul(a2, b2) {
        this._verify2(a2, b2);
        return this.imod(a2.imul(b2));
      };
      Red.prototype.mul = function mul(a2, b2) {
        this._verify2(a2, b2);
        return this.imod(a2.mul(b2));
      };
      Red.prototype.isqr = function isqr(a2) {
        return this.imul(a2, a2.clone());
      };
      Red.prototype.sqr = function sqr(a2) {
        return this.mul(a2, a2);
      };
      Red.prototype.sqrt = function sqrt(a2) {
        if (a2.isZero()) return a2.clone();
        var mod3 = this.m.andln(3);
        assert2(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN2(1)).iushrn(2);
          return this.pow(a2, pow);
        }
        var q2 = this.m.subn(1);
        var s2 = 0;
        while (!q2.isZero() && q2.andln(1) === 0) {
          s2++;
          q2.iushrn(1);
        }
        assert2(!q2.isZero());
        var one = new BN2(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z2 = this.m.bitLength();
        z2 = new BN2(2 * z2 * z2).toRed(this);
        while (this.pow(z2, lpow).cmp(nOne) !== 0) {
          z2.redIAdd(nOne);
        }
        var c2 = this.pow(z2, q2);
        var r3 = this.pow(a2, q2.addn(1).iushrn(1));
        var t = this.pow(a2, q2);
        var m2 = s2;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i2 = 0; tmp.cmp(one) !== 0; i2++) {
            tmp = tmp.redSqr();
          }
          assert2(i2 < m2);
          var b2 = this.pow(c2, new BN2(1).iushln(m2 - i2 - 1));
          r3 = r3.redMul(b2);
          c2 = b2.redSqr();
          t = t.redMul(c2);
          m2 = i2;
        }
        return r3;
      };
      Red.prototype.invm = function invm(a2) {
        var inv = a2._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a2, num) {
        if (num.isZero()) return new BN2(1).toRed(this);
        if (num.cmpn(1) === 0) return a2.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN2(1).toRed(this);
        wnd[1] = a2;
        for (var i2 = 2; i2 < wnd.length; i2++) {
          wnd[i2] = this.mul(wnd[i2 - 1], a2);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i2 = num.length - 1; i2 >= 0; i2--) {
          var word = num.words[i2];
          for (var j2 = start - 1; j2 >= 0; j2--) {
            var bit = word >> j2 & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i2 !== 0 || j2 !== 0)) continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r3 = num.umod(this.m);
        return r3 === num ? r3.clone() : r3;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN2.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m2) {
        Red.call(this, m2);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN2(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r3 = this.imod(num.mul(this.rinv));
        r3.red = null;
        return r3;
      };
      Mont.prototype.imul = function imul(a2, b2) {
        if (a2.isZero() || b2.isZero()) {
          a2.words[0] = 0;
          a2.length = 1;
          return a2;
        }
        var t = a2.imul(b2);
        var c2 = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u2 = t.isub(c2).iushrn(this.shift);
        var res = u2;
        if (u2.cmp(this.m) >= 0) {
          res = u2.isub(this.m);
        } else if (u2.cmpn(0) < 0) {
          res = u2.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a2, b2) {
        if (a2.isZero() || b2.isZero()) return new BN2(0)._forceRed(this);
        var t = a2.mul(b2);
        var c2 = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u2 = t.isub(c2).iushrn(this.shift);
        var res = u2;
        if (u2.cmp(this.m) >= 0) {
          res = u2.isub(this.m);
        } else if (u2.cmpn(0) < 0) {
          res = u2.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a2) {
        var res = this.imod(a2._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/is-typedarray/index.js
var require_is_typedarray = __commonJS({
  "node_modules/is-typedarray/index.js"(exports, module) {
    module.exports = isTypedArray2;
    isTypedArray2.strict = isStrictTypedArray;
    isTypedArray2.loose = isLooseTypedArray;
    var toString = Object.prototype.toString;
    var names = {
      "[object Int8Array]": true,
      "[object Int16Array]": true,
      "[object Int32Array]": true,
      "[object Uint8Array]": true,
      "[object Uint8ClampedArray]": true,
      "[object Uint16Array]": true,
      "[object Uint32Array]": true,
      "[object Float32Array]": true,
      "[object Float64Array]": true
    };
    function isTypedArray2(arr) {
      return isStrictTypedArray(arr) || isLooseTypedArray(arr);
    }
    function isStrictTypedArray(arr) {
      return arr instanceof Int8Array || arr instanceof Int16Array || arr instanceof Int32Array || arr instanceof Uint8Array || arr instanceof Uint8ClampedArray || arr instanceof Uint16Array || arr instanceof Uint32Array || arr instanceof Float32Array || arr instanceof Float64Array;
    }
    function isLooseTypedArray(arr) {
      return names[toString.call(arr)];
    }
  }
});

// node_modules/typedarray-to-buffer/index.js
var require_typedarray_to_buffer = __commonJS({
  "node_modules/typedarray-to-buffer/index.js"(exports, module) {
    var isTypedArray2 = require_is_typedarray().strict;
    module.exports = function typedarrayToBuffer(arr) {
      if (isTypedArray2(arr)) {
        var buf = Buffer.from(arr.buffer);
        if (arr.byteLength !== arr.buffer.byteLength) {
          buf = buf.slice(arr.byteOffset, arr.byteOffset + arr.byteLength);
        }
        return buf;
      } else {
        return Buffer.from(arr);
      }
    };
  }
});

// node_modules/js-sha3/src/sha3.js
var require_sha3 = __commonJS({
  "node_modules/js-sha3/src/sha3.js"(exports, module) {
    (function() {
      "use strict";
      var INPUT_ERROR = "input is invalid type";
      var FINALIZE_ERROR = "finalize already called";
      var WINDOW = typeof window === "object";
      var root = WINDOW ? window : {};
      if (root.JS_SHA3_NO_WINDOW) {
        WINDOW = false;
      }
      var WEB_WORKER = !WINDOW && typeof self === "object";
      var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS) {
        root = global;
      } else if (WEB_WORKER) {
        root = self;
      }
      var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && typeof module === "object" && module.exports;
      var AMD = typeof define === "function" && define.amd;
      var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS = "0123456789abcdef".split("");
      var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
      var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
      var KECCAK_PADDING = [1, 256, 65536, 16777216];
      var PADDING2 = [6, 1536, 393216, 100663296];
      var SHIFT = [0, 8, 16, 24];
      var RC = [
        1,
        0,
        32898,
        0,
        32906,
        2147483648,
        2147516416,
        2147483648,
        32907,
        0,
        2147483649,
        0,
        2147516545,
        2147483648,
        32777,
        2147483648,
        138,
        0,
        136,
        0,
        2147516425,
        0,
        2147483658,
        0,
        2147516555,
        0,
        139,
        2147483648,
        32905,
        2147483648,
        32771,
        2147483648,
        32770,
        2147483648,
        128,
        2147483648,
        32778,
        0,
        2147483658,
        2147483648,
        2147516545,
        2147483648,
        32896,
        2147483648,
        2147483649,
        0,
        2147516424,
        2147483648
      ];
      var BITS = [224, 256, 384, 512];
      var SHAKE_BITS = [128, 256];
      var OUTPUT_TYPES = ["hex", "buffer", "arrayBuffer", "array", "digest"];
      var CSHAKE_BYTEPAD = {
        "128": 168,
        "256": 136
      };
      if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
        Array.isArray = function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
      }
      if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
        ArrayBuffer.isView = function(obj) {
          return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
        };
      }
      var createOutputMethod = function(bits2, padding, outputType) {
        return function(message) {
          return new Keccak(bits2, padding, bits2).update(message)[outputType]();
        };
      };
      var createShakeOutputMethod = function(bits2, padding, outputType) {
        return function(message, outputBits) {
          return new Keccak(bits2, padding, outputBits).update(message)[outputType]();
        };
      };
      var createCshakeOutputMethod = function(bits2, padding, outputType) {
        return function(message, outputBits, n2, s2) {
          return methods["cshake" + bits2].update(message, outputBits, n2, s2)[outputType]();
        };
      };
      var createKmacOutputMethod = function(bits2, padding, outputType) {
        return function(key, message, outputBits, s2) {
          return methods["kmac" + bits2].update(key, message, outputBits, s2)[outputType]();
        };
      };
      var createOutputMethods = function(method, createMethod2, bits2, padding) {
        for (var i3 = 0; i3 < OUTPUT_TYPES.length; ++i3) {
          var type = OUTPUT_TYPES[i3];
          method[type] = createMethod2(bits2, padding, type);
        }
        return method;
      };
      var createMethod = function(bits2, padding) {
        var method = createOutputMethod(bits2, padding, "hex");
        method.create = function() {
          return new Keccak(bits2, padding, bits2);
        };
        method.update = function(message) {
          return method.create().update(message);
        };
        return createOutputMethods(method, createOutputMethod, bits2, padding);
      };
      var createShakeMethod = function(bits2, padding) {
        var method = createShakeOutputMethod(bits2, padding, "hex");
        method.create = function(outputBits) {
          return new Keccak(bits2, padding, outputBits);
        };
        method.update = function(message, outputBits) {
          return method.create(outputBits).update(message);
        };
        return createOutputMethods(method, createShakeOutputMethod, bits2, padding);
      };
      var createCshakeMethod = function(bits2, padding) {
        var w2 = CSHAKE_BYTEPAD[bits2];
        var method = createCshakeOutputMethod(bits2, padding, "hex");
        method.create = function(outputBits, n2, s2) {
          if (!n2 && !s2) {
            return methods["shake" + bits2].create(outputBits);
          } else {
            return new Keccak(bits2, padding, outputBits).bytepad([n2, s2], w2);
          }
        };
        method.update = function(message, outputBits, n2, s2) {
          return method.create(outputBits, n2, s2).update(message);
        };
        return createOutputMethods(method, createCshakeOutputMethod, bits2, padding);
      };
      var createKmacMethod = function(bits2, padding) {
        var w2 = CSHAKE_BYTEPAD[bits2];
        var method = createKmacOutputMethod(bits2, padding, "hex");
        method.create = function(key, outputBits, s2) {
          return new Kmac(bits2, padding, outputBits).bytepad(["KMAC", s2], w2).bytepad([key], w2);
        };
        method.update = function(key, message, outputBits, s2) {
          return method.create(key, outputBits, s2).update(message);
        };
        return createOutputMethods(method, createKmacOutputMethod, bits2, padding);
      };
      var algorithms = [
        { name: "keccak", padding: KECCAK_PADDING, bits: BITS, createMethod },
        { name: "sha3", padding: PADDING2, bits: BITS, createMethod },
        { name: "shake", padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
        { name: "cshake", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
        { name: "kmac", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
      ];
      var methods = {}, methodNames = [];
      for (var i2 = 0; i2 < algorithms.length; ++i2) {
        var algorithm = algorithms[i2];
        var bits = algorithm.bits;
        for (var j2 = 0; j2 < bits.length; ++j2) {
          var methodName = algorithm.name + "_" + bits[j2];
          methodNames.push(methodName);
          methods[methodName] = algorithm.createMethod(bits[j2], algorithm.padding);
          if (algorithm.name !== "sha3") {
            var newMethodName = algorithm.name + bits[j2];
            methodNames.push(newMethodName);
            methods[newMethodName] = methods[methodName];
          }
        }
      }
      function Keccak(bits2, padding, outputBits) {
        this.blocks = [];
        this.s = [];
        this.padding = padding;
        this.outputBits = outputBits;
        this.reset = true;
        this.finalized = false;
        this.block = 0;
        this.start = 0;
        this.blockCount = 1600 - (bits2 << 1) >> 5;
        this.byteCount = this.blockCount << 2;
        this.outputBlocks = outputBits >> 5;
        this.extraBytes = (outputBits & 31) >> 3;
        for (var i3 = 0; i3 < 50; ++i3) {
          this.s[i3] = 0;
        }
      }
      Keccak.prototype.update = function(message) {
        if (this.finalized) {
          throw new Error(FINALIZE_ERROR);
        }
        var notString, type = typeof message;
        if (type !== "string") {
          if (type === "object") {
            if (message === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            } else if (!Array.isArray(message)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var blocks = this.blocks, byteCount = this.byteCount, length = message.length, blockCount = this.blockCount, index = 0, s2 = this.s, i3, code;
        while (index < length) {
          if (this.reset) {
            this.reset = false;
            blocks[0] = this.block;
            for (i3 = 1; i3 < blockCount + 1; ++i3) {
              blocks[i3] = 0;
            }
          }
          if (notString) {
            for (i3 = this.start; index < length && i3 < byteCount; ++index) {
              blocks[i3 >> 2] |= message[index] << SHIFT[i3++ & 3];
            }
          } else {
            for (i3 = this.start; index < length && i3 < byteCount; ++index) {
              code = message.charCodeAt(index);
              if (code < 128) {
                blocks[i3 >> 2] |= code << SHIFT[i3++ & 3];
              } else if (code < 2048) {
                blocks[i3 >> 2] |= (192 | code >> 6) << SHIFT[i3++ & 3];
                blocks[i3 >> 2] |= (128 | code & 63) << SHIFT[i3++ & 3];
              } else if (code < 55296 || code >= 57344) {
                blocks[i3 >> 2] |= (224 | code >> 12) << SHIFT[i3++ & 3];
                blocks[i3 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i3++ & 3];
                blocks[i3 >> 2] |= (128 | code & 63) << SHIFT[i3++ & 3];
              } else {
                code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                blocks[i3 >> 2] |= (240 | code >> 18) << SHIFT[i3++ & 3];
                blocks[i3 >> 2] |= (128 | code >> 12 & 63) << SHIFT[i3++ & 3];
                blocks[i3 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i3++ & 3];
                blocks[i3 >> 2] |= (128 | code & 63) << SHIFT[i3++ & 3];
              }
            }
          }
          this.lastByteIndex = i3;
          if (i3 >= byteCount) {
            this.start = i3 - byteCount;
            this.block = blocks[blockCount];
            for (i3 = 0; i3 < blockCount; ++i3) {
              s2[i3] ^= blocks[i3];
            }
            f2(s2);
            this.reset = true;
          } else {
            this.start = i3;
          }
        }
        return this;
      };
      Keccak.prototype.encode = function(x2, right) {
        var o3 = x2 & 255, n2 = 1;
        var bytes = [o3];
        x2 = x2 >> 8;
        o3 = x2 & 255;
        while (o3 > 0) {
          bytes.unshift(o3);
          x2 = x2 >> 8;
          o3 = x2 & 255;
          ++n2;
        }
        if (right) {
          bytes.push(n2);
        } else {
          bytes.unshift(n2);
        }
        this.update(bytes);
        return bytes.length;
      };
      Keccak.prototype.encodeString = function(str) {
        var notString, type = typeof str;
        if (type !== "string") {
          if (type === "object") {
            if (str === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
              str = new Uint8Array(str);
            } else if (!Array.isArray(str)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var bytes = 0, length = str.length;
        if (notString) {
          bytes = length;
        } else {
          for (var i3 = 0; i3 < str.length; ++i3) {
            var code = str.charCodeAt(i3);
            if (code < 128) {
              bytes += 1;
            } else if (code < 2048) {
              bytes += 2;
            } else if (code < 55296 || code >= 57344) {
              bytes += 3;
            } else {
              code = 65536 + ((code & 1023) << 10 | str.charCodeAt(++i3) & 1023);
              bytes += 4;
            }
          }
        }
        bytes += this.encode(bytes * 8);
        this.update(str);
        return bytes;
      };
      Keccak.prototype.bytepad = function(strs, w2) {
        var bytes = this.encode(w2);
        for (var i3 = 0; i3 < strs.length; ++i3) {
          bytes += this.encodeString(strs[i3]);
        }
        var paddingBytes = w2 - bytes % w2;
        var zeros = [];
        zeros.length = paddingBytes;
        this.update(zeros);
        return this;
      };
      Keccak.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks = this.blocks, i3 = this.lastByteIndex, blockCount = this.blockCount, s2 = this.s;
        blocks[i3 >> 2] |= this.padding[i3 & 3];
        if (this.lastByteIndex === this.byteCount) {
          blocks[0] = blocks[blockCount];
          for (i3 = 1; i3 < blockCount + 1; ++i3) {
            blocks[i3] = 0;
          }
        }
        blocks[blockCount - 1] |= 2147483648;
        for (i3 = 0; i3 < blockCount; ++i3) {
          s2[i3] ^= blocks[i3];
        }
        f2(s2);
      };
      Keccak.prototype.toString = Keccak.prototype.hex = function() {
        this.finalize();
        var blockCount = this.blockCount, s2 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i3 = 0, j3 = 0;
        var hex = "", block;
        while (j3 < outputBlocks) {
          for (i3 = 0; i3 < blockCount && j3 < outputBlocks; ++i3, ++j3) {
            block = s2[i3];
            hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15] + HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15] + HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15] + HEX_CHARS[block >> 28 & 15] + HEX_CHARS[block >> 24 & 15];
          }
          if (j3 % blockCount === 0) {
            f2(s2);
            i3 = 0;
          }
        }
        if (extraBytes) {
          block = s2[i3];
          hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15];
          if (extraBytes > 1) {
            hex += HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15];
          }
          if (extraBytes > 2) {
            hex += HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15];
          }
        }
        return hex;
      };
      Keccak.prototype.arrayBuffer = function() {
        this.finalize();
        var blockCount = this.blockCount, s2 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i3 = 0, j3 = 0;
        var bytes = this.outputBits >> 3;
        var buffer;
        if (extraBytes) {
          buffer = new ArrayBuffer(outputBlocks + 1 << 2);
        } else {
          buffer = new ArrayBuffer(bytes);
        }
        var array = new Uint32Array(buffer);
        while (j3 < outputBlocks) {
          for (i3 = 0; i3 < blockCount && j3 < outputBlocks; ++i3, ++j3) {
            array[j3] = s2[i3];
          }
          if (j3 % blockCount === 0) {
            f2(s2);
          }
        }
        if (extraBytes) {
          array[i3] = s2[i3];
          buffer = buffer.slice(0, bytes);
        }
        return buffer;
      };
      Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;
      Keccak.prototype.digest = Keccak.prototype.array = function() {
        this.finalize();
        var blockCount = this.blockCount, s2 = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i3 = 0, j3 = 0;
        var array = [], offset, block;
        while (j3 < outputBlocks) {
          for (i3 = 0; i3 < blockCount && j3 < outputBlocks; ++i3, ++j3) {
            offset = j3 << 2;
            block = s2[i3];
            array[offset] = block & 255;
            array[offset + 1] = block >> 8 & 255;
            array[offset + 2] = block >> 16 & 255;
            array[offset + 3] = block >> 24 & 255;
          }
          if (j3 % blockCount === 0) {
            f2(s2);
          }
        }
        if (extraBytes) {
          offset = j3 << 2;
          block = s2[i3];
          array[offset] = block & 255;
          if (extraBytes > 1) {
            array[offset + 1] = block >> 8 & 255;
          }
          if (extraBytes > 2) {
            array[offset + 2] = block >> 16 & 255;
          }
        }
        return array;
      };
      function Kmac(bits2, padding, outputBits) {
        Keccak.call(this, bits2, padding, outputBits);
      }
      Kmac.prototype = new Keccak();
      Kmac.prototype.finalize = function() {
        this.encode(this.outputBits, true);
        return Keccak.prototype.finalize.call(this);
      };
      var f2 = function(s2) {
        var h2, l2, n2, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
        for (n2 = 0; n2 < 48; n2 += 2) {
          c0 = s2[0] ^ s2[10] ^ s2[20] ^ s2[30] ^ s2[40];
          c1 = s2[1] ^ s2[11] ^ s2[21] ^ s2[31] ^ s2[41];
          c2 = s2[2] ^ s2[12] ^ s2[22] ^ s2[32] ^ s2[42];
          c3 = s2[3] ^ s2[13] ^ s2[23] ^ s2[33] ^ s2[43];
          c4 = s2[4] ^ s2[14] ^ s2[24] ^ s2[34] ^ s2[44];
          c5 = s2[5] ^ s2[15] ^ s2[25] ^ s2[35] ^ s2[45];
          c6 = s2[6] ^ s2[16] ^ s2[26] ^ s2[36] ^ s2[46];
          c7 = s2[7] ^ s2[17] ^ s2[27] ^ s2[37] ^ s2[47];
          c8 = s2[8] ^ s2[18] ^ s2[28] ^ s2[38] ^ s2[48];
          c9 = s2[9] ^ s2[19] ^ s2[29] ^ s2[39] ^ s2[49];
          h2 = c8 ^ (c2 << 1 | c3 >>> 31);
          l2 = c9 ^ (c3 << 1 | c2 >>> 31);
          s2[0] ^= h2;
          s2[1] ^= l2;
          s2[10] ^= h2;
          s2[11] ^= l2;
          s2[20] ^= h2;
          s2[21] ^= l2;
          s2[30] ^= h2;
          s2[31] ^= l2;
          s2[40] ^= h2;
          s2[41] ^= l2;
          h2 = c0 ^ (c4 << 1 | c5 >>> 31);
          l2 = c1 ^ (c5 << 1 | c4 >>> 31);
          s2[2] ^= h2;
          s2[3] ^= l2;
          s2[12] ^= h2;
          s2[13] ^= l2;
          s2[22] ^= h2;
          s2[23] ^= l2;
          s2[32] ^= h2;
          s2[33] ^= l2;
          s2[42] ^= h2;
          s2[43] ^= l2;
          h2 = c2 ^ (c6 << 1 | c7 >>> 31);
          l2 = c3 ^ (c7 << 1 | c6 >>> 31);
          s2[4] ^= h2;
          s2[5] ^= l2;
          s2[14] ^= h2;
          s2[15] ^= l2;
          s2[24] ^= h2;
          s2[25] ^= l2;
          s2[34] ^= h2;
          s2[35] ^= l2;
          s2[44] ^= h2;
          s2[45] ^= l2;
          h2 = c4 ^ (c8 << 1 | c9 >>> 31);
          l2 = c5 ^ (c9 << 1 | c8 >>> 31);
          s2[6] ^= h2;
          s2[7] ^= l2;
          s2[16] ^= h2;
          s2[17] ^= l2;
          s2[26] ^= h2;
          s2[27] ^= l2;
          s2[36] ^= h2;
          s2[37] ^= l2;
          s2[46] ^= h2;
          s2[47] ^= l2;
          h2 = c6 ^ (c0 << 1 | c1 >>> 31);
          l2 = c7 ^ (c1 << 1 | c0 >>> 31);
          s2[8] ^= h2;
          s2[9] ^= l2;
          s2[18] ^= h2;
          s2[19] ^= l2;
          s2[28] ^= h2;
          s2[29] ^= l2;
          s2[38] ^= h2;
          s2[39] ^= l2;
          s2[48] ^= h2;
          s2[49] ^= l2;
          b0 = s2[0];
          b1 = s2[1];
          b32 = s2[11] << 4 | s2[10] >>> 28;
          b33 = s2[10] << 4 | s2[11] >>> 28;
          b14 = s2[20] << 3 | s2[21] >>> 29;
          b15 = s2[21] << 3 | s2[20] >>> 29;
          b46 = s2[31] << 9 | s2[30] >>> 23;
          b47 = s2[30] << 9 | s2[31] >>> 23;
          b28 = s2[40] << 18 | s2[41] >>> 14;
          b29 = s2[41] << 18 | s2[40] >>> 14;
          b20 = s2[2] << 1 | s2[3] >>> 31;
          b21 = s2[3] << 1 | s2[2] >>> 31;
          b2 = s2[13] << 12 | s2[12] >>> 20;
          b3 = s2[12] << 12 | s2[13] >>> 20;
          b34 = s2[22] << 10 | s2[23] >>> 22;
          b35 = s2[23] << 10 | s2[22] >>> 22;
          b16 = s2[33] << 13 | s2[32] >>> 19;
          b17 = s2[32] << 13 | s2[33] >>> 19;
          b48 = s2[42] << 2 | s2[43] >>> 30;
          b49 = s2[43] << 2 | s2[42] >>> 30;
          b40 = s2[5] << 30 | s2[4] >>> 2;
          b41 = s2[4] << 30 | s2[5] >>> 2;
          b22 = s2[14] << 6 | s2[15] >>> 26;
          b23 = s2[15] << 6 | s2[14] >>> 26;
          b4 = s2[25] << 11 | s2[24] >>> 21;
          b5 = s2[24] << 11 | s2[25] >>> 21;
          b36 = s2[34] << 15 | s2[35] >>> 17;
          b37 = s2[35] << 15 | s2[34] >>> 17;
          b18 = s2[45] << 29 | s2[44] >>> 3;
          b19 = s2[44] << 29 | s2[45] >>> 3;
          b10 = s2[6] << 28 | s2[7] >>> 4;
          b11 = s2[7] << 28 | s2[6] >>> 4;
          b42 = s2[17] << 23 | s2[16] >>> 9;
          b43 = s2[16] << 23 | s2[17] >>> 9;
          b24 = s2[26] << 25 | s2[27] >>> 7;
          b25 = s2[27] << 25 | s2[26] >>> 7;
          b6 = s2[36] << 21 | s2[37] >>> 11;
          b7 = s2[37] << 21 | s2[36] >>> 11;
          b38 = s2[47] << 24 | s2[46] >>> 8;
          b39 = s2[46] << 24 | s2[47] >>> 8;
          b30 = s2[8] << 27 | s2[9] >>> 5;
          b31 = s2[9] << 27 | s2[8] >>> 5;
          b12 = s2[18] << 20 | s2[19] >>> 12;
          b13 = s2[19] << 20 | s2[18] >>> 12;
          b44 = s2[29] << 7 | s2[28] >>> 25;
          b45 = s2[28] << 7 | s2[29] >>> 25;
          b26 = s2[38] << 8 | s2[39] >>> 24;
          b27 = s2[39] << 8 | s2[38] >>> 24;
          b8 = s2[48] << 14 | s2[49] >>> 18;
          b9 = s2[49] << 14 | s2[48] >>> 18;
          s2[0] = b0 ^ ~b2 & b4;
          s2[1] = b1 ^ ~b3 & b5;
          s2[10] = b10 ^ ~b12 & b14;
          s2[11] = b11 ^ ~b13 & b15;
          s2[20] = b20 ^ ~b22 & b24;
          s2[21] = b21 ^ ~b23 & b25;
          s2[30] = b30 ^ ~b32 & b34;
          s2[31] = b31 ^ ~b33 & b35;
          s2[40] = b40 ^ ~b42 & b44;
          s2[41] = b41 ^ ~b43 & b45;
          s2[2] = b2 ^ ~b4 & b6;
          s2[3] = b3 ^ ~b5 & b7;
          s2[12] = b12 ^ ~b14 & b16;
          s2[13] = b13 ^ ~b15 & b17;
          s2[22] = b22 ^ ~b24 & b26;
          s2[23] = b23 ^ ~b25 & b27;
          s2[32] = b32 ^ ~b34 & b36;
          s2[33] = b33 ^ ~b35 & b37;
          s2[42] = b42 ^ ~b44 & b46;
          s2[43] = b43 ^ ~b45 & b47;
          s2[4] = b4 ^ ~b6 & b8;
          s2[5] = b5 ^ ~b7 & b9;
          s2[14] = b14 ^ ~b16 & b18;
          s2[15] = b15 ^ ~b17 & b19;
          s2[24] = b24 ^ ~b26 & b28;
          s2[25] = b25 ^ ~b27 & b29;
          s2[34] = b34 ^ ~b36 & b38;
          s2[35] = b35 ^ ~b37 & b39;
          s2[44] = b44 ^ ~b46 & b48;
          s2[45] = b45 ^ ~b47 & b49;
          s2[6] = b6 ^ ~b8 & b0;
          s2[7] = b7 ^ ~b9 & b1;
          s2[16] = b16 ^ ~b18 & b10;
          s2[17] = b17 ^ ~b19 & b11;
          s2[26] = b26 ^ ~b28 & b20;
          s2[27] = b27 ^ ~b29 & b21;
          s2[36] = b36 ^ ~b38 & b30;
          s2[37] = b37 ^ ~b39 & b31;
          s2[46] = b46 ^ ~b48 & b40;
          s2[47] = b47 ^ ~b49 & b41;
          s2[8] = b8 ^ ~b0 & b2;
          s2[9] = b9 ^ ~b1 & b3;
          s2[18] = b18 ^ ~b10 & b12;
          s2[19] = b19 ^ ~b11 & b13;
          s2[28] = b28 ^ ~b20 & b22;
          s2[29] = b29 ^ ~b21 & b23;
          s2[38] = b38 ^ ~b30 & b32;
          s2[39] = b39 ^ ~b31 & b33;
          s2[48] = b48 ^ ~b40 & b42;
          s2[49] = b49 ^ ~b41 & b43;
          s2[0] ^= RC[n2];
          s2[1] ^= RC[n2 + 1];
        }
      };
      if (COMMON_JS) {
        module.exports = methods;
      } else {
        for (i2 = 0; i2 < methodNames.length; ++i2) {
          root[methodNames[i2]] = methods[methodNames[i2]];
        }
        if (AMD) {
          define(function() {
            return methods;
          });
        }
      }
    })();
  }
});

// node_modules/tslib/tslib.es6.js
var tslib_es6_exports = {};
__export(tslib_es6_exports, {
  __assign: () => __assign,
  __asyncDelegator: () => __asyncDelegator,
  __asyncGenerator: () => __asyncGenerator,
  __asyncValues: () => __asyncValues,
  __await: () => __await,
  __awaiter: () => __awaiter,
  __classPrivateFieldGet: () => __classPrivateFieldGet,
  __classPrivateFieldSet: () => __classPrivateFieldSet,
  __createBinding: () => __createBinding,
  __decorate: () => __decorate,
  __exportStar: () => __exportStar,
  __extends: () => __extends,
  __generator: () => __generator,
  __importDefault: () => __importDefault,
  __importStar: () => __importStar,
  __makeTemplateObject: () => __makeTemplateObject,
  __metadata: () => __metadata,
  __param: () => __param,
  __read: () => __read,
  __rest: () => __rest,
  __spread: () => __spread,
  __spreadArrays: () => __spreadArrays2,
  __values: () => __values2
});
function __extends(d2, b2) {
  extendStatics(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
function __rest(s2, e2) {
  var t = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
    t[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t[p2[i2]] = s2[p2[i2]];
    }
  return t;
}
function __decorate(decorators, target, key, desc) {
  var c2 = arguments.length, r3 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r3 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r3 = (c2 < 3 ? d2(r3) : c2 > 3 ? d2(target, key, r3) : d2(target, key)) || r3;
  return c2 > 3 && r3 && Object.defineProperty(target, key, r3), r3;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f2, y2, t, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2) throw new TypeError("Generator is already executing.");
    while (_2) try {
      if (f2 = 1, y2 && (t = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t = y2["return"]) && t.call(y2), 0) : y2.next) && !(t = t.call(y2, op[1])).done) return t;
      if (y2 = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _2.label++;
          return { value: op[1], done: false };
        case 5:
          _2.label++;
          y2 = op[1];
          op = [0];
          continue;
        case 7:
          op = _2.ops.pop();
          _2.trys.pop();
          continue;
        default:
          if (!(t = _2.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _2 = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _2.label = op[1];
            break;
          }
          if (op[0] === 6 && _2.label < t[1]) {
            _2.label = t[1];
            t = op;
            break;
          }
          if (t && _2.label < t[2]) {
            _2.label = t[2];
            _2.ops.push(op);
            break;
          }
          if (t[2]) _2.ops.pop();
          _2.trys.pop();
          continue;
      }
      op = body.call(thisArg, _2);
    } catch (e2) {
      op = [6, e2];
      y2 = 0;
    } finally {
      f2 = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __createBinding(o3, m2, k2, k22) {
  if (k22 === void 0) k22 = k2;
  o3[k22] = m2[k2];
}
function __exportStar(m2, exports) {
  for (var p2 in m2) if (p2 !== "default" && !exports.hasOwnProperty(p2)) exports[p2] = m2[p2];
}
function __values2(o3) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o3[s2], i2 = 0;
  if (m2) return m2.call(o3);
  if (o3 && typeof o3.length === "number") return {
    next: function() {
      if (o3 && i2 >= o3.length) o3 = void 0;
      return { value: o3 && o3[i2++], done: !o3 };
    }
  };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o3, n2) {
  var m2 = typeof Symbol === "function" && o3[Symbol.iterator];
  if (!m2) return o3;
  var i2 = m2.call(o3), r3, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r3 = i2.next()).done) ar.push(r3.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r3 && !r3.done && (m2 = i2["return"])) m2.call(i2);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i2 = 0; i2 < arguments.length; i2++)
    ar = ar.concat(__read(arguments[i2]));
  return ar;
}
function __spreadArrays2() {
  for (var s2 = 0, i2 = 0, il = arguments.length; i2 < il; i2++) s2 += arguments[i2].length;
  for (var r3 = Array(s2), k2 = 0, i2 = 0; i2 < il; i2++)
    for (var a2 = arguments[i2], j2 = 0, jl = a2.length; j2 < jl; j2++, k2++)
      r3[k2] = a2[j2];
  return r3;
}
function __await(v2) {
  return this instanceof __await ? (this.v = v2, this) : new __await(v2);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g2 = generator.apply(thisArg, _arguments || []), i2, q2 = [];
  return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2;
  function verb(n2) {
    if (g2[n2]) i2[n2] = function(v2) {
      return new Promise(function(a2, b2) {
        q2.push([n2, v2, a2, b2]) > 1 || resume(n2, v2);
      });
    };
  }
  function resume(n2, v2) {
    try {
      step(g2[n2](v2));
    } catch (e2) {
      settle(q2[0][3], e2);
    }
  }
  function step(r3) {
    r3.value instanceof __await ? Promise.resolve(r3.value.v).then(fulfill, reject) : settle(q2[0][2], r3);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f2, v2) {
    if (f2(v2), q2.shift(), q2.length) resume(q2[0][0], q2[0][1]);
  }
}
function __asyncDelegator(o3) {
  var i2, p2;
  return i2 = {}, verb("next"), verb("throw", function(e2) {
    throw e2;
  }), verb("return"), i2[Symbol.iterator] = function() {
    return this;
  }, i2;
  function verb(n2, f2) {
    i2[n2] = o3[n2] ? function(v2) {
      return (p2 = !p2) ? { value: __await(o3[n2](v2)), done: n2 === "return" } : f2 ? f2(v2) : v2;
    } : f2;
  }
}
function __asyncValues(o3) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m2 = o3[Symbol.asyncIterator], i2;
  return m2 ? m2.call(o3) : (o3 = typeof __values2 === "function" ? __values2(o3) : o3[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2);
  function verb(n2) {
    i2[n2] = o3[n2] && function(v2) {
      return new Promise(function(resolve, reject) {
        v2 = o3[n2](v2), settle(resolve, reject, v2.done, v2.value);
      });
    };
  }
  function settle(resolve, reject, d2, v2) {
    Promise.resolve(v2).then(function(v3) {
      resolve({ value: v3, done: d2 });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) {
    for (var k2 in mod) if (Object.hasOwnProperty.call(mod, k2)) result[k2] = mod[k2];
  }
  result.default = mod;
  return result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, privateMap) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return privateMap.get(receiver);
}
function __classPrivateFieldSet(receiver, privateMap, value) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to set private field on non-instance");
  }
  privateMap.set(receiver, value);
  return value;
}
var extendStatics, __assign;
var init_tslib_es6 = __esm({
  "node_modules/tslib/tslib.es6.js"() {
    extendStatics = function(d2, b2) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
        d3.__proto__ = b3;
      } || function(d3, b3) {
        for (var p2 in b3) if (b3.hasOwnProperty(p2)) d3[p2] = b3[p2];
      };
      return extendStatics(d2, b2);
    };
    __assign = function() {
      __assign = Object.assign || function __assign2(t) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2)) t[p2] = s2[p2];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
  }
});

// node_modules/@walletconnect/environment/dist/cjs/crypto.js
var require_crypto = __commonJS({
  "node_modules/@walletconnect/environment/dist/cjs/crypto.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isBrowserCryptoAvailable = exports.getSubtleCrypto = exports.getBrowerCrypto = void 0;
    function getBrowerCrypto2() {
      return (global === null || global === void 0 ? void 0 : global.crypto) || (global === null || global === void 0 ? void 0 : global.msCrypto) || {};
    }
    exports.getBrowerCrypto = getBrowerCrypto2;
    function getSubtleCrypto2() {
      const browserCrypto = getBrowerCrypto2();
      return browserCrypto.subtle || browserCrypto.webkitSubtle;
    }
    exports.getSubtleCrypto = getSubtleCrypto2;
    function isBrowserCryptoAvailable() {
      return !!getBrowerCrypto2() && !!getSubtleCrypto2();
    }
    exports.isBrowserCryptoAvailable = isBrowserCryptoAvailable;
  }
});

// node_modules/@walletconnect/environment/dist/cjs/env.js
var require_env = __commonJS({
  "node_modules/@walletconnect/environment/dist/cjs/env.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isBrowser = exports.isNode = exports.isReactNative = void 0;
    function isReactNative2() {
      return typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative";
    }
    exports.isReactNative = isReactNative2;
    function isNode4() {
      return typeof process !== "undefined" && typeof process.versions !== "undefined" && typeof process.versions.node !== "undefined";
    }
    exports.isNode = isNode4;
    function isBrowser2() {
      return !isReactNative2() && !isNode4();
    }
    exports.isBrowser = isBrowser2;
  }
});

// node_modules/@walletconnect/environment/dist/cjs/index.js
var require_cjs3 = __commonJS({
  "node_modules/@walletconnect/environment/dist/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    tslib_1.__exportStar(require_crypto(), exports);
    tslib_1.__exportStar(require_env(), exports);
  }
});

// node_modules/strict-uri-encode/index.js
var require_strict_uri_encode = __commonJS({
  "node_modules/strict-uri-encode/index.js"(exports, module) {
    "use strict";
    module.exports = (str) => encodeURIComponent(str).replace(/[!'()*]/g, (x2) => `%${x2.charCodeAt(0).toString(16).toUpperCase()}`);
  }
});

// node_modules/decode-uri-component/index.js
var require_decode_uri_component = __commonJS({
  "node_modules/decode-uri-component/index.js"(exports, module) {
    "use strict";
    var token = "%[a-f0-9]{2}";
    var singleMatcher = new RegExp("(" + token + ")|([^%]+?)", "gi");
    var multiMatcher = new RegExp("(" + token + ")+", "gi");
    function decodeComponents(components, split) {
      try {
        return [decodeURIComponent(components.join(""))];
      } catch (err) {
      }
      if (components.length === 1) {
        return components;
      }
      split = split || 1;
      var left = components.slice(0, split);
      var right = components.slice(split);
      return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
    }
    function decode3(input) {
      try {
        return decodeURIComponent(input);
      } catch (err) {
        var tokens = input.match(singleMatcher) || [];
        for (var i2 = 1; i2 < tokens.length; i2++) {
          input = decodeComponents(tokens, i2).join("");
          tokens = input.match(singleMatcher) || [];
        }
        return input;
      }
    }
    function customDecodeURIComponent(input) {
      var replaceMap = {
        "%FE%FF": "��",
        "%FF%FE": "��"
      };
      var match = multiMatcher.exec(input);
      while (match) {
        try {
          replaceMap[match[0]] = decodeURIComponent(match[0]);
        } catch (err) {
          var result = decode3(match[0]);
          if (result !== match[0]) {
            replaceMap[match[0]] = result;
          }
        }
        match = multiMatcher.exec(input);
      }
      replaceMap["%C2"] = "�";
      var entries = Object.keys(replaceMap);
      for (var i2 = 0; i2 < entries.length; i2++) {
        var key = entries[i2];
        input = input.replace(new RegExp(key, "g"), replaceMap[key]);
      }
      return input;
    }
    module.exports = function(encodedURI) {
      if (typeof encodedURI !== "string") {
        throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
      }
      try {
        encodedURI = encodedURI.replace(/\+/g, " ");
        return decodeURIComponent(encodedURI);
      } catch (err) {
        return customDecodeURIComponent(encodedURI);
      }
    };
  }
});

// node_modules/split-on-first/index.js
var require_split_on_first = __commonJS({
  "node_modules/split-on-first/index.js"(exports, module) {
    "use strict";
    module.exports = (string, separator) => {
      if (!(typeof string === "string" && typeof separator === "string")) {
        throw new TypeError("Expected the arguments to be of type `string`");
      }
      if (separator === "") {
        return [string];
      }
      const separatorIndex = string.indexOf(separator);
      if (separatorIndex === -1) {
        return [string];
      }
      return [
        string.slice(0, separatorIndex),
        string.slice(separatorIndex + separator.length)
      ];
    };
  }
});

// node_modules/query-string/index.js
var require_query_string = __commonJS({
  "node_modules/query-string/index.js"(exports) {
    "use strict";
    var strictUriEncode = require_strict_uri_encode();
    var decodeComponent = require_decode_uri_component();
    var splitOnFirst = require_split_on_first();
    var isNullOrUndefined = (value) => value === null || value === void 0;
    function encoderForArrayFormat(options) {
      switch (options.arrayFormat) {
        case "index":
          return (key) => (result, value) => {
            const index = result.length;
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode2(key, options), "[", index, "]"].join("")];
            }
            return [
              ...result,
              [encode2(key, options), "[", encode2(index, options), "]=", encode2(value, options)].join("")
            ];
          };
        case "bracket":
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, [encode2(key, options), "[]"].join("")];
            }
            return [...result, [encode2(key, options), "[]=", encode2(value, options)].join("")];
          };
        case "comma":
        case "separator":
          return (key) => (result, value) => {
            if (value === null || value === void 0 || value.length === 0) {
              return result;
            }
            if (result.length === 0) {
              return [[encode2(key, options), "=", encode2(value, options)].join("")];
            }
            return [[result, encode2(value, options)].join(options.arrayFormatSeparator)];
          };
        default:
          return (key) => (result, value) => {
            if (value === void 0 || options.skipNull && value === null || options.skipEmptyString && value === "") {
              return result;
            }
            if (value === null) {
              return [...result, encode2(key, options)];
            }
            return [...result, [encode2(key, options), "=", encode2(value, options)].join("")];
          };
      }
    }
    function parserForArrayFormat(options) {
      let result;
      switch (options.arrayFormat) {
        case "index":
          return (key, value, accumulator) => {
            result = /\[(\d*)\]$/.exec(key);
            key = key.replace(/\[\d*\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = {};
            }
            accumulator[key][result[1]] = value;
          };
        case "bracket":
          return (key, value, accumulator) => {
            result = /(\[\])$/.exec(key);
            key = key.replace(/\[\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        case "comma":
        case "separator":
          return (key, value, accumulator) => {
            const isArray = typeof value === "string" && value.split("").indexOf(options.arrayFormatSeparator) > -1;
            const newValue = isArray ? value.split(options.arrayFormatSeparator).map((item) => decode3(item, options)) : value === null ? value : decode3(value, options);
            accumulator[key] = newValue;
          };
        default:
          return (key, value, accumulator) => {
            if (accumulator[key] === void 0) {
              accumulator[key] = value;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
      }
    }
    function validateArrayFormatSeparator(value) {
      if (typeof value !== "string" || value.length !== 1) {
        throw new TypeError("arrayFormatSeparator must be single character string");
      }
    }
    function encode2(value, options) {
      if (options.encode) {
        return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
      }
      return value;
    }
    function decode3(value, options) {
      if (options.decode) {
        return decodeComponent(value);
      }
      return value;
    }
    function keysSorter(input) {
      if (Array.isArray(input)) {
        return input.sort();
      }
      if (typeof input === "object") {
        return keysSorter(Object.keys(input)).sort((a2, b2) => Number(a2) - Number(b2)).map((key) => input[key]);
      }
      return input;
    }
    function removeHash(input) {
      const hashStart = input.indexOf("#");
      if (hashStart !== -1) {
        input = input.slice(0, hashStart);
      }
      return input;
    }
    function getHash(url) {
      let hash = "";
      const hashStart = url.indexOf("#");
      if (hashStart !== -1) {
        hash = url.slice(hashStart);
      }
      return hash;
    }
    function extract(input) {
      input = removeHash(input);
      const queryStart = input.indexOf("?");
      if (queryStart === -1) {
        return "";
      }
      return input.slice(queryStart + 1);
    }
    function parseValue(value, options) {
      if (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
        value = Number(value);
      } else if (options.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
        value = value.toLowerCase() === "true";
      }
      return value;
    }
    function parse2(input, options) {
      options = Object.assign({
        decode: true,
        sort: true,
        arrayFormat: "none",
        arrayFormatSeparator: ",",
        parseNumbers: false,
        parseBooleans: false
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const formatter = parserForArrayFormat(options);
      const ret = /* @__PURE__ */ Object.create(null);
      if (typeof input !== "string") {
        return ret;
      }
      input = input.trim().replace(/^[?#&]/, "");
      if (!input) {
        return ret;
      }
      for (const param of input.split("&")) {
        let [key, value] = splitOnFirst(options.decode ? param.replace(/\+/g, " ") : param, "=");
        value = value === void 0 ? null : ["comma", "separator"].includes(options.arrayFormat) ? value : decode3(value, options);
        formatter(decode3(key, options), value, ret);
      }
      for (const key of Object.keys(ret)) {
        const value = ret[key];
        if (typeof value === "object" && value !== null) {
          for (const k2 of Object.keys(value)) {
            value[k2] = parseValue(value[k2], options);
          }
        } else {
          ret[key] = parseValue(value, options);
        }
      }
      if (options.sort === false) {
        return ret;
      }
      return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {
        const value = ret[key];
        if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
          result[key] = keysSorter(value);
        } else {
          result[key] = value;
        }
        return result;
      }, /* @__PURE__ */ Object.create(null));
    }
    exports.extract = extract;
    exports.parse = parse2;
    exports.stringify = (object, options) => {
      if (!object) {
        return "";
      }
      options = Object.assign({
        encode: true,
        strict: true,
        arrayFormat: "none",
        arrayFormatSeparator: ","
      }, options);
      validateArrayFormatSeparator(options.arrayFormatSeparator);
      const shouldFilter = (key) => options.skipNull && isNullOrUndefined(object[key]) || options.skipEmptyString && object[key] === "";
      const formatter = encoderForArrayFormat(options);
      const objectCopy = {};
      for (const key of Object.keys(object)) {
        if (!shouldFilter(key)) {
          objectCopy[key] = object[key];
        }
      }
      const keys = Object.keys(objectCopy);
      if (options.sort !== false) {
        keys.sort(options.sort);
      }
      return keys.map((key) => {
        const value = object[key];
        if (value === void 0) {
          return "";
        }
        if (value === null) {
          return encode2(key, options);
        }
        if (Array.isArray(value)) {
          return value.reduce(formatter(key), []).join("&");
        }
        return encode2(key, options) + "=" + encode2(value, options);
      }).filter((x2) => x2.length > 0).join("&");
    };
    exports.parseUrl = (input, options) => {
      options = Object.assign({
        decode: true
      }, options);
      const [url, hash] = splitOnFirst(input, "#");
      return Object.assign(
        {
          url: url.split("?")[0] || "",
          query: parse2(extract(input), options)
        },
        options && options.parseFragmentIdentifier && hash ? { fragmentIdentifier: decode3(hash, options) } : {}
      );
    };
    exports.stringifyUrl = (input, options) => {
      options = Object.assign({
        encode: true,
        strict: true
      }, options);
      const url = removeHash(input.url).split("?")[0] || "";
      const queryFromUrl = exports.extract(input.url);
      const parsedQueryFromUrl = exports.parse(queryFromUrl, { sort: false });
      const query = Object.assign(parsedQueryFromUrl, input.query);
      let queryString = exports.stringify(query, options);
      if (queryString) {
        queryString = `?${queryString}`;
      }
      let hash = getHash(input.url);
      if (input.fragmentIdentifier) {
        hash = `#${encode2(input.fragmentIdentifier, options)}`;
      }
      return `${url}${queryString}${hash}`;
    };
  }
});

// node_modules/ws/browser.js
var require_browser = __commonJS({
  "node_modules/ws/browser.js"(exports, module) {
    "use strict";
    module.exports = function() {
      throw new Error(
        "ws does not work in the browser. Browser clients must use the native WebSocket object"
      );
    };
  }
});

// browser-external:crypto
var require_crypto2 = __commonJS({
  "browser-external:crypto"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "crypto" has been externalized for browser compatibility. Cannot access "crypto.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/tweetnacl/nacl-fast.js
var require_nacl_fast = __commonJS({
  "node_modules/tweetnacl/nacl-fast.js"(exports, module) {
    (function(nacl2) {
      "use strict";
      var gf = function(init) {
        var i2, r3 = new Float64Array(16);
        if (init) for (i2 = 0; i2 < init.length; i2++) r3[i2] = init[i2];
        return r3;
      };
      var randombytes = function() {
        throw new Error("no PRNG");
      };
      var _0 = new Uint8Array(16);
      var _9 = new Uint8Array(32);
      _9[0] = 9;
      var gf0 = gf(), gf1 = gf([1]), _121665 = gf([56129, 1]), D2 = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), D22 = gf([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), X2 = gf([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), Y2 = gf([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), I2 = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
      function ts64(x2, i2, h2, l2) {
        x2[i2] = h2 >> 24 & 255;
        x2[i2 + 1] = h2 >> 16 & 255;
        x2[i2 + 2] = h2 >> 8 & 255;
        x2[i2 + 3] = h2 & 255;
        x2[i2 + 4] = l2 >> 24 & 255;
        x2[i2 + 5] = l2 >> 16 & 255;
        x2[i2 + 6] = l2 >> 8 & 255;
        x2[i2 + 7] = l2 & 255;
      }
      function vn(x2, xi, y2, yi, n2) {
        var i2, d2 = 0;
        for (i2 = 0; i2 < n2; i2++) d2 |= x2[xi + i2] ^ y2[yi + i2];
        return (1 & d2 - 1 >>> 8) - 1;
      }
      function crypto_verify_16(x2, xi, y2, yi) {
        return vn(x2, xi, y2, yi, 16);
      }
      function crypto_verify_32(x2, xi, y2, yi) {
        return vn(x2, xi, y2, yi, 32);
      }
      function core_salsa20(o3, p2, k2, c2) {
        var j0 = c2[0] & 255 | (c2[1] & 255) << 8 | (c2[2] & 255) << 16 | (c2[3] & 255) << 24, j1 = k2[0] & 255 | (k2[1] & 255) << 8 | (k2[2] & 255) << 16 | (k2[3] & 255) << 24, j2 = k2[4] & 255 | (k2[5] & 255) << 8 | (k2[6] & 255) << 16 | (k2[7] & 255) << 24, j3 = k2[8] & 255 | (k2[9] & 255) << 8 | (k2[10] & 255) << 16 | (k2[11] & 255) << 24, j4 = k2[12] & 255 | (k2[13] & 255) << 8 | (k2[14] & 255) << 16 | (k2[15] & 255) << 24, j5 = c2[4] & 255 | (c2[5] & 255) << 8 | (c2[6] & 255) << 16 | (c2[7] & 255) << 24, j6 = p2[0] & 255 | (p2[1] & 255) << 8 | (p2[2] & 255) << 16 | (p2[3] & 255) << 24, j7 = p2[4] & 255 | (p2[5] & 255) << 8 | (p2[6] & 255) << 16 | (p2[7] & 255) << 24, j8 = p2[8] & 255 | (p2[9] & 255) << 8 | (p2[10] & 255) << 16 | (p2[11] & 255) << 24, j9 = p2[12] & 255 | (p2[13] & 255) << 8 | (p2[14] & 255) << 16 | (p2[15] & 255) << 24, j10 = c2[8] & 255 | (c2[9] & 255) << 8 | (c2[10] & 255) << 16 | (c2[11] & 255) << 24, j11 = k2[16] & 255 | (k2[17] & 255) << 8 | (k2[18] & 255) << 16 | (k2[19] & 255) << 24, j12 = k2[20] & 255 | (k2[21] & 255) << 8 | (k2[22] & 255) << 16 | (k2[23] & 255) << 24, j13 = k2[24] & 255 | (k2[25] & 255) << 8 | (k2[26] & 255) << 16 | (k2[27] & 255) << 24, j14 = k2[28] & 255 | (k2[29] & 255) << 8 | (k2[30] & 255) << 16 | (k2[31] & 255) << 24, j15 = c2[12] & 255 | (c2[13] & 255) << 8 | (c2[14] & 255) << 16 | (c2[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u2;
        for (var i2 = 0; i2 < 20; i2 += 2) {
          u2 = x0 + x12 | 0;
          x4 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x4 + x0 | 0;
          x8 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x8 + x4 | 0;
          x12 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x12 + x8 | 0;
          x0 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x5 + x1 | 0;
          x9 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x9 + x5 | 0;
          x13 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x13 + x9 | 0;
          x1 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x1 + x13 | 0;
          x5 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x10 + x6 | 0;
          x14 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x14 + x10 | 0;
          x2 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x2 + x14 | 0;
          x6 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x6 + x2 | 0;
          x10 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x15 + x11 | 0;
          x3 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x3 + x15 | 0;
          x7 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x7 + x3 | 0;
          x11 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x11 + x7 | 0;
          x15 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x0 + x3 | 0;
          x1 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x1 + x0 | 0;
          x2 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x2 + x1 | 0;
          x3 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x3 + x2 | 0;
          x0 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x5 + x4 | 0;
          x6 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x6 + x5 | 0;
          x7 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x7 + x6 | 0;
          x4 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x4 + x7 | 0;
          x5 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x10 + x9 | 0;
          x11 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x11 + x10 | 0;
          x8 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x8 + x11 | 0;
          x9 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x9 + x8 | 0;
          x10 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x15 + x14 | 0;
          x12 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x12 + x15 | 0;
          x13 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x13 + x12 | 0;
          x14 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x14 + x13 | 0;
          x15 ^= u2 << 18 | u2 >>> 32 - 18;
        }
        x0 = x0 + j0 | 0;
        x1 = x1 + j1 | 0;
        x2 = x2 + j2 | 0;
        x3 = x3 + j3 | 0;
        x4 = x4 + j4 | 0;
        x5 = x5 + j5 | 0;
        x6 = x6 + j6 | 0;
        x7 = x7 + j7 | 0;
        x8 = x8 + j8 | 0;
        x9 = x9 + j9 | 0;
        x10 = x10 + j10 | 0;
        x11 = x11 + j11 | 0;
        x12 = x12 + j12 | 0;
        x13 = x13 + j13 | 0;
        x14 = x14 + j14 | 0;
        x15 = x15 + j15 | 0;
        o3[0] = x0 >>> 0 & 255;
        o3[1] = x0 >>> 8 & 255;
        o3[2] = x0 >>> 16 & 255;
        o3[3] = x0 >>> 24 & 255;
        o3[4] = x1 >>> 0 & 255;
        o3[5] = x1 >>> 8 & 255;
        o3[6] = x1 >>> 16 & 255;
        o3[7] = x1 >>> 24 & 255;
        o3[8] = x2 >>> 0 & 255;
        o3[9] = x2 >>> 8 & 255;
        o3[10] = x2 >>> 16 & 255;
        o3[11] = x2 >>> 24 & 255;
        o3[12] = x3 >>> 0 & 255;
        o3[13] = x3 >>> 8 & 255;
        o3[14] = x3 >>> 16 & 255;
        o3[15] = x3 >>> 24 & 255;
        o3[16] = x4 >>> 0 & 255;
        o3[17] = x4 >>> 8 & 255;
        o3[18] = x4 >>> 16 & 255;
        o3[19] = x4 >>> 24 & 255;
        o3[20] = x5 >>> 0 & 255;
        o3[21] = x5 >>> 8 & 255;
        o3[22] = x5 >>> 16 & 255;
        o3[23] = x5 >>> 24 & 255;
        o3[24] = x6 >>> 0 & 255;
        o3[25] = x6 >>> 8 & 255;
        o3[26] = x6 >>> 16 & 255;
        o3[27] = x6 >>> 24 & 255;
        o3[28] = x7 >>> 0 & 255;
        o3[29] = x7 >>> 8 & 255;
        o3[30] = x7 >>> 16 & 255;
        o3[31] = x7 >>> 24 & 255;
        o3[32] = x8 >>> 0 & 255;
        o3[33] = x8 >>> 8 & 255;
        o3[34] = x8 >>> 16 & 255;
        o3[35] = x8 >>> 24 & 255;
        o3[36] = x9 >>> 0 & 255;
        o3[37] = x9 >>> 8 & 255;
        o3[38] = x9 >>> 16 & 255;
        o3[39] = x9 >>> 24 & 255;
        o3[40] = x10 >>> 0 & 255;
        o3[41] = x10 >>> 8 & 255;
        o3[42] = x10 >>> 16 & 255;
        o3[43] = x10 >>> 24 & 255;
        o3[44] = x11 >>> 0 & 255;
        o3[45] = x11 >>> 8 & 255;
        o3[46] = x11 >>> 16 & 255;
        o3[47] = x11 >>> 24 & 255;
        o3[48] = x12 >>> 0 & 255;
        o3[49] = x12 >>> 8 & 255;
        o3[50] = x12 >>> 16 & 255;
        o3[51] = x12 >>> 24 & 255;
        o3[52] = x13 >>> 0 & 255;
        o3[53] = x13 >>> 8 & 255;
        o3[54] = x13 >>> 16 & 255;
        o3[55] = x13 >>> 24 & 255;
        o3[56] = x14 >>> 0 & 255;
        o3[57] = x14 >>> 8 & 255;
        o3[58] = x14 >>> 16 & 255;
        o3[59] = x14 >>> 24 & 255;
        o3[60] = x15 >>> 0 & 255;
        o3[61] = x15 >>> 8 & 255;
        o3[62] = x15 >>> 16 & 255;
        o3[63] = x15 >>> 24 & 255;
      }
      function core_hsalsa20(o3, p2, k2, c2) {
        var j0 = c2[0] & 255 | (c2[1] & 255) << 8 | (c2[2] & 255) << 16 | (c2[3] & 255) << 24, j1 = k2[0] & 255 | (k2[1] & 255) << 8 | (k2[2] & 255) << 16 | (k2[3] & 255) << 24, j2 = k2[4] & 255 | (k2[5] & 255) << 8 | (k2[6] & 255) << 16 | (k2[7] & 255) << 24, j3 = k2[8] & 255 | (k2[9] & 255) << 8 | (k2[10] & 255) << 16 | (k2[11] & 255) << 24, j4 = k2[12] & 255 | (k2[13] & 255) << 8 | (k2[14] & 255) << 16 | (k2[15] & 255) << 24, j5 = c2[4] & 255 | (c2[5] & 255) << 8 | (c2[6] & 255) << 16 | (c2[7] & 255) << 24, j6 = p2[0] & 255 | (p2[1] & 255) << 8 | (p2[2] & 255) << 16 | (p2[3] & 255) << 24, j7 = p2[4] & 255 | (p2[5] & 255) << 8 | (p2[6] & 255) << 16 | (p2[7] & 255) << 24, j8 = p2[8] & 255 | (p2[9] & 255) << 8 | (p2[10] & 255) << 16 | (p2[11] & 255) << 24, j9 = p2[12] & 255 | (p2[13] & 255) << 8 | (p2[14] & 255) << 16 | (p2[15] & 255) << 24, j10 = c2[8] & 255 | (c2[9] & 255) << 8 | (c2[10] & 255) << 16 | (c2[11] & 255) << 24, j11 = k2[16] & 255 | (k2[17] & 255) << 8 | (k2[18] & 255) << 16 | (k2[19] & 255) << 24, j12 = k2[20] & 255 | (k2[21] & 255) << 8 | (k2[22] & 255) << 16 | (k2[23] & 255) << 24, j13 = k2[24] & 255 | (k2[25] & 255) << 8 | (k2[26] & 255) << 16 | (k2[27] & 255) << 24, j14 = k2[28] & 255 | (k2[29] & 255) << 8 | (k2[30] & 255) << 16 | (k2[31] & 255) << 24, j15 = c2[12] & 255 | (c2[13] & 255) << 8 | (c2[14] & 255) << 16 | (c2[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u2;
        for (var i2 = 0; i2 < 20; i2 += 2) {
          u2 = x0 + x12 | 0;
          x4 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x4 + x0 | 0;
          x8 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x8 + x4 | 0;
          x12 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x12 + x8 | 0;
          x0 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x5 + x1 | 0;
          x9 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x9 + x5 | 0;
          x13 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x13 + x9 | 0;
          x1 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x1 + x13 | 0;
          x5 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x10 + x6 | 0;
          x14 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x14 + x10 | 0;
          x2 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x2 + x14 | 0;
          x6 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x6 + x2 | 0;
          x10 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x15 + x11 | 0;
          x3 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x3 + x15 | 0;
          x7 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x7 + x3 | 0;
          x11 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x11 + x7 | 0;
          x15 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x0 + x3 | 0;
          x1 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x1 + x0 | 0;
          x2 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x2 + x1 | 0;
          x3 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x3 + x2 | 0;
          x0 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x5 + x4 | 0;
          x6 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x6 + x5 | 0;
          x7 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x7 + x6 | 0;
          x4 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x4 + x7 | 0;
          x5 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x10 + x9 | 0;
          x11 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x11 + x10 | 0;
          x8 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x8 + x11 | 0;
          x9 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x9 + x8 | 0;
          x10 ^= u2 << 18 | u2 >>> 32 - 18;
          u2 = x15 + x14 | 0;
          x12 ^= u2 << 7 | u2 >>> 32 - 7;
          u2 = x12 + x15 | 0;
          x13 ^= u2 << 9 | u2 >>> 32 - 9;
          u2 = x13 + x12 | 0;
          x14 ^= u2 << 13 | u2 >>> 32 - 13;
          u2 = x14 + x13 | 0;
          x15 ^= u2 << 18 | u2 >>> 32 - 18;
        }
        o3[0] = x0 >>> 0 & 255;
        o3[1] = x0 >>> 8 & 255;
        o3[2] = x0 >>> 16 & 255;
        o3[3] = x0 >>> 24 & 255;
        o3[4] = x5 >>> 0 & 255;
        o3[5] = x5 >>> 8 & 255;
        o3[6] = x5 >>> 16 & 255;
        o3[7] = x5 >>> 24 & 255;
        o3[8] = x10 >>> 0 & 255;
        o3[9] = x10 >>> 8 & 255;
        o3[10] = x10 >>> 16 & 255;
        o3[11] = x10 >>> 24 & 255;
        o3[12] = x15 >>> 0 & 255;
        o3[13] = x15 >>> 8 & 255;
        o3[14] = x15 >>> 16 & 255;
        o3[15] = x15 >>> 24 & 255;
        o3[16] = x6 >>> 0 & 255;
        o3[17] = x6 >>> 8 & 255;
        o3[18] = x6 >>> 16 & 255;
        o3[19] = x6 >>> 24 & 255;
        o3[20] = x7 >>> 0 & 255;
        o3[21] = x7 >>> 8 & 255;
        o3[22] = x7 >>> 16 & 255;
        o3[23] = x7 >>> 24 & 255;
        o3[24] = x8 >>> 0 & 255;
        o3[25] = x8 >>> 8 & 255;
        o3[26] = x8 >>> 16 & 255;
        o3[27] = x8 >>> 24 & 255;
        o3[28] = x9 >>> 0 & 255;
        o3[29] = x9 >>> 8 & 255;
        o3[30] = x9 >>> 16 & 255;
        o3[31] = x9 >>> 24 & 255;
      }
      function crypto_core_salsa20(out, inp, k2, c2) {
        core_salsa20(out, inp, k2, c2);
      }
      function crypto_core_hsalsa20(out, inp, k2, c2) {
        core_hsalsa20(out, inp, k2, c2);
      }
      var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
      function crypto_stream_salsa20_xor(c2, cpos, m2, mpos, b2, n2, k2) {
        var z2 = new Uint8Array(16), x2 = new Uint8Array(64);
        var u2, i2;
        for (i2 = 0; i2 < 16; i2++) z2[i2] = 0;
        for (i2 = 0; i2 < 8; i2++) z2[i2] = n2[i2];
        while (b2 >= 64) {
          crypto_core_salsa20(x2, z2, k2, sigma);
          for (i2 = 0; i2 < 64; i2++) c2[cpos + i2] = m2[mpos + i2] ^ x2[i2];
          u2 = 1;
          for (i2 = 8; i2 < 16; i2++) {
            u2 = u2 + (z2[i2] & 255) | 0;
            z2[i2] = u2 & 255;
            u2 >>>= 8;
          }
          b2 -= 64;
          cpos += 64;
          mpos += 64;
        }
        if (b2 > 0) {
          crypto_core_salsa20(x2, z2, k2, sigma);
          for (i2 = 0; i2 < b2; i2++) c2[cpos + i2] = m2[mpos + i2] ^ x2[i2];
        }
        return 0;
      }
      function crypto_stream_salsa20(c2, cpos, b2, n2, k2) {
        var z2 = new Uint8Array(16), x2 = new Uint8Array(64);
        var u2, i2;
        for (i2 = 0; i2 < 16; i2++) z2[i2] = 0;
        for (i2 = 0; i2 < 8; i2++) z2[i2] = n2[i2];
        while (b2 >= 64) {
          crypto_core_salsa20(x2, z2, k2, sigma);
          for (i2 = 0; i2 < 64; i2++) c2[cpos + i2] = x2[i2];
          u2 = 1;
          for (i2 = 8; i2 < 16; i2++) {
            u2 = u2 + (z2[i2] & 255) | 0;
            z2[i2] = u2 & 255;
            u2 >>>= 8;
          }
          b2 -= 64;
          cpos += 64;
        }
        if (b2 > 0) {
          crypto_core_salsa20(x2, z2, k2, sigma);
          for (i2 = 0; i2 < b2; i2++) c2[cpos + i2] = x2[i2];
        }
        return 0;
      }
      function crypto_stream(c2, cpos, d2, n2, k2) {
        var s2 = new Uint8Array(32);
        crypto_core_hsalsa20(s2, n2, k2, sigma);
        var sn = new Uint8Array(8);
        for (var i2 = 0; i2 < 8; i2++) sn[i2] = n2[i2 + 16];
        return crypto_stream_salsa20(c2, cpos, d2, sn, s2);
      }
      function crypto_stream_xor(c2, cpos, m2, mpos, d2, n2, k2) {
        var s2 = new Uint8Array(32);
        crypto_core_hsalsa20(s2, n2, k2, sigma);
        var sn = new Uint8Array(8);
        for (var i2 = 0; i2 < 8; i2++) sn[i2] = n2[i2 + 16];
        return crypto_stream_salsa20_xor(c2, cpos, m2, mpos, d2, sn, s2);
      }
      var poly1305 = function(key) {
        this.buffer = new Uint8Array(16);
        this.r = new Uint16Array(10);
        this.h = new Uint16Array(10);
        this.pad = new Uint16Array(8);
        this.leftover = 0;
        this.fin = 0;
        var t0, t1, t2, t3, t4, t5, t6, t7;
        t0 = key[0] & 255 | (key[1] & 255) << 8;
        this.r[0] = t0 & 8191;
        t1 = key[2] & 255 | (key[3] & 255) << 8;
        this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
        t2 = key[4] & 255 | (key[5] & 255) << 8;
        this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
        t3 = key[6] & 255 | (key[7] & 255) << 8;
        this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
        t4 = key[8] & 255 | (key[9] & 255) << 8;
        this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
        this.r[5] = t4 >>> 1 & 8190;
        t5 = key[10] & 255 | (key[11] & 255) << 8;
        this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
        t6 = key[12] & 255 | (key[13] & 255) << 8;
        this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
        t7 = key[14] & 255 | (key[15] & 255) << 8;
        this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
        this.r[9] = t7 >>> 5 & 127;
        this.pad[0] = key[16] & 255 | (key[17] & 255) << 8;
        this.pad[1] = key[18] & 255 | (key[19] & 255) << 8;
        this.pad[2] = key[20] & 255 | (key[21] & 255) << 8;
        this.pad[3] = key[22] & 255 | (key[23] & 255) << 8;
        this.pad[4] = key[24] & 255 | (key[25] & 255) << 8;
        this.pad[5] = key[26] & 255 | (key[27] & 255) << 8;
        this.pad[6] = key[28] & 255 | (key[29] & 255) << 8;
        this.pad[7] = key[30] & 255 | (key[31] & 255) << 8;
      };
      poly1305.prototype.blocks = function(m2, mpos, bytes) {
        var hibit = this.fin ? 0 : 1 << 11;
        var t0, t1, t2, t3, t4, t5, t6, t7, c2;
        var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
        var h0 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
        var r0 = this.r[0], r1 = this.r[1], r22 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];
        while (bytes >= 16) {
          t0 = m2[mpos + 0] & 255 | (m2[mpos + 1] & 255) << 8;
          h0 += t0 & 8191;
          t1 = m2[mpos + 2] & 255 | (m2[mpos + 3] & 255) << 8;
          h1 += (t0 >>> 13 | t1 << 3) & 8191;
          t2 = m2[mpos + 4] & 255 | (m2[mpos + 5] & 255) << 8;
          h2 += (t1 >>> 10 | t2 << 6) & 8191;
          t3 = m2[mpos + 6] & 255 | (m2[mpos + 7] & 255) << 8;
          h3 += (t2 >>> 7 | t3 << 9) & 8191;
          t4 = m2[mpos + 8] & 255 | (m2[mpos + 9] & 255) << 8;
          h4 += (t3 >>> 4 | t4 << 12) & 8191;
          h5 += t4 >>> 1 & 8191;
          t5 = m2[mpos + 10] & 255 | (m2[mpos + 11] & 255) << 8;
          h6 += (t4 >>> 14 | t5 << 2) & 8191;
          t6 = m2[mpos + 12] & 255 | (m2[mpos + 13] & 255) << 8;
          h7 += (t5 >>> 11 | t6 << 5) & 8191;
          t7 = m2[mpos + 14] & 255 | (m2[mpos + 15] & 255) << 8;
          h8 += (t6 >>> 8 | t7 << 8) & 8191;
          h9 += t7 >>> 5 | hibit;
          c2 = 0;
          d0 = c2;
          d0 += h0 * r0;
          d0 += h1 * (5 * r9);
          d0 += h2 * (5 * r8);
          d0 += h3 * (5 * r7);
          d0 += h4 * (5 * r6);
          c2 = d0 >>> 13;
          d0 &= 8191;
          d0 += h5 * (5 * r5);
          d0 += h6 * (5 * r4);
          d0 += h7 * (5 * r3);
          d0 += h8 * (5 * r22);
          d0 += h9 * (5 * r1);
          c2 += d0 >>> 13;
          d0 &= 8191;
          d1 = c2;
          d1 += h0 * r1;
          d1 += h1 * r0;
          d1 += h2 * (5 * r9);
          d1 += h3 * (5 * r8);
          d1 += h4 * (5 * r7);
          c2 = d1 >>> 13;
          d1 &= 8191;
          d1 += h5 * (5 * r6);
          d1 += h6 * (5 * r5);
          d1 += h7 * (5 * r4);
          d1 += h8 * (5 * r3);
          d1 += h9 * (5 * r22);
          c2 += d1 >>> 13;
          d1 &= 8191;
          d2 = c2;
          d2 += h0 * r22;
          d2 += h1 * r1;
          d2 += h2 * r0;
          d2 += h3 * (5 * r9);
          d2 += h4 * (5 * r8);
          c2 = d2 >>> 13;
          d2 &= 8191;
          d2 += h5 * (5 * r7);
          d2 += h6 * (5 * r6);
          d2 += h7 * (5 * r5);
          d2 += h8 * (5 * r4);
          d2 += h9 * (5 * r3);
          c2 += d2 >>> 13;
          d2 &= 8191;
          d3 = c2;
          d3 += h0 * r3;
          d3 += h1 * r22;
          d3 += h2 * r1;
          d3 += h3 * r0;
          d3 += h4 * (5 * r9);
          c2 = d3 >>> 13;
          d3 &= 8191;
          d3 += h5 * (5 * r8);
          d3 += h6 * (5 * r7);
          d3 += h7 * (5 * r6);
          d3 += h8 * (5 * r5);
          d3 += h9 * (5 * r4);
          c2 += d3 >>> 13;
          d3 &= 8191;
          d4 = c2;
          d4 += h0 * r4;
          d4 += h1 * r3;
          d4 += h2 * r22;
          d4 += h3 * r1;
          d4 += h4 * r0;
          c2 = d4 >>> 13;
          d4 &= 8191;
          d4 += h5 * (5 * r9);
          d4 += h6 * (5 * r8);
          d4 += h7 * (5 * r7);
          d4 += h8 * (5 * r6);
          d4 += h9 * (5 * r5);
          c2 += d4 >>> 13;
          d4 &= 8191;
          d5 = c2;
          d5 += h0 * r5;
          d5 += h1 * r4;
          d5 += h2 * r3;
          d5 += h3 * r22;
          d5 += h4 * r1;
          c2 = d5 >>> 13;
          d5 &= 8191;
          d5 += h5 * r0;
          d5 += h6 * (5 * r9);
          d5 += h7 * (5 * r8);
          d5 += h8 * (5 * r7);
          d5 += h9 * (5 * r6);
          c2 += d5 >>> 13;
          d5 &= 8191;
          d6 = c2;
          d6 += h0 * r6;
          d6 += h1 * r5;
          d6 += h2 * r4;
          d6 += h3 * r3;
          d6 += h4 * r22;
          c2 = d6 >>> 13;
          d6 &= 8191;
          d6 += h5 * r1;
          d6 += h6 * r0;
          d6 += h7 * (5 * r9);
          d6 += h8 * (5 * r8);
          d6 += h9 * (5 * r7);
          c2 += d6 >>> 13;
          d6 &= 8191;
          d7 = c2;
          d7 += h0 * r7;
          d7 += h1 * r6;
          d7 += h2 * r5;
          d7 += h3 * r4;
          d7 += h4 * r3;
          c2 = d7 >>> 13;
          d7 &= 8191;
          d7 += h5 * r22;
          d7 += h6 * r1;
          d7 += h7 * r0;
          d7 += h8 * (5 * r9);
          d7 += h9 * (5 * r8);
          c2 += d7 >>> 13;
          d7 &= 8191;
          d8 = c2;
          d8 += h0 * r8;
          d8 += h1 * r7;
          d8 += h2 * r6;
          d8 += h3 * r5;
          d8 += h4 * r4;
          c2 = d8 >>> 13;
          d8 &= 8191;
          d8 += h5 * r3;
          d8 += h6 * r22;
          d8 += h7 * r1;
          d8 += h8 * r0;
          d8 += h9 * (5 * r9);
          c2 += d8 >>> 13;
          d8 &= 8191;
          d9 = c2;
          d9 += h0 * r9;
          d9 += h1 * r8;
          d9 += h2 * r7;
          d9 += h3 * r6;
          d9 += h4 * r5;
          c2 = d9 >>> 13;
          d9 &= 8191;
          d9 += h5 * r4;
          d9 += h6 * r3;
          d9 += h7 * r22;
          d9 += h8 * r1;
          d9 += h9 * r0;
          c2 += d9 >>> 13;
          d9 &= 8191;
          c2 = (c2 << 2) + c2 | 0;
          c2 = c2 + d0 | 0;
          d0 = c2 & 8191;
          c2 = c2 >>> 13;
          d1 += c2;
          h0 = d0;
          h1 = d1;
          h2 = d2;
          h3 = d3;
          h4 = d4;
          h5 = d5;
          h6 = d6;
          h7 = d7;
          h8 = d8;
          h9 = d9;
          mpos += 16;
          bytes -= 16;
        }
        this.h[0] = h0;
        this.h[1] = h1;
        this.h[2] = h2;
        this.h[3] = h3;
        this.h[4] = h4;
        this.h[5] = h5;
        this.h[6] = h6;
        this.h[7] = h7;
        this.h[8] = h8;
        this.h[9] = h9;
      };
      poly1305.prototype.finish = function(mac, macpos) {
        var g2 = new Uint16Array(10);
        var c2, mask, f2, i2;
        if (this.leftover) {
          i2 = this.leftover;
          this.buffer[i2++] = 1;
          for (; i2 < 16; i2++) this.buffer[i2] = 0;
          this.fin = 1;
          this.blocks(this.buffer, 0, 16);
        }
        c2 = this.h[1] >>> 13;
        this.h[1] &= 8191;
        for (i2 = 2; i2 < 10; i2++) {
          this.h[i2] += c2;
          c2 = this.h[i2] >>> 13;
          this.h[i2] &= 8191;
        }
        this.h[0] += c2 * 5;
        c2 = this.h[0] >>> 13;
        this.h[0] &= 8191;
        this.h[1] += c2;
        c2 = this.h[1] >>> 13;
        this.h[1] &= 8191;
        this.h[2] += c2;
        g2[0] = this.h[0] + 5;
        c2 = g2[0] >>> 13;
        g2[0] &= 8191;
        for (i2 = 1; i2 < 10; i2++) {
          g2[i2] = this.h[i2] + c2;
          c2 = g2[i2] >>> 13;
          g2[i2] &= 8191;
        }
        g2[9] -= 1 << 13;
        mask = (c2 ^ 1) - 1;
        for (i2 = 0; i2 < 10; i2++) g2[i2] &= mask;
        mask = ~mask;
        for (i2 = 0; i2 < 10; i2++) this.h[i2] = this.h[i2] & mask | g2[i2];
        this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
        this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
        this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
        this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
        this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
        this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
        this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
        this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
        f2 = this.h[0] + this.pad[0];
        this.h[0] = f2 & 65535;
        for (i2 = 1; i2 < 8; i2++) {
          f2 = (this.h[i2] + this.pad[i2] | 0) + (f2 >>> 16) | 0;
          this.h[i2] = f2 & 65535;
        }
        mac[macpos + 0] = this.h[0] >>> 0 & 255;
        mac[macpos + 1] = this.h[0] >>> 8 & 255;
        mac[macpos + 2] = this.h[1] >>> 0 & 255;
        mac[macpos + 3] = this.h[1] >>> 8 & 255;
        mac[macpos + 4] = this.h[2] >>> 0 & 255;
        mac[macpos + 5] = this.h[2] >>> 8 & 255;
        mac[macpos + 6] = this.h[3] >>> 0 & 255;
        mac[macpos + 7] = this.h[3] >>> 8 & 255;
        mac[macpos + 8] = this.h[4] >>> 0 & 255;
        mac[macpos + 9] = this.h[4] >>> 8 & 255;
        mac[macpos + 10] = this.h[5] >>> 0 & 255;
        mac[macpos + 11] = this.h[5] >>> 8 & 255;
        mac[macpos + 12] = this.h[6] >>> 0 & 255;
        mac[macpos + 13] = this.h[6] >>> 8 & 255;
        mac[macpos + 14] = this.h[7] >>> 0 & 255;
        mac[macpos + 15] = this.h[7] >>> 8 & 255;
      };
      poly1305.prototype.update = function(m2, mpos, bytes) {
        var i2, want;
        if (this.leftover) {
          want = 16 - this.leftover;
          if (want > bytes)
            want = bytes;
          for (i2 = 0; i2 < want; i2++)
            this.buffer[this.leftover + i2] = m2[mpos + i2];
          bytes -= want;
          mpos += want;
          this.leftover += want;
          if (this.leftover < 16)
            return;
          this.blocks(this.buffer, 0, 16);
          this.leftover = 0;
        }
        if (bytes >= 16) {
          want = bytes - bytes % 16;
          this.blocks(m2, mpos, want);
          mpos += want;
          bytes -= want;
        }
        if (bytes) {
          for (i2 = 0; i2 < bytes; i2++)
            this.buffer[this.leftover + i2] = m2[mpos + i2];
          this.leftover += bytes;
        }
      };
      function crypto_onetimeauth(out, outpos, m2, mpos, n2, k2) {
        var s2 = new poly1305(k2);
        s2.update(m2, mpos, n2);
        s2.finish(out, outpos);
        return 0;
      }
      function crypto_onetimeauth_verify(h2, hpos, m2, mpos, n2, k2) {
        var x2 = new Uint8Array(16);
        crypto_onetimeauth(x2, 0, m2, mpos, n2, k2);
        return crypto_verify_16(h2, hpos, x2, 0);
      }
      function crypto_secretbox(c2, m2, d2, n2, k2) {
        var i2;
        if (d2 < 32) return -1;
        crypto_stream_xor(c2, 0, m2, 0, d2, n2, k2);
        crypto_onetimeauth(c2, 16, c2, 32, d2 - 32, c2);
        for (i2 = 0; i2 < 16; i2++) c2[i2] = 0;
        return 0;
      }
      function crypto_secretbox_open(m2, c2, d2, n2, k2) {
        var i2;
        var x2 = new Uint8Array(32);
        if (d2 < 32) return -1;
        crypto_stream(x2, 0, 32, n2, k2);
        if (crypto_onetimeauth_verify(c2, 16, c2, 32, d2 - 32, x2) !== 0) return -1;
        crypto_stream_xor(m2, 0, c2, 0, d2, n2, k2);
        for (i2 = 0; i2 < 32; i2++) m2[i2] = 0;
        return 0;
      }
      function set25519(r3, a2) {
        var i2;
        for (i2 = 0; i2 < 16; i2++) r3[i2] = a2[i2] | 0;
      }
      function car25519(o3) {
        var i2, v2, c2 = 1;
        for (i2 = 0; i2 < 16; i2++) {
          v2 = o3[i2] + c2 + 65535;
          c2 = Math.floor(v2 / 65536);
          o3[i2] = v2 - c2 * 65536;
        }
        o3[0] += c2 - 1 + 37 * (c2 - 1);
      }
      function sel25519(p2, q2, b2) {
        var t, c2 = ~(b2 - 1);
        for (var i2 = 0; i2 < 16; i2++) {
          t = c2 & (p2[i2] ^ q2[i2]);
          p2[i2] ^= t;
          q2[i2] ^= t;
        }
      }
      function pack25519(o3, n2) {
        var i2, j2, b2;
        var m2 = gf(), t = gf();
        for (i2 = 0; i2 < 16; i2++) t[i2] = n2[i2];
        car25519(t);
        car25519(t);
        car25519(t);
        for (j2 = 0; j2 < 2; j2++) {
          m2[0] = t[0] - 65517;
          for (i2 = 1; i2 < 15; i2++) {
            m2[i2] = t[i2] - 65535 - (m2[i2 - 1] >> 16 & 1);
            m2[i2 - 1] &= 65535;
          }
          m2[15] = t[15] - 32767 - (m2[14] >> 16 & 1);
          b2 = m2[15] >> 16 & 1;
          m2[14] &= 65535;
          sel25519(t, m2, 1 - b2);
        }
        for (i2 = 0; i2 < 16; i2++) {
          o3[2 * i2] = t[i2] & 255;
          o3[2 * i2 + 1] = t[i2] >> 8;
        }
      }
      function neq25519(a2, b2) {
        var c2 = new Uint8Array(32), d2 = new Uint8Array(32);
        pack25519(c2, a2);
        pack25519(d2, b2);
        return crypto_verify_32(c2, 0, d2, 0);
      }
      function par25519(a2) {
        var d2 = new Uint8Array(32);
        pack25519(d2, a2);
        return d2[0] & 1;
      }
      function unpack25519(o3, n2) {
        var i2;
        for (i2 = 0; i2 < 16; i2++) o3[i2] = n2[2 * i2] + (n2[2 * i2 + 1] << 8);
        o3[15] &= 32767;
      }
      function A2(o3, a2, b2) {
        for (var i2 = 0; i2 < 16; i2++) o3[i2] = a2[i2] + b2[i2];
      }
      function Z2(o3, a2, b2) {
        for (var i2 = 0; i2 < 16; i2++) o3[i2] = a2[i2] - b2[i2];
      }
      function M2(o3, a2, b2) {
        var v2, c2, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b2[0], b1 = b2[1], b22 = b2[2], b3 = b2[3], b4 = b2[4], b5 = b2[5], b6 = b2[6], b7 = b2[7], b8 = b2[8], b9 = b2[9], b10 = b2[10], b11 = b2[11], b12 = b2[12], b13 = b2[13], b14 = b2[14], b15 = b2[15];
        v2 = a2[0];
        t0 += v2 * b0;
        t1 += v2 * b1;
        t2 += v2 * b22;
        t3 += v2 * b3;
        t4 += v2 * b4;
        t5 += v2 * b5;
        t6 += v2 * b6;
        t7 += v2 * b7;
        t8 += v2 * b8;
        t9 += v2 * b9;
        t10 += v2 * b10;
        t11 += v2 * b11;
        t12 += v2 * b12;
        t13 += v2 * b13;
        t14 += v2 * b14;
        t15 += v2 * b15;
        v2 = a2[1];
        t1 += v2 * b0;
        t2 += v2 * b1;
        t3 += v2 * b22;
        t4 += v2 * b3;
        t5 += v2 * b4;
        t6 += v2 * b5;
        t7 += v2 * b6;
        t8 += v2 * b7;
        t9 += v2 * b8;
        t10 += v2 * b9;
        t11 += v2 * b10;
        t12 += v2 * b11;
        t13 += v2 * b12;
        t14 += v2 * b13;
        t15 += v2 * b14;
        t16 += v2 * b15;
        v2 = a2[2];
        t2 += v2 * b0;
        t3 += v2 * b1;
        t4 += v2 * b22;
        t5 += v2 * b3;
        t6 += v2 * b4;
        t7 += v2 * b5;
        t8 += v2 * b6;
        t9 += v2 * b7;
        t10 += v2 * b8;
        t11 += v2 * b9;
        t12 += v2 * b10;
        t13 += v2 * b11;
        t14 += v2 * b12;
        t15 += v2 * b13;
        t16 += v2 * b14;
        t17 += v2 * b15;
        v2 = a2[3];
        t3 += v2 * b0;
        t4 += v2 * b1;
        t5 += v2 * b22;
        t6 += v2 * b3;
        t7 += v2 * b4;
        t8 += v2 * b5;
        t9 += v2 * b6;
        t10 += v2 * b7;
        t11 += v2 * b8;
        t12 += v2 * b9;
        t13 += v2 * b10;
        t14 += v2 * b11;
        t15 += v2 * b12;
        t16 += v2 * b13;
        t17 += v2 * b14;
        t18 += v2 * b15;
        v2 = a2[4];
        t4 += v2 * b0;
        t5 += v2 * b1;
        t6 += v2 * b22;
        t7 += v2 * b3;
        t8 += v2 * b4;
        t9 += v2 * b5;
        t10 += v2 * b6;
        t11 += v2 * b7;
        t12 += v2 * b8;
        t13 += v2 * b9;
        t14 += v2 * b10;
        t15 += v2 * b11;
        t16 += v2 * b12;
        t17 += v2 * b13;
        t18 += v2 * b14;
        t19 += v2 * b15;
        v2 = a2[5];
        t5 += v2 * b0;
        t6 += v2 * b1;
        t7 += v2 * b22;
        t8 += v2 * b3;
        t9 += v2 * b4;
        t10 += v2 * b5;
        t11 += v2 * b6;
        t12 += v2 * b7;
        t13 += v2 * b8;
        t14 += v2 * b9;
        t15 += v2 * b10;
        t16 += v2 * b11;
        t17 += v2 * b12;
        t18 += v2 * b13;
        t19 += v2 * b14;
        t20 += v2 * b15;
        v2 = a2[6];
        t6 += v2 * b0;
        t7 += v2 * b1;
        t8 += v2 * b22;
        t9 += v2 * b3;
        t10 += v2 * b4;
        t11 += v2 * b5;
        t12 += v2 * b6;
        t13 += v2 * b7;
        t14 += v2 * b8;
        t15 += v2 * b9;
        t16 += v2 * b10;
        t17 += v2 * b11;
        t18 += v2 * b12;
        t19 += v2 * b13;
        t20 += v2 * b14;
        t21 += v2 * b15;
        v2 = a2[7];
        t7 += v2 * b0;
        t8 += v2 * b1;
        t9 += v2 * b22;
        t10 += v2 * b3;
        t11 += v2 * b4;
        t12 += v2 * b5;
        t13 += v2 * b6;
        t14 += v2 * b7;
        t15 += v2 * b8;
        t16 += v2 * b9;
        t17 += v2 * b10;
        t18 += v2 * b11;
        t19 += v2 * b12;
        t20 += v2 * b13;
        t21 += v2 * b14;
        t22 += v2 * b15;
        v2 = a2[8];
        t8 += v2 * b0;
        t9 += v2 * b1;
        t10 += v2 * b22;
        t11 += v2 * b3;
        t12 += v2 * b4;
        t13 += v2 * b5;
        t14 += v2 * b6;
        t15 += v2 * b7;
        t16 += v2 * b8;
        t17 += v2 * b9;
        t18 += v2 * b10;
        t19 += v2 * b11;
        t20 += v2 * b12;
        t21 += v2 * b13;
        t22 += v2 * b14;
        t23 += v2 * b15;
        v2 = a2[9];
        t9 += v2 * b0;
        t10 += v2 * b1;
        t11 += v2 * b22;
        t12 += v2 * b3;
        t13 += v2 * b4;
        t14 += v2 * b5;
        t15 += v2 * b6;
        t16 += v2 * b7;
        t17 += v2 * b8;
        t18 += v2 * b9;
        t19 += v2 * b10;
        t20 += v2 * b11;
        t21 += v2 * b12;
        t22 += v2 * b13;
        t23 += v2 * b14;
        t24 += v2 * b15;
        v2 = a2[10];
        t10 += v2 * b0;
        t11 += v2 * b1;
        t12 += v2 * b22;
        t13 += v2 * b3;
        t14 += v2 * b4;
        t15 += v2 * b5;
        t16 += v2 * b6;
        t17 += v2 * b7;
        t18 += v2 * b8;
        t19 += v2 * b9;
        t20 += v2 * b10;
        t21 += v2 * b11;
        t22 += v2 * b12;
        t23 += v2 * b13;
        t24 += v2 * b14;
        t25 += v2 * b15;
        v2 = a2[11];
        t11 += v2 * b0;
        t12 += v2 * b1;
        t13 += v2 * b22;
        t14 += v2 * b3;
        t15 += v2 * b4;
        t16 += v2 * b5;
        t17 += v2 * b6;
        t18 += v2 * b7;
        t19 += v2 * b8;
        t20 += v2 * b9;
        t21 += v2 * b10;
        t22 += v2 * b11;
        t23 += v2 * b12;
        t24 += v2 * b13;
        t25 += v2 * b14;
        t26 += v2 * b15;
        v2 = a2[12];
        t12 += v2 * b0;
        t13 += v2 * b1;
        t14 += v2 * b22;
        t15 += v2 * b3;
        t16 += v2 * b4;
        t17 += v2 * b5;
        t18 += v2 * b6;
        t19 += v2 * b7;
        t20 += v2 * b8;
        t21 += v2 * b9;
        t22 += v2 * b10;
        t23 += v2 * b11;
        t24 += v2 * b12;
        t25 += v2 * b13;
        t26 += v2 * b14;
        t27 += v2 * b15;
        v2 = a2[13];
        t13 += v2 * b0;
        t14 += v2 * b1;
        t15 += v2 * b22;
        t16 += v2 * b3;
        t17 += v2 * b4;
        t18 += v2 * b5;
        t19 += v2 * b6;
        t20 += v2 * b7;
        t21 += v2 * b8;
        t22 += v2 * b9;
        t23 += v2 * b10;
        t24 += v2 * b11;
        t25 += v2 * b12;
        t26 += v2 * b13;
        t27 += v2 * b14;
        t28 += v2 * b15;
        v2 = a2[14];
        t14 += v2 * b0;
        t15 += v2 * b1;
        t16 += v2 * b22;
        t17 += v2 * b3;
        t18 += v2 * b4;
        t19 += v2 * b5;
        t20 += v2 * b6;
        t21 += v2 * b7;
        t22 += v2 * b8;
        t23 += v2 * b9;
        t24 += v2 * b10;
        t25 += v2 * b11;
        t26 += v2 * b12;
        t27 += v2 * b13;
        t28 += v2 * b14;
        t29 += v2 * b15;
        v2 = a2[15];
        t15 += v2 * b0;
        t16 += v2 * b1;
        t17 += v2 * b22;
        t18 += v2 * b3;
        t19 += v2 * b4;
        t20 += v2 * b5;
        t21 += v2 * b6;
        t22 += v2 * b7;
        t23 += v2 * b8;
        t24 += v2 * b9;
        t25 += v2 * b10;
        t26 += v2 * b11;
        t27 += v2 * b12;
        t28 += v2 * b13;
        t29 += v2 * b14;
        t30 += v2 * b15;
        t0 += 38 * t16;
        t1 += 38 * t17;
        t2 += 38 * t18;
        t3 += 38 * t19;
        t4 += 38 * t20;
        t5 += 38 * t21;
        t6 += 38 * t22;
        t7 += 38 * t23;
        t8 += 38 * t24;
        t9 += 38 * t25;
        t10 += 38 * t26;
        t11 += 38 * t27;
        t12 += 38 * t28;
        t13 += 38 * t29;
        t14 += 38 * t30;
        c2 = 1;
        v2 = t0 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t0 = v2 - c2 * 65536;
        v2 = t1 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t1 = v2 - c2 * 65536;
        v2 = t2 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t2 = v2 - c2 * 65536;
        v2 = t3 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t3 = v2 - c2 * 65536;
        v2 = t4 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t4 = v2 - c2 * 65536;
        v2 = t5 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t5 = v2 - c2 * 65536;
        v2 = t6 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t6 = v2 - c2 * 65536;
        v2 = t7 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t7 = v2 - c2 * 65536;
        v2 = t8 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t8 = v2 - c2 * 65536;
        v2 = t9 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t9 = v2 - c2 * 65536;
        v2 = t10 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t10 = v2 - c2 * 65536;
        v2 = t11 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t11 = v2 - c2 * 65536;
        v2 = t12 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t12 = v2 - c2 * 65536;
        v2 = t13 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t13 = v2 - c2 * 65536;
        v2 = t14 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t14 = v2 - c2 * 65536;
        v2 = t15 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t15 = v2 - c2 * 65536;
        t0 += c2 - 1 + 37 * (c2 - 1);
        c2 = 1;
        v2 = t0 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t0 = v2 - c2 * 65536;
        v2 = t1 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t1 = v2 - c2 * 65536;
        v2 = t2 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t2 = v2 - c2 * 65536;
        v2 = t3 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t3 = v2 - c2 * 65536;
        v2 = t4 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t4 = v2 - c2 * 65536;
        v2 = t5 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t5 = v2 - c2 * 65536;
        v2 = t6 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t6 = v2 - c2 * 65536;
        v2 = t7 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t7 = v2 - c2 * 65536;
        v2 = t8 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t8 = v2 - c2 * 65536;
        v2 = t9 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t9 = v2 - c2 * 65536;
        v2 = t10 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t10 = v2 - c2 * 65536;
        v2 = t11 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t11 = v2 - c2 * 65536;
        v2 = t12 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t12 = v2 - c2 * 65536;
        v2 = t13 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t13 = v2 - c2 * 65536;
        v2 = t14 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t14 = v2 - c2 * 65536;
        v2 = t15 + c2 + 65535;
        c2 = Math.floor(v2 / 65536);
        t15 = v2 - c2 * 65536;
        t0 += c2 - 1 + 37 * (c2 - 1);
        o3[0] = t0;
        o3[1] = t1;
        o3[2] = t2;
        o3[3] = t3;
        o3[4] = t4;
        o3[5] = t5;
        o3[6] = t6;
        o3[7] = t7;
        o3[8] = t8;
        o3[9] = t9;
        o3[10] = t10;
        o3[11] = t11;
        o3[12] = t12;
        o3[13] = t13;
        o3[14] = t14;
        o3[15] = t15;
      }
      function S2(o3, a2) {
        M2(o3, a2, a2);
      }
      function inv25519(o3, i2) {
        var c2 = gf();
        var a2;
        for (a2 = 0; a2 < 16; a2++) c2[a2] = i2[a2];
        for (a2 = 253; a2 >= 0; a2--) {
          S2(c2, c2);
          if (a2 !== 2 && a2 !== 4) M2(c2, c2, i2);
        }
        for (a2 = 0; a2 < 16; a2++) o3[a2] = c2[a2];
      }
      function pow2523(o3, i2) {
        var c2 = gf();
        var a2;
        for (a2 = 0; a2 < 16; a2++) c2[a2] = i2[a2];
        for (a2 = 250; a2 >= 0; a2--) {
          S2(c2, c2);
          if (a2 !== 1) M2(c2, c2, i2);
        }
        for (a2 = 0; a2 < 16; a2++) o3[a2] = c2[a2];
      }
      function crypto_scalarmult(q2, n2, p2) {
        var z2 = new Uint8Array(32);
        var x2 = new Float64Array(80), r3, i2;
        var a2 = gf(), b2 = gf(), c2 = gf(), d2 = gf(), e2 = gf(), f2 = gf();
        for (i2 = 0; i2 < 31; i2++) z2[i2] = n2[i2];
        z2[31] = n2[31] & 127 | 64;
        z2[0] &= 248;
        unpack25519(x2, p2);
        for (i2 = 0; i2 < 16; i2++) {
          b2[i2] = x2[i2];
          d2[i2] = a2[i2] = c2[i2] = 0;
        }
        a2[0] = d2[0] = 1;
        for (i2 = 254; i2 >= 0; --i2) {
          r3 = z2[i2 >>> 3] >>> (i2 & 7) & 1;
          sel25519(a2, b2, r3);
          sel25519(c2, d2, r3);
          A2(e2, a2, c2);
          Z2(a2, a2, c2);
          A2(c2, b2, d2);
          Z2(b2, b2, d2);
          S2(d2, e2);
          S2(f2, a2);
          M2(a2, c2, a2);
          M2(c2, b2, e2);
          A2(e2, a2, c2);
          Z2(a2, a2, c2);
          S2(b2, a2);
          Z2(c2, d2, f2);
          M2(a2, c2, _121665);
          A2(a2, a2, d2);
          M2(c2, c2, a2);
          M2(a2, d2, f2);
          M2(d2, b2, x2);
          S2(b2, e2);
          sel25519(a2, b2, r3);
          sel25519(c2, d2, r3);
        }
        for (i2 = 0; i2 < 16; i2++) {
          x2[i2 + 16] = a2[i2];
          x2[i2 + 32] = c2[i2];
          x2[i2 + 48] = b2[i2];
          x2[i2 + 64] = d2[i2];
        }
        var x32 = x2.subarray(32);
        var x16 = x2.subarray(16);
        inv25519(x32, x32);
        M2(x16, x16, x32);
        pack25519(q2, x16);
        return 0;
      }
      function crypto_scalarmult_base(q2, n2) {
        return crypto_scalarmult(q2, n2, _9);
      }
      function crypto_box_keypair(y2, x2) {
        randombytes(x2, 32);
        return crypto_scalarmult_base(y2, x2);
      }
      function crypto_box_beforenm(k2, y2, x2) {
        var s2 = new Uint8Array(32);
        crypto_scalarmult(s2, x2, y2);
        return crypto_core_hsalsa20(k2, _0, s2, sigma);
      }
      var crypto_box_afternm = crypto_secretbox;
      var crypto_box_open_afternm = crypto_secretbox_open;
      function crypto_box(c2, m2, d2, n2, y2, x2) {
        var k2 = new Uint8Array(32);
        crypto_box_beforenm(k2, y2, x2);
        return crypto_box_afternm(c2, m2, d2, n2, k2);
      }
      function crypto_box_open(m2, c2, d2, n2, y2, x2) {
        var k2 = new Uint8Array(32);
        crypto_box_beforenm(k2, y2, x2);
        return crypto_box_open_afternm(m2, c2, d2, n2, k2);
      }
      var K2 = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ];
      function crypto_hashblocks_hl(hh, hl, m2, n2) {
        var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i2, j2, h2, l2, a2, b2, c2, d2;
        var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
        var pos = 0;
        while (n2 >= 128) {
          for (i2 = 0; i2 < 16; i2++) {
            j2 = 8 * i2 + pos;
            wh[i2] = m2[j2 + 0] << 24 | m2[j2 + 1] << 16 | m2[j2 + 2] << 8 | m2[j2 + 3];
            wl[i2] = m2[j2 + 4] << 24 | m2[j2 + 5] << 16 | m2[j2 + 6] << 8 | m2[j2 + 7];
          }
          for (i2 = 0; i2 < 80; i2++) {
            bh0 = ah0;
            bh1 = ah1;
            bh2 = ah2;
            bh3 = ah3;
            bh4 = ah4;
            bh5 = ah5;
            bh6 = ah6;
            bh7 = ah7;
            bl0 = al0;
            bl1 = al1;
            bl2 = al2;
            bl3 = al3;
            bl4 = al4;
            bl5 = al5;
            bl6 = al6;
            bl7 = al7;
            h2 = ah7;
            l2 = al7;
            a2 = l2 & 65535;
            b2 = l2 >>> 16;
            c2 = h2 & 65535;
            d2 = h2 >>> 16;
            h2 = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
            l2 = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
            a2 += l2 & 65535;
            b2 += l2 >>> 16;
            c2 += h2 & 65535;
            d2 += h2 >>> 16;
            h2 = ah4 & ah5 ^ ~ah4 & ah6;
            l2 = al4 & al5 ^ ~al4 & al6;
            a2 += l2 & 65535;
            b2 += l2 >>> 16;
            c2 += h2 & 65535;
            d2 += h2 >>> 16;
            h2 = K2[i2 * 2];
            l2 = K2[i2 * 2 + 1];
            a2 += l2 & 65535;
            b2 += l2 >>> 16;
            c2 += h2 & 65535;
            d2 += h2 >>> 16;
            h2 = wh[i2 % 16];
            l2 = wl[i2 % 16];
            a2 += l2 & 65535;
            b2 += l2 >>> 16;
            c2 += h2 & 65535;
            d2 += h2 >>> 16;
            b2 += a2 >>> 16;
            c2 += b2 >>> 16;
            d2 += c2 >>> 16;
            th = c2 & 65535 | d2 << 16;
            tl = a2 & 65535 | b2 << 16;
            h2 = th;
            l2 = tl;
            a2 = l2 & 65535;
            b2 = l2 >>> 16;
            c2 = h2 & 65535;
            d2 = h2 >>> 16;
            h2 = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
            l2 = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
            a2 += l2 & 65535;
            b2 += l2 >>> 16;
            c2 += h2 & 65535;
            d2 += h2 >>> 16;
            h2 = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
            l2 = al0 & al1 ^ al0 & al2 ^ al1 & al2;
            a2 += l2 & 65535;
            b2 += l2 >>> 16;
            c2 += h2 & 65535;
            d2 += h2 >>> 16;
            b2 += a2 >>> 16;
            c2 += b2 >>> 16;
            d2 += c2 >>> 16;
            bh7 = c2 & 65535 | d2 << 16;
            bl7 = a2 & 65535 | b2 << 16;
            h2 = bh3;
            l2 = bl3;
            a2 = l2 & 65535;
            b2 = l2 >>> 16;
            c2 = h2 & 65535;
            d2 = h2 >>> 16;
            h2 = th;
            l2 = tl;
            a2 += l2 & 65535;
            b2 += l2 >>> 16;
            c2 += h2 & 65535;
            d2 += h2 >>> 16;
            b2 += a2 >>> 16;
            c2 += b2 >>> 16;
            d2 += c2 >>> 16;
            bh3 = c2 & 65535 | d2 << 16;
            bl3 = a2 & 65535 | b2 << 16;
            ah1 = bh0;
            ah2 = bh1;
            ah3 = bh2;
            ah4 = bh3;
            ah5 = bh4;
            ah6 = bh5;
            ah7 = bh6;
            ah0 = bh7;
            al1 = bl0;
            al2 = bl1;
            al3 = bl2;
            al4 = bl3;
            al5 = bl4;
            al6 = bl5;
            al7 = bl6;
            al0 = bl7;
            if (i2 % 16 === 15) {
              for (j2 = 0; j2 < 16; j2++) {
                h2 = wh[j2];
                l2 = wl[j2];
                a2 = l2 & 65535;
                b2 = l2 >>> 16;
                c2 = h2 & 65535;
                d2 = h2 >>> 16;
                h2 = wh[(j2 + 9) % 16];
                l2 = wl[(j2 + 9) % 16];
                a2 += l2 & 65535;
                b2 += l2 >>> 16;
                c2 += h2 & 65535;
                d2 += h2 >>> 16;
                th = wh[(j2 + 1) % 16];
                tl = wl[(j2 + 1) % 16];
                h2 = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
                l2 = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
                a2 += l2 & 65535;
                b2 += l2 >>> 16;
                c2 += h2 & 65535;
                d2 += h2 >>> 16;
                th = wh[(j2 + 14) % 16];
                tl = wl[(j2 + 14) % 16];
                h2 = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
                l2 = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
                a2 += l2 & 65535;
                b2 += l2 >>> 16;
                c2 += h2 & 65535;
                d2 += h2 >>> 16;
                b2 += a2 >>> 16;
                c2 += b2 >>> 16;
                d2 += c2 >>> 16;
                wh[j2] = c2 & 65535 | d2 << 16;
                wl[j2] = a2 & 65535 | b2 << 16;
              }
            }
          }
          h2 = ah0;
          l2 = al0;
          a2 = l2 & 65535;
          b2 = l2 >>> 16;
          c2 = h2 & 65535;
          d2 = h2 >>> 16;
          h2 = hh[0];
          l2 = hl[0];
          a2 += l2 & 65535;
          b2 += l2 >>> 16;
          c2 += h2 & 65535;
          d2 += h2 >>> 16;
          b2 += a2 >>> 16;
          c2 += b2 >>> 16;
          d2 += c2 >>> 16;
          hh[0] = ah0 = c2 & 65535 | d2 << 16;
          hl[0] = al0 = a2 & 65535 | b2 << 16;
          h2 = ah1;
          l2 = al1;
          a2 = l2 & 65535;
          b2 = l2 >>> 16;
          c2 = h2 & 65535;
          d2 = h2 >>> 16;
          h2 = hh[1];
          l2 = hl[1];
          a2 += l2 & 65535;
          b2 += l2 >>> 16;
          c2 += h2 & 65535;
          d2 += h2 >>> 16;
          b2 += a2 >>> 16;
          c2 += b2 >>> 16;
          d2 += c2 >>> 16;
          hh[1] = ah1 = c2 & 65535 | d2 << 16;
          hl[1] = al1 = a2 & 65535 | b2 << 16;
          h2 = ah2;
          l2 = al2;
          a2 = l2 & 65535;
          b2 = l2 >>> 16;
          c2 = h2 & 65535;
          d2 = h2 >>> 16;
          h2 = hh[2];
          l2 = hl[2];
          a2 += l2 & 65535;
          b2 += l2 >>> 16;
          c2 += h2 & 65535;
          d2 += h2 >>> 16;
          b2 += a2 >>> 16;
          c2 += b2 >>> 16;
          d2 += c2 >>> 16;
          hh[2] = ah2 = c2 & 65535 | d2 << 16;
          hl[2] = al2 = a2 & 65535 | b2 << 16;
          h2 = ah3;
          l2 = al3;
          a2 = l2 & 65535;
          b2 = l2 >>> 16;
          c2 = h2 & 65535;
          d2 = h2 >>> 16;
          h2 = hh[3];
          l2 = hl[3];
          a2 += l2 & 65535;
          b2 += l2 >>> 16;
          c2 += h2 & 65535;
          d2 += h2 >>> 16;
          b2 += a2 >>> 16;
          c2 += b2 >>> 16;
          d2 += c2 >>> 16;
          hh[3] = ah3 = c2 & 65535 | d2 << 16;
          hl[3] = al3 = a2 & 65535 | b2 << 16;
          h2 = ah4;
          l2 = al4;
          a2 = l2 & 65535;
          b2 = l2 >>> 16;
          c2 = h2 & 65535;
          d2 = h2 >>> 16;
          h2 = hh[4];
          l2 = hl[4];
          a2 += l2 & 65535;
          b2 += l2 >>> 16;
          c2 += h2 & 65535;
          d2 += h2 >>> 16;
          b2 += a2 >>> 16;
          c2 += b2 >>> 16;
          d2 += c2 >>> 16;
          hh[4] = ah4 = c2 & 65535 | d2 << 16;
          hl[4] = al4 = a2 & 65535 | b2 << 16;
          h2 = ah5;
          l2 = al5;
          a2 = l2 & 65535;
          b2 = l2 >>> 16;
          c2 = h2 & 65535;
          d2 = h2 >>> 16;
          h2 = hh[5];
          l2 = hl[5];
          a2 += l2 & 65535;
          b2 += l2 >>> 16;
          c2 += h2 & 65535;
          d2 += h2 >>> 16;
          b2 += a2 >>> 16;
          c2 += b2 >>> 16;
          d2 += c2 >>> 16;
          hh[5] = ah5 = c2 & 65535 | d2 << 16;
          hl[5] = al5 = a2 & 65535 | b2 << 16;
          h2 = ah6;
          l2 = al6;
          a2 = l2 & 65535;
          b2 = l2 >>> 16;
          c2 = h2 & 65535;
          d2 = h2 >>> 16;
          h2 = hh[6];
          l2 = hl[6];
          a2 += l2 & 65535;
          b2 += l2 >>> 16;
          c2 += h2 & 65535;
          d2 += h2 >>> 16;
          b2 += a2 >>> 16;
          c2 += b2 >>> 16;
          d2 += c2 >>> 16;
          hh[6] = ah6 = c2 & 65535 | d2 << 16;
          hl[6] = al6 = a2 & 65535 | b2 << 16;
          h2 = ah7;
          l2 = al7;
          a2 = l2 & 65535;
          b2 = l2 >>> 16;
          c2 = h2 & 65535;
          d2 = h2 >>> 16;
          h2 = hh[7];
          l2 = hl[7];
          a2 += l2 & 65535;
          b2 += l2 >>> 16;
          c2 += h2 & 65535;
          d2 += h2 >>> 16;
          b2 += a2 >>> 16;
          c2 += b2 >>> 16;
          d2 += c2 >>> 16;
          hh[7] = ah7 = c2 & 65535 | d2 << 16;
          hl[7] = al7 = a2 & 65535 | b2 << 16;
          pos += 128;
          n2 -= 128;
        }
        return n2;
      }
      function crypto_hash(out, m2, n2) {
        var hh = new Int32Array(8), hl = new Int32Array(8), x2 = new Uint8Array(256), i2, b2 = n2;
        hh[0] = 1779033703;
        hh[1] = 3144134277;
        hh[2] = 1013904242;
        hh[3] = 2773480762;
        hh[4] = 1359893119;
        hh[5] = 2600822924;
        hh[6] = 528734635;
        hh[7] = 1541459225;
        hl[0] = 4089235720;
        hl[1] = 2227873595;
        hl[2] = 4271175723;
        hl[3] = 1595750129;
        hl[4] = 2917565137;
        hl[5] = 725511199;
        hl[6] = 4215389547;
        hl[7] = 327033209;
        crypto_hashblocks_hl(hh, hl, m2, n2);
        n2 %= 128;
        for (i2 = 0; i2 < n2; i2++) x2[i2] = m2[b2 - n2 + i2];
        x2[n2] = 128;
        n2 = 256 - 128 * (n2 < 112 ? 1 : 0);
        x2[n2 - 9] = 0;
        ts64(x2, n2 - 8, b2 / 536870912 | 0, b2 << 3);
        crypto_hashblocks_hl(hh, hl, x2, n2);
        for (i2 = 0; i2 < 8; i2++) ts64(out, 8 * i2, hh[i2], hl[i2]);
        return 0;
      }
      function add(p2, q2) {
        var a2 = gf(), b2 = gf(), c2 = gf(), d2 = gf(), e2 = gf(), f2 = gf(), g2 = gf(), h2 = gf(), t = gf();
        Z2(a2, p2[1], p2[0]);
        Z2(t, q2[1], q2[0]);
        M2(a2, a2, t);
        A2(b2, p2[0], p2[1]);
        A2(t, q2[0], q2[1]);
        M2(b2, b2, t);
        M2(c2, p2[3], q2[3]);
        M2(c2, c2, D22);
        M2(d2, p2[2], q2[2]);
        A2(d2, d2, d2);
        Z2(e2, b2, a2);
        Z2(f2, d2, c2);
        A2(g2, d2, c2);
        A2(h2, b2, a2);
        M2(p2[0], e2, f2);
        M2(p2[1], h2, g2);
        M2(p2[2], g2, f2);
        M2(p2[3], e2, h2);
      }
      function cswap(p2, q2, b2) {
        var i2;
        for (i2 = 0; i2 < 4; i2++) {
          sel25519(p2[i2], q2[i2], b2);
        }
      }
      function pack(r3, p2) {
        var tx = gf(), ty = gf(), zi = gf();
        inv25519(zi, p2[2]);
        M2(tx, p2[0], zi);
        M2(ty, p2[1], zi);
        pack25519(r3, ty);
        r3[31] ^= par25519(tx) << 7;
      }
      function scalarmult(p2, q2, s2) {
        var b2, i2;
        set25519(p2[0], gf0);
        set25519(p2[1], gf1);
        set25519(p2[2], gf1);
        set25519(p2[3], gf0);
        for (i2 = 255; i2 >= 0; --i2) {
          b2 = s2[i2 / 8 | 0] >> (i2 & 7) & 1;
          cswap(p2, q2, b2);
          add(q2, p2);
          add(p2, p2);
          cswap(p2, q2, b2);
        }
      }
      function scalarbase(p2, s2) {
        var q2 = [gf(), gf(), gf(), gf()];
        set25519(q2[0], X2);
        set25519(q2[1], Y2);
        set25519(q2[2], gf1);
        M2(q2[3], X2, Y2);
        scalarmult(p2, q2, s2);
      }
      function crypto_sign_keypair(pk, sk, seeded) {
        var d2 = new Uint8Array(64);
        var p2 = [gf(), gf(), gf(), gf()];
        var i2;
        if (!seeded) randombytes(sk, 32);
        crypto_hash(d2, sk, 32);
        d2[0] &= 248;
        d2[31] &= 127;
        d2[31] |= 64;
        scalarbase(p2, d2);
        pack(pk, p2);
        for (i2 = 0; i2 < 32; i2++) sk[i2 + 32] = pk[i2];
        return 0;
      }
      var L2 = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
      function modL(r3, x2) {
        var carry, i2, j2, k2;
        for (i2 = 63; i2 >= 32; --i2) {
          carry = 0;
          for (j2 = i2 - 32, k2 = i2 - 12; j2 < k2; ++j2) {
            x2[j2] += carry - 16 * x2[i2] * L2[j2 - (i2 - 32)];
            carry = Math.floor((x2[j2] + 128) / 256);
            x2[j2] -= carry * 256;
          }
          x2[j2] += carry;
          x2[i2] = 0;
        }
        carry = 0;
        for (j2 = 0; j2 < 32; j2++) {
          x2[j2] += carry - (x2[31] >> 4) * L2[j2];
          carry = x2[j2] >> 8;
          x2[j2] &= 255;
        }
        for (j2 = 0; j2 < 32; j2++) x2[j2] -= carry * L2[j2];
        for (i2 = 0; i2 < 32; i2++) {
          x2[i2 + 1] += x2[i2] >> 8;
          r3[i2] = x2[i2] & 255;
        }
      }
      function reduce(r3) {
        var x2 = new Float64Array(64), i2;
        for (i2 = 0; i2 < 64; i2++) x2[i2] = r3[i2];
        for (i2 = 0; i2 < 64; i2++) r3[i2] = 0;
        modL(r3, x2);
      }
      function crypto_sign(sm, m2, n2, sk) {
        var d2 = new Uint8Array(64), h2 = new Uint8Array(64), r3 = new Uint8Array(64);
        var i2, j2, x2 = new Float64Array(64);
        var p2 = [gf(), gf(), gf(), gf()];
        crypto_hash(d2, sk, 32);
        d2[0] &= 248;
        d2[31] &= 127;
        d2[31] |= 64;
        var smlen = n2 + 64;
        for (i2 = 0; i2 < n2; i2++) sm[64 + i2] = m2[i2];
        for (i2 = 0; i2 < 32; i2++) sm[32 + i2] = d2[32 + i2];
        crypto_hash(r3, sm.subarray(32), n2 + 32);
        reduce(r3);
        scalarbase(p2, r3);
        pack(sm, p2);
        for (i2 = 32; i2 < 64; i2++) sm[i2] = sk[i2];
        crypto_hash(h2, sm, n2 + 64);
        reduce(h2);
        for (i2 = 0; i2 < 64; i2++) x2[i2] = 0;
        for (i2 = 0; i2 < 32; i2++) x2[i2] = r3[i2];
        for (i2 = 0; i2 < 32; i2++) {
          for (j2 = 0; j2 < 32; j2++) {
            x2[i2 + j2] += h2[i2] * d2[j2];
          }
        }
        modL(sm.subarray(32), x2);
        return smlen;
      }
      function unpackneg(r3, p2) {
        var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
        set25519(r3[2], gf1);
        unpack25519(r3[1], p2);
        S2(num, r3[1]);
        M2(den, num, D2);
        Z2(num, num, r3[2]);
        A2(den, r3[2], den);
        S2(den2, den);
        S2(den4, den2);
        M2(den6, den4, den2);
        M2(t, den6, num);
        M2(t, t, den);
        pow2523(t, t);
        M2(t, t, num);
        M2(t, t, den);
        M2(t, t, den);
        M2(r3[0], t, den);
        S2(chk, r3[0]);
        M2(chk, chk, den);
        if (neq25519(chk, num)) M2(r3[0], r3[0], I2);
        S2(chk, r3[0]);
        M2(chk, chk, den);
        if (neq25519(chk, num)) return -1;
        if (par25519(r3[0]) === p2[31] >> 7) Z2(r3[0], gf0, r3[0]);
        M2(r3[3], r3[0], r3[1]);
        return 0;
      }
      function crypto_sign_open(m2, sm, n2, pk) {
        var i2;
        var t = new Uint8Array(32), h2 = new Uint8Array(64);
        var p2 = [gf(), gf(), gf(), gf()], q2 = [gf(), gf(), gf(), gf()];
        if (n2 < 64) return -1;
        if (unpackneg(q2, pk)) return -1;
        for (i2 = 0; i2 < n2; i2++) m2[i2] = sm[i2];
        for (i2 = 0; i2 < 32; i2++) m2[i2 + 32] = pk[i2];
        crypto_hash(h2, m2, n2);
        reduce(h2);
        scalarmult(p2, q2, h2);
        scalarbase(q2, sm.subarray(32));
        add(p2, q2);
        pack(t, p2);
        n2 -= 64;
        if (crypto_verify_32(sm, 0, t, 0)) {
          for (i2 = 0; i2 < n2; i2++) m2[i2] = 0;
          return -1;
        }
        for (i2 = 0; i2 < n2; i2++) m2[i2] = sm[i2 + 64];
        return n2;
      }
      var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
      nacl2.lowlevel = {
        crypto_core_hsalsa20,
        crypto_stream_xor,
        crypto_stream,
        crypto_stream_salsa20_xor,
        crypto_stream_salsa20,
        crypto_onetimeauth,
        crypto_onetimeauth_verify,
        crypto_verify_16,
        crypto_verify_32,
        crypto_secretbox,
        crypto_secretbox_open,
        crypto_scalarmult,
        crypto_scalarmult_base,
        crypto_box_beforenm,
        crypto_box_afternm,
        crypto_box,
        crypto_box_open,
        crypto_box_keypair,
        crypto_hash,
        crypto_sign,
        crypto_sign_keypair,
        crypto_sign_open,
        crypto_secretbox_KEYBYTES,
        crypto_secretbox_NONCEBYTES,
        crypto_secretbox_ZEROBYTES,
        crypto_secretbox_BOXZEROBYTES,
        crypto_scalarmult_BYTES,
        crypto_scalarmult_SCALARBYTES,
        crypto_box_PUBLICKEYBYTES,
        crypto_box_SECRETKEYBYTES,
        crypto_box_BEFORENMBYTES,
        crypto_box_NONCEBYTES,
        crypto_box_ZEROBYTES,
        crypto_box_BOXZEROBYTES,
        crypto_sign_BYTES,
        crypto_sign_PUBLICKEYBYTES,
        crypto_sign_SECRETKEYBYTES,
        crypto_sign_SEEDBYTES,
        crypto_hash_BYTES,
        gf,
        D: D2,
        L: L2,
        pack25519,
        unpack25519,
        M: M2,
        A: A2,
        S: S2,
        Z: Z2,
        pow2523,
        add,
        set25519,
        modL,
        scalarmult,
        scalarbase
      };
      function checkLengths(k2, n2) {
        if (k2.length !== crypto_secretbox_KEYBYTES) throw new Error("bad key size");
        if (n2.length !== crypto_secretbox_NONCEBYTES) throw new Error("bad nonce size");
      }
      function checkBoxLengths(pk, sk) {
        if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error("bad public key size");
        if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error("bad secret key size");
      }
      function checkArrayTypes() {
        for (var i2 = 0; i2 < arguments.length; i2++) {
          if (!(arguments[i2] instanceof Uint8Array))
            throw new TypeError("unexpected type, use Uint8Array");
        }
      }
      function cleanup(arr) {
        for (var i2 = 0; i2 < arr.length; i2++) arr[i2] = 0;
      }
      nacl2.randomBytes = function(n2) {
        var b2 = new Uint8Array(n2);
        randombytes(b2, n2);
        return b2;
      };
      nacl2.secretbox = function(msg, nonce, key) {
        checkArrayTypes(msg, nonce, key);
        checkLengths(key, nonce);
        var m2 = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
        var c2 = new Uint8Array(m2.length);
        for (var i2 = 0; i2 < msg.length; i2++) m2[i2 + crypto_secretbox_ZEROBYTES] = msg[i2];
        crypto_secretbox(c2, m2, m2.length, nonce, key);
        return c2.subarray(crypto_secretbox_BOXZEROBYTES);
      };
      nacl2.secretbox.open = function(box, nonce, key) {
        checkArrayTypes(box, nonce, key);
        checkLengths(key, nonce);
        var c2 = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
        var m2 = new Uint8Array(c2.length);
        for (var i2 = 0; i2 < box.length; i2++) c2[i2 + crypto_secretbox_BOXZEROBYTES] = box[i2];
        if (c2.length < 32) return null;
        if (crypto_secretbox_open(m2, c2, c2.length, nonce, key) !== 0) return null;
        return m2.subarray(crypto_secretbox_ZEROBYTES);
      };
      nacl2.secretbox.keyLength = crypto_secretbox_KEYBYTES;
      nacl2.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
      nacl2.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
      nacl2.scalarMult = function(n2, p2) {
        checkArrayTypes(n2, p2);
        if (n2.length !== crypto_scalarmult_SCALARBYTES) throw new Error("bad n size");
        if (p2.length !== crypto_scalarmult_BYTES) throw new Error("bad p size");
        var q2 = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult(q2, n2, p2);
        return q2;
      };
      nacl2.scalarMult.base = function(n2) {
        checkArrayTypes(n2);
        if (n2.length !== crypto_scalarmult_SCALARBYTES) throw new Error("bad n size");
        var q2 = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult_base(q2, n2);
        return q2;
      };
      nacl2.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
      nacl2.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
      nacl2.box = function(msg, nonce, publicKey, secretKey) {
        var k2 = nacl2.box.before(publicKey, secretKey);
        return nacl2.secretbox(msg, nonce, k2);
      };
      nacl2.box.before = function(publicKey, secretKey) {
        checkArrayTypes(publicKey, secretKey);
        checkBoxLengths(publicKey, secretKey);
        var k2 = new Uint8Array(crypto_box_BEFORENMBYTES);
        crypto_box_beforenm(k2, publicKey, secretKey);
        return k2;
      };
      nacl2.box.after = nacl2.secretbox;
      nacl2.box.open = function(msg, nonce, publicKey, secretKey) {
        var k2 = nacl2.box.before(publicKey, secretKey);
        return nacl2.secretbox.open(msg, nonce, k2);
      };
      nacl2.box.open.after = nacl2.secretbox.open;
      nacl2.box.keyPair = function() {
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
        crypto_box_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl2.box.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_box_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        crypto_scalarmult_base(pk, secretKey);
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl2.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
      nacl2.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
      nacl2.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
      nacl2.box.nonceLength = crypto_box_NONCEBYTES;
      nacl2.box.overheadLength = nacl2.secretbox.overheadLength;
      nacl2.sign = function(msg, secretKey) {
        checkArrayTypes(msg, secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
        crypto_sign(signedMsg, msg, msg.length, secretKey);
        return signedMsg;
      };
      nacl2.sign.open = function(signedMsg, publicKey) {
        checkArrayTypes(signedMsg, publicKey);
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var tmp = new Uint8Array(signedMsg.length);
        var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
        if (mlen < 0) return null;
        var m2 = new Uint8Array(mlen);
        for (var i2 = 0; i2 < m2.length; i2++) m2[i2] = tmp[i2];
        return m2;
      };
      nacl2.sign.detached = function(msg, secretKey) {
        var signedMsg = nacl2.sign(msg, secretKey);
        var sig = new Uint8Array(crypto_sign_BYTES);
        for (var i2 = 0; i2 < sig.length; i2++) sig[i2] = signedMsg[i2];
        return sig;
      };
      nacl2.sign.detached.verify = function(msg, sig, publicKey) {
        checkArrayTypes(msg, sig, publicKey);
        if (sig.length !== crypto_sign_BYTES)
          throw new Error("bad signature size");
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
          throw new Error("bad public key size");
        var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
        var m2 = new Uint8Array(crypto_sign_BYTES + msg.length);
        var i2;
        for (i2 = 0; i2 < crypto_sign_BYTES; i2++) sm[i2] = sig[i2];
        for (i2 = 0; i2 < msg.length; i2++) sm[i2 + crypto_sign_BYTES] = msg[i2];
        return crypto_sign_open(m2, sm, sm.length, publicKey) >= 0;
      };
      nacl2.sign.keyPair = function() {
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        crypto_sign_keypair(pk, sk);
        return { publicKey: pk, secretKey: sk };
      };
      nacl2.sign.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
          throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        for (var i2 = 0; i2 < pk.length; i2++) pk[i2] = secretKey[32 + i2];
        return { publicKey: pk, secretKey: new Uint8Array(secretKey) };
      };
      nacl2.sign.keyPair.fromSeed = function(seed) {
        checkArrayTypes(seed);
        if (seed.length !== crypto_sign_SEEDBYTES)
          throw new Error("bad seed size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        for (var i2 = 0; i2 < 32; i2++) sk[i2] = seed[i2];
        crypto_sign_keypair(pk, sk, true);
        return { publicKey: pk, secretKey: sk };
      };
      nacl2.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
      nacl2.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
      nacl2.sign.seedLength = crypto_sign_SEEDBYTES;
      nacl2.sign.signatureLength = crypto_sign_BYTES;
      nacl2.hash = function(msg) {
        checkArrayTypes(msg);
        var h2 = new Uint8Array(crypto_hash_BYTES);
        crypto_hash(h2, msg, msg.length);
        return h2;
      };
      nacl2.hash.hashLength = crypto_hash_BYTES;
      nacl2.verify = function(x2, y2) {
        checkArrayTypes(x2, y2);
        if (x2.length === 0 || y2.length === 0) return false;
        if (x2.length !== y2.length) return false;
        return vn(x2, 0, y2, 0, x2.length) === 0 ? true : false;
      };
      nacl2.setPRNG = function(fn) {
        randombytes = fn;
      };
      (function() {
        var crypto2 = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
        if (crypto2 && crypto2.getRandomValues) {
          var QUOTA = 65536;
          nacl2.setPRNG(function(x2, n2) {
            var i2, v2 = new Uint8Array(n2);
            for (i2 = 0; i2 < n2; i2 += QUOTA) {
              crypto2.getRandomValues(v2.subarray(i2, i2 + Math.min(n2 - i2, QUOTA)));
            }
            for (i2 = 0; i2 < n2; i2++) x2[i2] = v2[i2];
            cleanup(v2);
          });
        } else if (typeof __require !== "undefined") {
          crypto2 = require_crypto2();
          if (crypto2 && crypto2.randomBytes) {
            nacl2.setPRNG(function(x2, n2) {
              var i2, v2 = crypto2.randomBytes(n2);
              for (i2 = 0; i2 < n2; i2++) x2[i2] = v2[i2];
              cleanup(v2);
            });
          }
        }
      })();
    })(typeof module !== "undefined" && module.exports ? module.exports : self.nacl = self.nacl || {});
  }
});

// node_modules/js-sha512/src/sha512.js
var require_sha512 = __commonJS({
  "node_modules/js-sha512/src/sha512.js"(exports, module) {
    (function() {
      "use strict";
      var INPUT_ERROR = "input is invalid type";
      var FINALIZE_ERROR = "finalize already called";
      var WINDOW = typeof window === "object";
      var root = WINDOW ? window : {};
      if (root.JS_SHA512_NO_WINDOW) {
        WINDOW = false;
      }
      var WEB_WORKER = !WINDOW && typeof self === "object";
      var NODE_JS = !root.JS_SHA512_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS) {
        root = global;
      } else if (WEB_WORKER) {
        root = self;
      }
      var COMMON_JS = !root.JS_SHA512_NO_COMMON_JS && typeof module === "object" && module.exports;
      var AMD = typeof define === "function" && define.amd;
      var ARRAY_BUFFER = !root.JS_SHA512_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS = "0123456789abcdef".split("");
      var EXTRA = [-2147483648, 8388608, 32768, 128];
      var SHIFT = [24, 16, 8, 0];
      var K2 = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ];
      var OUTPUT_TYPES = ["hex", "array", "digest", "arrayBuffer"];
      var blocks = [];
      if (root.JS_SHA512_NO_NODE_JS || !Array.isArray) {
        Array.isArray = function(obj) {
          return Object.prototype.toString.call(obj) === "[object Array]";
        };
      }
      if (ARRAY_BUFFER && (root.JS_SHA512_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
        ArrayBuffer.isView = function(obj) {
          return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
        };
      }
      var createOutputMethod = function(outputType, bits) {
        return function(message) {
          return new Sha512(bits, true).update(message)[outputType]();
        };
      };
      var createMethod = function(bits) {
        var method = createOutputMethod("hex", bits);
        method.create = function() {
          return new Sha512(bits);
        };
        method.update = function(message) {
          return method.create().update(message);
        };
        for (var i2 = 0; i2 < OUTPUT_TYPES.length; ++i2) {
          var type = OUTPUT_TYPES[i2];
          method[type] = createOutputMethod(type, bits);
        }
        return method;
      };
      var createHmacOutputMethod = function(outputType, bits) {
        return function(key, message) {
          return new HmacSha512(key, bits, true).update(message)[outputType]();
        };
      };
      var createHmacMethod = function(bits) {
        var method = createHmacOutputMethod("hex", bits);
        method.create = function(key) {
          return new HmacSha512(key, bits);
        };
        method.update = function(key, message) {
          return method.create(key).update(message);
        };
        for (var i2 = 0; i2 < OUTPUT_TYPES.length; ++i2) {
          var type = OUTPUT_TYPES[i2];
          method[type] = createHmacOutputMethod(type, bits);
        }
        return method;
      };
      function Sha512(bits, sharedMemory) {
        if (sharedMemory) {
          blocks[0] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = blocks[16] = blocks[17] = blocks[18] = blocks[19] = blocks[20] = blocks[21] = blocks[22] = blocks[23] = blocks[24] = blocks[25] = blocks[26] = blocks[27] = blocks[28] = blocks[29] = blocks[30] = blocks[31] = blocks[32] = 0;
          this.blocks = blocks;
        } else {
          this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        }
        if (bits == 384) {
          this.h0h = 3418070365;
          this.h0l = 3238371032;
          this.h1h = 1654270250;
          this.h1l = 914150663;
          this.h2h = 2438529370;
          this.h2l = 812702999;
          this.h3h = 355462360;
          this.h3l = 4144912697;
          this.h4h = 1731405415;
          this.h4l = 4290775857;
          this.h5h = 2394180231;
          this.h5l = 1750603025;
          this.h6h = 3675008525;
          this.h6l = 1694076839;
          this.h7h = 1203062813;
          this.h7l = 3204075428;
        } else if (bits == 256) {
          this.h0h = 573645204;
          this.h0l = 4230739756;
          this.h1h = 2673172387;
          this.h1l = 3360449730;
          this.h2h = 596883563;
          this.h2l = 1867755857;
          this.h3h = 2520282905;
          this.h3l = 1497426621;
          this.h4h = 2519219938;
          this.h4l = 2827943907;
          this.h5h = 3193839141;
          this.h5l = 1401305490;
          this.h6h = 721525244;
          this.h6l = 746961066;
          this.h7h = 246885852;
          this.h7l = 2177182882;
        } else if (bits == 224) {
          this.h0h = 2352822216;
          this.h0l = 424955298;
          this.h1h = 1944164710;
          this.h1l = 2312950998;
          this.h2h = 502970286;
          this.h2l = 855612546;
          this.h3h = 1738396948;
          this.h3l = 1479516111;
          this.h4h = 258812777;
          this.h4l = 2077511080;
          this.h5h = 2011393907;
          this.h5l = 79989058;
          this.h6h = 1067287976;
          this.h6l = 1780299464;
          this.h7h = 286451373;
          this.h7l = 2446758561;
        } else {
          this.h0h = 1779033703;
          this.h0l = 4089235720;
          this.h1h = 3144134277;
          this.h1l = 2227873595;
          this.h2h = 1013904242;
          this.h2l = 4271175723;
          this.h3h = 2773480762;
          this.h3l = 1595750129;
          this.h4h = 1359893119;
          this.h4l = 2917565137;
          this.h5h = 2600822924;
          this.h5l = 725511199;
          this.h6h = 528734635;
          this.h6l = 4215389547;
          this.h7h = 1541459225;
          this.h7l = 327033209;
        }
        this.bits = bits;
        this.block = this.start = this.bytes = this.hBytes = 0;
        this.finalized = this.hashed = false;
      }
      Sha512.prototype.update = function(message) {
        if (this.finalized) {
          throw new Error(FINALIZE_ERROR);
        }
        var notString, type = typeof message;
        if (type !== "string") {
          if (type === "object") {
            if (message === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
              message = new Uint8Array(message);
            } else if (!Array.isArray(message)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var code, index = 0, i2, length = message.length, blocks2 = this.blocks;
        while (index < length) {
          if (this.hashed) {
            this.hashed = false;
            blocks2[0] = this.block;
            blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = blocks2[16] = blocks2[17] = blocks2[18] = blocks2[19] = blocks2[20] = blocks2[21] = blocks2[22] = blocks2[23] = blocks2[24] = blocks2[25] = blocks2[26] = blocks2[27] = blocks2[28] = blocks2[29] = blocks2[30] = blocks2[31] = blocks2[32] = 0;
          }
          if (notString) {
            for (i2 = this.start; index < length && i2 < 128; ++index) {
              blocks2[i2 >> 2] |= message[index] << SHIFT[i2++ & 3];
            }
          } else {
            for (i2 = this.start; index < length && i2 < 128; ++index) {
              code = message.charCodeAt(index);
              if (code < 128) {
                blocks2[i2 >> 2] |= code << SHIFT[i2++ & 3];
              } else if (code < 2048) {
                blocks2[i2 >> 2] |= (192 | code >> 6) << SHIFT[i2++ & 3];
                blocks2[i2 >> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
              } else if (code < 55296 || code >= 57344) {
                blocks2[i2 >> 2] |= (224 | code >> 12) << SHIFT[i2++ & 3];
                blocks2[i2 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i2++ & 3];
                blocks2[i2 >> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
              } else {
                code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                blocks2[i2 >> 2] |= (240 | code >> 18) << SHIFT[i2++ & 3];
                blocks2[i2 >> 2] |= (128 | code >> 12 & 63) << SHIFT[i2++ & 3];
                blocks2[i2 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i2++ & 3];
                blocks2[i2 >> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
              }
            }
          }
          this.lastByteIndex = i2;
          this.bytes += i2 - this.start;
          if (i2 >= 128) {
            this.block = blocks2[32];
            this.start = i2 - 128;
            this.hash();
            this.hashed = true;
          } else {
            this.start = i2;
          }
        }
        if (this.bytes > 4294967295) {
          this.hBytes += this.bytes / 4294967296 << 0;
          this.bytes = this.bytes % 4294967296;
        }
        return this;
      };
      Sha512.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks2 = this.blocks, i2 = this.lastByteIndex;
        blocks2[32] = this.block;
        blocks2[i2 >> 2] |= EXTRA[i2 & 3];
        this.block = blocks2[32];
        if (i2 >= 112) {
          if (!this.hashed) {
            this.hash();
          }
          blocks2[0] = this.block;
          blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = blocks2[16] = blocks2[17] = blocks2[18] = blocks2[19] = blocks2[20] = blocks2[21] = blocks2[22] = blocks2[23] = blocks2[24] = blocks2[25] = blocks2[26] = blocks2[27] = blocks2[28] = blocks2[29] = blocks2[30] = blocks2[31] = blocks2[32] = 0;
        }
        blocks2[30] = this.hBytes << 3 | this.bytes >>> 29;
        blocks2[31] = this.bytes << 3;
        this.hash();
      };
      Sha512.prototype.hash = function() {
        var h0h = this.h0h, h0l = this.h0l, h1h = this.h1h, h1l = this.h1l, h2h = this.h2h, h2l = this.h2l, h3h = this.h3h, h3l = this.h3l, h4h = this.h4h, h4l = this.h4l, h5h = this.h5h, h5l = this.h5l, h6h = this.h6h, h6l = this.h6l, h7h = this.h7h, h7l = this.h7l, blocks2 = this.blocks, j2, s0h, s0l, s1h, s1l, c1, c2, c3, c4, abh, abl, dah, dal, cdh, cdl, bch, bcl, majh, majl, t1h, t1l, t2h, t2l, chh, chl;
        for (j2 = 32; j2 < 160; j2 += 2) {
          t1h = blocks2[j2 - 30];
          t1l = blocks2[j2 - 29];
          s0h = (t1h >>> 1 | t1l << 31) ^ (t1h >>> 8 | t1l << 24) ^ t1h >>> 7;
          s0l = (t1l >>> 1 | t1h << 31) ^ (t1l >>> 8 | t1h << 24) ^ (t1l >>> 7 | t1h << 25);
          t1h = blocks2[j2 - 4];
          t1l = blocks2[j2 - 3];
          s1h = (t1h >>> 19 | t1l << 13) ^ (t1l >>> 29 | t1h << 3) ^ t1h >>> 6;
          s1l = (t1l >>> 19 | t1h << 13) ^ (t1h >>> 29 | t1l << 3) ^ (t1l >>> 6 | t1h << 26);
          t1h = blocks2[j2 - 32];
          t1l = blocks2[j2 - 31];
          t2h = blocks2[j2 - 14];
          t2l = blocks2[j2 - 13];
          c1 = (t2l & 65535) + (t1l & 65535) + (s0l & 65535) + (s1l & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (s0l >>> 16) + (s1l >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (s0h & 65535) + (s1h & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (s0h >>> 16) + (s1h >>> 16) + (c3 >>> 16);
          blocks2[j2] = c4 << 16 | c3 & 65535;
          blocks2[j2 + 1] = c2 << 16 | c1 & 65535;
        }
        var ah = h0h, al = h0l, bh = h1h, bl = h1l, ch = h2h, cl = h2l, dh = h3h, dl = h3l, eh = h4h, el = h4l, fh = h5h, fl = h5l, gh = h6h, gl = h6l, hh = h7h, hl = h7l;
        bch = bh & ch;
        bcl = bl & cl;
        for (j2 = 0; j2 < 160; j2 += 8) {
          s0h = (ah >>> 28 | al << 4) ^ (al >>> 2 | ah << 30) ^ (al >>> 7 | ah << 25);
          s0l = (al >>> 28 | ah << 4) ^ (ah >>> 2 | al << 30) ^ (ah >>> 7 | al << 25);
          s1h = (eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (el >>> 9 | eh << 23);
          s1l = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (eh >>> 9 | el << 23);
          abh = ah & bh;
          abl = al & bl;
          majh = abh ^ ah & ch ^ bch;
          majl = abl ^ al & cl ^ bcl;
          chh = eh & fh ^ ~eh & gh;
          chl = el & fl ^ ~el & gl;
          t1h = blocks2[j2];
          t1l = blocks2[j2 + 1];
          t2h = K2[j2];
          t2l = K2[j2 + 1];
          c1 = (t2l & 65535) + (t1l & 65535) + (chl & 65535) + (s1l & 65535) + (hl & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (hl >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (chh & 65535) + (s1h & 65535) + (hh & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (hh >>> 16) + (c3 >>> 16);
          t1h = c4 << 16 | c3 & 65535;
          t1l = c2 << 16 | c1 & 65535;
          c1 = (majl & 65535) + (s0l & 65535);
          c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
          c3 = (majh & 65535) + (s0h & 65535) + (c2 >>> 16);
          c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);
          t2h = c4 << 16 | c3 & 65535;
          t2l = c2 << 16 | c1 & 65535;
          c1 = (dl & 65535) + (t1l & 65535);
          c2 = (dl >>> 16) + (t1l >>> 16) + (c1 >>> 16);
          c3 = (dh & 65535) + (t1h & 65535) + (c2 >>> 16);
          c4 = (dh >>> 16) + (t1h >>> 16) + (c3 >>> 16);
          hh = c4 << 16 | c3 & 65535;
          hl = c2 << 16 | c1 & 65535;
          c1 = (t2l & 65535) + (t1l & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);
          dh = c4 << 16 | c3 & 65535;
          dl = c2 << 16 | c1 & 65535;
          s0h = (dh >>> 28 | dl << 4) ^ (dl >>> 2 | dh << 30) ^ (dl >>> 7 | dh << 25);
          s0l = (dl >>> 28 | dh << 4) ^ (dh >>> 2 | dl << 30) ^ (dh >>> 7 | dl << 25);
          s1h = (hh >>> 14 | hl << 18) ^ (hh >>> 18 | hl << 14) ^ (hl >>> 9 | hh << 23);
          s1l = (hl >>> 14 | hh << 18) ^ (hl >>> 18 | hh << 14) ^ (hh >>> 9 | hl << 23);
          dah = dh & ah;
          dal = dl & al;
          majh = dah ^ dh & bh ^ abh;
          majl = dal ^ dl & bl ^ abl;
          chh = hh & eh ^ ~hh & fh;
          chl = hl & el ^ ~hl & fl;
          t1h = blocks2[j2 + 2];
          t1l = blocks2[j2 + 3];
          t2h = K2[j2 + 2];
          t2l = K2[j2 + 3];
          c1 = (t2l & 65535) + (t1l & 65535) + (chl & 65535) + (s1l & 65535) + (gl & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (gl >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (chh & 65535) + (s1h & 65535) + (gh & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (gh >>> 16) + (c3 >>> 16);
          t1h = c4 << 16 | c3 & 65535;
          t1l = c2 << 16 | c1 & 65535;
          c1 = (majl & 65535) + (s0l & 65535);
          c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
          c3 = (majh & 65535) + (s0h & 65535) + (c2 >>> 16);
          c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);
          t2h = c4 << 16 | c3 & 65535;
          t2l = c2 << 16 | c1 & 65535;
          c1 = (cl & 65535) + (t1l & 65535);
          c2 = (cl >>> 16) + (t1l >>> 16) + (c1 >>> 16);
          c3 = (ch & 65535) + (t1h & 65535) + (c2 >>> 16);
          c4 = (ch >>> 16) + (t1h >>> 16) + (c3 >>> 16);
          gh = c4 << 16 | c3 & 65535;
          gl = c2 << 16 | c1 & 65535;
          c1 = (t2l & 65535) + (t1l & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);
          ch = c4 << 16 | c3 & 65535;
          cl = c2 << 16 | c1 & 65535;
          s0h = (ch >>> 28 | cl << 4) ^ (cl >>> 2 | ch << 30) ^ (cl >>> 7 | ch << 25);
          s0l = (cl >>> 28 | ch << 4) ^ (ch >>> 2 | cl << 30) ^ (ch >>> 7 | cl << 25);
          s1h = (gh >>> 14 | gl << 18) ^ (gh >>> 18 | gl << 14) ^ (gl >>> 9 | gh << 23);
          s1l = (gl >>> 14 | gh << 18) ^ (gl >>> 18 | gh << 14) ^ (gh >>> 9 | gl << 23);
          cdh = ch & dh;
          cdl = cl & dl;
          majh = cdh ^ ch & ah ^ dah;
          majl = cdl ^ cl & al ^ dal;
          chh = gh & hh ^ ~gh & eh;
          chl = gl & hl ^ ~gl & el;
          t1h = blocks2[j2 + 4];
          t1l = blocks2[j2 + 5];
          t2h = K2[j2 + 4];
          t2l = K2[j2 + 5];
          c1 = (t2l & 65535) + (t1l & 65535) + (chl & 65535) + (s1l & 65535) + (fl & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (fl >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (chh & 65535) + (s1h & 65535) + (fh & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (fh >>> 16) + (c3 >>> 16);
          t1h = c4 << 16 | c3 & 65535;
          t1l = c2 << 16 | c1 & 65535;
          c1 = (majl & 65535) + (s0l & 65535);
          c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
          c3 = (majh & 65535) + (s0h & 65535) + (c2 >>> 16);
          c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);
          t2h = c4 << 16 | c3 & 65535;
          t2l = c2 << 16 | c1 & 65535;
          c1 = (bl & 65535) + (t1l & 65535);
          c2 = (bl >>> 16) + (t1l >>> 16) + (c1 >>> 16);
          c3 = (bh & 65535) + (t1h & 65535) + (c2 >>> 16);
          c4 = (bh >>> 16) + (t1h >>> 16) + (c3 >>> 16);
          fh = c4 << 16 | c3 & 65535;
          fl = c2 << 16 | c1 & 65535;
          c1 = (t2l & 65535) + (t1l & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);
          bh = c4 << 16 | c3 & 65535;
          bl = c2 << 16 | c1 & 65535;
          s0h = (bh >>> 28 | bl << 4) ^ (bl >>> 2 | bh << 30) ^ (bl >>> 7 | bh << 25);
          s0l = (bl >>> 28 | bh << 4) ^ (bh >>> 2 | bl << 30) ^ (bh >>> 7 | bl << 25);
          s1h = (fh >>> 14 | fl << 18) ^ (fh >>> 18 | fl << 14) ^ (fl >>> 9 | fh << 23);
          s1l = (fl >>> 14 | fh << 18) ^ (fl >>> 18 | fh << 14) ^ (fh >>> 9 | fl << 23);
          bch = bh & ch;
          bcl = bl & cl;
          majh = bch ^ bh & dh ^ cdh;
          majl = bcl ^ bl & dl ^ cdl;
          chh = fh & gh ^ ~fh & hh;
          chl = fl & gl ^ ~fl & hl;
          t1h = blocks2[j2 + 6];
          t1l = blocks2[j2 + 7];
          t2h = K2[j2 + 6];
          t2l = K2[j2 + 7];
          c1 = (t2l & 65535) + (t1l & 65535) + (chl & 65535) + (s1l & 65535) + (el & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (chl >>> 16) + (s1l >>> 16) + (el >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (chh & 65535) + (s1h & 65535) + (eh & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (chh >>> 16) + (s1h >>> 16) + (eh >>> 16) + (c3 >>> 16);
          t1h = c4 << 16 | c3 & 65535;
          t1l = c2 << 16 | c1 & 65535;
          c1 = (majl & 65535) + (s0l & 65535);
          c2 = (majl >>> 16) + (s0l >>> 16) + (c1 >>> 16);
          c3 = (majh & 65535) + (s0h & 65535) + (c2 >>> 16);
          c4 = (majh >>> 16) + (s0h >>> 16) + (c3 >>> 16);
          t2h = c4 << 16 | c3 & 65535;
          t2l = c2 << 16 | c1 & 65535;
          c1 = (al & 65535) + (t1l & 65535);
          c2 = (al >>> 16) + (t1l >>> 16) + (c1 >>> 16);
          c3 = (ah & 65535) + (t1h & 65535) + (c2 >>> 16);
          c4 = (ah >>> 16) + (t1h >>> 16) + (c3 >>> 16);
          eh = c4 << 16 | c3 & 65535;
          el = c2 << 16 | c1 & 65535;
          c1 = (t2l & 65535) + (t1l & 65535);
          c2 = (t2l >>> 16) + (t1l >>> 16) + (c1 >>> 16);
          c3 = (t2h & 65535) + (t1h & 65535) + (c2 >>> 16);
          c4 = (t2h >>> 16) + (t1h >>> 16) + (c3 >>> 16);
          ah = c4 << 16 | c3 & 65535;
          al = c2 << 16 | c1 & 65535;
        }
        c1 = (h0l & 65535) + (al & 65535);
        c2 = (h0l >>> 16) + (al >>> 16) + (c1 >>> 16);
        c3 = (h0h & 65535) + (ah & 65535) + (c2 >>> 16);
        c4 = (h0h >>> 16) + (ah >>> 16) + (c3 >>> 16);
        this.h0h = c4 << 16 | c3 & 65535;
        this.h0l = c2 << 16 | c1 & 65535;
        c1 = (h1l & 65535) + (bl & 65535);
        c2 = (h1l >>> 16) + (bl >>> 16) + (c1 >>> 16);
        c3 = (h1h & 65535) + (bh & 65535) + (c2 >>> 16);
        c4 = (h1h >>> 16) + (bh >>> 16) + (c3 >>> 16);
        this.h1h = c4 << 16 | c3 & 65535;
        this.h1l = c2 << 16 | c1 & 65535;
        c1 = (h2l & 65535) + (cl & 65535);
        c2 = (h2l >>> 16) + (cl >>> 16) + (c1 >>> 16);
        c3 = (h2h & 65535) + (ch & 65535) + (c2 >>> 16);
        c4 = (h2h >>> 16) + (ch >>> 16) + (c3 >>> 16);
        this.h2h = c4 << 16 | c3 & 65535;
        this.h2l = c2 << 16 | c1 & 65535;
        c1 = (h3l & 65535) + (dl & 65535);
        c2 = (h3l >>> 16) + (dl >>> 16) + (c1 >>> 16);
        c3 = (h3h & 65535) + (dh & 65535) + (c2 >>> 16);
        c4 = (h3h >>> 16) + (dh >>> 16) + (c3 >>> 16);
        this.h3h = c4 << 16 | c3 & 65535;
        this.h3l = c2 << 16 | c1 & 65535;
        c1 = (h4l & 65535) + (el & 65535);
        c2 = (h4l >>> 16) + (el >>> 16) + (c1 >>> 16);
        c3 = (h4h & 65535) + (eh & 65535) + (c2 >>> 16);
        c4 = (h4h >>> 16) + (eh >>> 16) + (c3 >>> 16);
        this.h4h = c4 << 16 | c3 & 65535;
        this.h4l = c2 << 16 | c1 & 65535;
        c1 = (h5l & 65535) + (fl & 65535);
        c2 = (h5l >>> 16) + (fl >>> 16) + (c1 >>> 16);
        c3 = (h5h & 65535) + (fh & 65535) + (c2 >>> 16);
        c4 = (h5h >>> 16) + (fh >>> 16) + (c3 >>> 16);
        this.h5h = c4 << 16 | c3 & 65535;
        this.h5l = c2 << 16 | c1 & 65535;
        c1 = (h6l & 65535) + (gl & 65535);
        c2 = (h6l >>> 16) + (gl >>> 16) + (c1 >>> 16);
        c3 = (h6h & 65535) + (gh & 65535) + (c2 >>> 16);
        c4 = (h6h >>> 16) + (gh >>> 16) + (c3 >>> 16);
        this.h6h = c4 << 16 | c3 & 65535;
        this.h6l = c2 << 16 | c1 & 65535;
        c1 = (h7l & 65535) + (hl & 65535);
        c2 = (h7l >>> 16) + (hl >>> 16) + (c1 >>> 16);
        c3 = (h7h & 65535) + (hh & 65535) + (c2 >>> 16);
        c4 = (h7h >>> 16) + (hh >>> 16) + (c3 >>> 16);
        this.h7h = c4 << 16 | c3 & 65535;
        this.h7l = c2 << 16 | c1 & 65535;
      };
      Sha512.prototype.hex = function() {
        this.finalize();
        var h0h = this.h0h, h0l = this.h0l, h1h = this.h1h, h1l = this.h1l, h2h = this.h2h, h2l = this.h2l, h3h = this.h3h, h3l = this.h3l, h4h = this.h4h, h4l = this.h4l, h5h = this.h5h, h5l = this.h5l, h6h = this.h6h, h6l = this.h6l, h7h = this.h7h, h7l = this.h7l, bits = this.bits;
        var hex = HEX_CHARS[h0h >> 28 & 15] + HEX_CHARS[h0h >> 24 & 15] + HEX_CHARS[h0h >> 20 & 15] + HEX_CHARS[h0h >> 16 & 15] + HEX_CHARS[h0h >> 12 & 15] + HEX_CHARS[h0h >> 8 & 15] + HEX_CHARS[h0h >> 4 & 15] + HEX_CHARS[h0h & 15] + HEX_CHARS[h0l >> 28 & 15] + HEX_CHARS[h0l >> 24 & 15] + HEX_CHARS[h0l >> 20 & 15] + HEX_CHARS[h0l >> 16 & 15] + HEX_CHARS[h0l >> 12 & 15] + HEX_CHARS[h0l >> 8 & 15] + HEX_CHARS[h0l >> 4 & 15] + HEX_CHARS[h0l & 15] + HEX_CHARS[h1h >> 28 & 15] + HEX_CHARS[h1h >> 24 & 15] + HEX_CHARS[h1h >> 20 & 15] + HEX_CHARS[h1h >> 16 & 15] + HEX_CHARS[h1h >> 12 & 15] + HEX_CHARS[h1h >> 8 & 15] + HEX_CHARS[h1h >> 4 & 15] + HEX_CHARS[h1h & 15] + HEX_CHARS[h1l >> 28 & 15] + HEX_CHARS[h1l >> 24 & 15] + HEX_CHARS[h1l >> 20 & 15] + HEX_CHARS[h1l >> 16 & 15] + HEX_CHARS[h1l >> 12 & 15] + HEX_CHARS[h1l >> 8 & 15] + HEX_CHARS[h1l >> 4 & 15] + HEX_CHARS[h1l & 15] + HEX_CHARS[h2h >> 28 & 15] + HEX_CHARS[h2h >> 24 & 15] + HEX_CHARS[h2h >> 20 & 15] + HEX_CHARS[h2h >> 16 & 15] + HEX_CHARS[h2h >> 12 & 15] + HEX_CHARS[h2h >> 8 & 15] + HEX_CHARS[h2h >> 4 & 15] + HEX_CHARS[h2h & 15] + HEX_CHARS[h2l >> 28 & 15] + HEX_CHARS[h2l >> 24 & 15] + HEX_CHARS[h2l >> 20 & 15] + HEX_CHARS[h2l >> 16 & 15] + HEX_CHARS[h2l >> 12 & 15] + HEX_CHARS[h2l >> 8 & 15] + HEX_CHARS[h2l >> 4 & 15] + HEX_CHARS[h2l & 15] + HEX_CHARS[h3h >> 28 & 15] + HEX_CHARS[h3h >> 24 & 15] + HEX_CHARS[h3h >> 20 & 15] + HEX_CHARS[h3h >> 16 & 15] + HEX_CHARS[h3h >> 12 & 15] + HEX_CHARS[h3h >> 8 & 15] + HEX_CHARS[h3h >> 4 & 15] + HEX_CHARS[h3h & 15];
        if (bits >= 256) {
          hex += HEX_CHARS[h3l >> 28 & 15] + HEX_CHARS[h3l >> 24 & 15] + HEX_CHARS[h3l >> 20 & 15] + HEX_CHARS[h3l >> 16 & 15] + HEX_CHARS[h3l >> 12 & 15] + HEX_CHARS[h3l >> 8 & 15] + HEX_CHARS[h3l >> 4 & 15] + HEX_CHARS[h3l & 15];
        }
        if (bits >= 384) {
          hex += HEX_CHARS[h4h >> 28 & 15] + HEX_CHARS[h4h >> 24 & 15] + HEX_CHARS[h4h >> 20 & 15] + HEX_CHARS[h4h >> 16 & 15] + HEX_CHARS[h4h >> 12 & 15] + HEX_CHARS[h4h >> 8 & 15] + HEX_CHARS[h4h >> 4 & 15] + HEX_CHARS[h4h & 15] + HEX_CHARS[h4l >> 28 & 15] + HEX_CHARS[h4l >> 24 & 15] + HEX_CHARS[h4l >> 20 & 15] + HEX_CHARS[h4l >> 16 & 15] + HEX_CHARS[h4l >> 12 & 15] + HEX_CHARS[h4l >> 8 & 15] + HEX_CHARS[h4l >> 4 & 15] + HEX_CHARS[h4l & 15] + HEX_CHARS[h5h >> 28 & 15] + HEX_CHARS[h5h >> 24 & 15] + HEX_CHARS[h5h >> 20 & 15] + HEX_CHARS[h5h >> 16 & 15] + HEX_CHARS[h5h >> 12 & 15] + HEX_CHARS[h5h >> 8 & 15] + HEX_CHARS[h5h >> 4 & 15] + HEX_CHARS[h5h & 15] + HEX_CHARS[h5l >> 28 & 15] + HEX_CHARS[h5l >> 24 & 15] + HEX_CHARS[h5l >> 20 & 15] + HEX_CHARS[h5l >> 16 & 15] + HEX_CHARS[h5l >> 12 & 15] + HEX_CHARS[h5l >> 8 & 15] + HEX_CHARS[h5l >> 4 & 15] + HEX_CHARS[h5l & 15];
        }
        if (bits == 512) {
          hex += HEX_CHARS[h6h >> 28 & 15] + HEX_CHARS[h6h >> 24 & 15] + HEX_CHARS[h6h >> 20 & 15] + HEX_CHARS[h6h >> 16 & 15] + HEX_CHARS[h6h >> 12 & 15] + HEX_CHARS[h6h >> 8 & 15] + HEX_CHARS[h6h >> 4 & 15] + HEX_CHARS[h6h & 15] + HEX_CHARS[h6l >> 28 & 15] + HEX_CHARS[h6l >> 24 & 15] + HEX_CHARS[h6l >> 20 & 15] + HEX_CHARS[h6l >> 16 & 15] + HEX_CHARS[h6l >> 12 & 15] + HEX_CHARS[h6l >> 8 & 15] + HEX_CHARS[h6l >> 4 & 15] + HEX_CHARS[h6l & 15] + HEX_CHARS[h7h >> 28 & 15] + HEX_CHARS[h7h >> 24 & 15] + HEX_CHARS[h7h >> 20 & 15] + HEX_CHARS[h7h >> 16 & 15] + HEX_CHARS[h7h >> 12 & 15] + HEX_CHARS[h7h >> 8 & 15] + HEX_CHARS[h7h >> 4 & 15] + HEX_CHARS[h7h & 15] + HEX_CHARS[h7l >> 28 & 15] + HEX_CHARS[h7l >> 24 & 15] + HEX_CHARS[h7l >> 20 & 15] + HEX_CHARS[h7l >> 16 & 15] + HEX_CHARS[h7l >> 12 & 15] + HEX_CHARS[h7l >> 8 & 15] + HEX_CHARS[h7l >> 4 & 15] + HEX_CHARS[h7l & 15];
        }
        return hex;
      };
      Sha512.prototype.toString = Sha512.prototype.hex;
      Sha512.prototype.digest = function() {
        this.finalize();
        var h0h = this.h0h, h0l = this.h0l, h1h = this.h1h, h1l = this.h1l, h2h = this.h2h, h2l = this.h2l, h3h = this.h3h, h3l = this.h3l, h4h = this.h4h, h4l = this.h4l, h5h = this.h5h, h5l = this.h5l, h6h = this.h6h, h6l = this.h6l, h7h = this.h7h, h7l = this.h7l, bits = this.bits;
        var arr = [
          h0h >> 24 & 255,
          h0h >> 16 & 255,
          h0h >> 8 & 255,
          h0h & 255,
          h0l >> 24 & 255,
          h0l >> 16 & 255,
          h0l >> 8 & 255,
          h0l & 255,
          h1h >> 24 & 255,
          h1h >> 16 & 255,
          h1h >> 8 & 255,
          h1h & 255,
          h1l >> 24 & 255,
          h1l >> 16 & 255,
          h1l >> 8 & 255,
          h1l & 255,
          h2h >> 24 & 255,
          h2h >> 16 & 255,
          h2h >> 8 & 255,
          h2h & 255,
          h2l >> 24 & 255,
          h2l >> 16 & 255,
          h2l >> 8 & 255,
          h2l & 255,
          h3h >> 24 & 255,
          h3h >> 16 & 255,
          h3h >> 8 & 255,
          h3h & 255
        ];
        if (bits >= 256) {
          arr.push(h3l >> 24 & 255, h3l >> 16 & 255, h3l >> 8 & 255, h3l & 255);
        }
        if (bits >= 384) {
          arr.push(
            h4h >> 24 & 255,
            h4h >> 16 & 255,
            h4h >> 8 & 255,
            h4h & 255,
            h4l >> 24 & 255,
            h4l >> 16 & 255,
            h4l >> 8 & 255,
            h4l & 255,
            h5h >> 24 & 255,
            h5h >> 16 & 255,
            h5h >> 8 & 255,
            h5h & 255,
            h5l >> 24 & 255,
            h5l >> 16 & 255,
            h5l >> 8 & 255,
            h5l & 255
          );
        }
        if (bits == 512) {
          arr.push(
            h6h >> 24 & 255,
            h6h >> 16 & 255,
            h6h >> 8 & 255,
            h6h & 255,
            h6l >> 24 & 255,
            h6l >> 16 & 255,
            h6l >> 8 & 255,
            h6l & 255,
            h7h >> 24 & 255,
            h7h >> 16 & 255,
            h7h >> 8 & 255,
            h7h & 255,
            h7l >> 24 & 255,
            h7l >> 16 & 255,
            h7l >> 8 & 255,
            h7l & 255
          );
        }
        return arr;
      };
      Sha512.prototype.array = Sha512.prototype.digest;
      Sha512.prototype.arrayBuffer = function() {
        this.finalize();
        var bits = this.bits;
        var buffer = new ArrayBuffer(bits / 8);
        var dataView = new DataView(buffer);
        dataView.setUint32(0, this.h0h);
        dataView.setUint32(4, this.h0l);
        dataView.setUint32(8, this.h1h);
        dataView.setUint32(12, this.h1l);
        dataView.setUint32(16, this.h2h);
        dataView.setUint32(20, this.h2l);
        dataView.setUint32(24, this.h3h);
        if (bits >= 256) {
          dataView.setUint32(28, this.h3l);
        }
        if (bits >= 384) {
          dataView.setUint32(32, this.h4h);
          dataView.setUint32(36, this.h4l);
          dataView.setUint32(40, this.h5h);
          dataView.setUint32(44, this.h5l);
        }
        if (bits == 512) {
          dataView.setUint32(48, this.h6h);
          dataView.setUint32(52, this.h6l);
          dataView.setUint32(56, this.h7h);
          dataView.setUint32(60, this.h7l);
        }
        return buffer;
      };
      Sha512.prototype.clone = function() {
        var hash = new Sha512(this.bits, false);
        this.copyTo(hash);
        return hash;
      };
      Sha512.prototype.copyTo = function(hash) {
        var i2 = 0, attrs = [
          "h0h",
          "h0l",
          "h1h",
          "h1l",
          "h2h",
          "h2l",
          "h3h",
          "h3l",
          "h4h",
          "h4l",
          "h5h",
          "h5l",
          "h6h",
          "h6l",
          "h7h",
          "h7l",
          "start",
          "bytes",
          "hBytes",
          "finalized",
          "hashed",
          "lastByteIndex"
        ];
        for (i2 = 0; i2 < attrs.length; ++i2) {
          hash[attrs[i2]] = this[attrs[i2]];
        }
        for (i2 = 0; i2 < this.blocks.length; ++i2) {
          hash.blocks[i2] = this.blocks[i2];
        }
      };
      function HmacSha512(key, bits, sharedMemory) {
        var notString, type = typeof key;
        if (type !== "string") {
          if (type === "object") {
            if (key === null) {
              throw new Error(INPUT_ERROR);
            } else if (ARRAY_BUFFER && key.constructor === ArrayBuffer) {
              key = new Uint8Array(key);
            } else if (!Array.isArray(key)) {
              if (!ARRAY_BUFFER || !ArrayBuffer.isView(key)) {
                throw new Error(INPUT_ERROR);
              }
            }
          } else {
            throw new Error(INPUT_ERROR);
          }
          notString = true;
        }
        var length = key.length;
        if (!notString) {
          var bytes = [], length = key.length, index = 0, code;
          for (var i2 = 0; i2 < length; ++i2) {
            code = key.charCodeAt(i2);
            if (code < 128) {
              bytes[index++] = code;
            } else if (code < 2048) {
              bytes[index++] = 192 | code >> 6;
              bytes[index++] = 128 | code & 63;
            } else if (code < 55296 || code >= 57344) {
              bytes[index++] = 224 | code >> 12;
              bytes[index++] = 128 | code >> 6 & 63;
              bytes[index++] = 128 | code & 63;
            } else {
              code = 65536 + ((code & 1023) << 10 | key.charCodeAt(++i2) & 1023);
              bytes[index++] = 240 | code >> 18;
              bytes[index++] = 128 | code >> 12 & 63;
              bytes[index++] = 128 | code >> 6 & 63;
              bytes[index++] = 128 | code & 63;
            }
          }
          key = bytes;
        }
        if (key.length > 128) {
          key = new Sha512(bits, true).update(key).array();
        }
        var oKeyPad = [], iKeyPad = [];
        for (var i2 = 0; i2 < 128; ++i2) {
          var b2 = key[i2] || 0;
          oKeyPad[i2] = 92 ^ b2;
          iKeyPad[i2] = 54 ^ b2;
        }
        Sha512.call(this, bits, sharedMemory);
        this.update(iKeyPad);
        this.oKeyPad = oKeyPad;
        this.inner = true;
        this.sharedMemory = sharedMemory;
      }
      HmacSha512.prototype = new Sha512();
      HmacSha512.prototype.finalize = function() {
        Sha512.prototype.finalize.call(this);
        if (this.inner) {
          this.inner = false;
          var innerHash = this.array();
          Sha512.call(this, this.bits, this.sharedMemory);
          this.update(this.oKeyPad);
          this.update(innerHash);
          Sha512.prototype.finalize.call(this);
        }
      };
      HmacSha512.prototype.clone = function() {
        var hash = new HmacSha512([], this.bits, false);
        this.copyTo(hash);
        hash.inner = this.inner;
        for (var i2 = 0; i2 < this.oKeyPad.length; ++i2) {
          hash.oKeyPad[i2] = this.oKeyPad[i2];
        }
        return hash;
      };
      var exports2 = createMethod(512);
      exports2.sha512 = exports2;
      exports2.sha384 = createMethod(384);
      exports2.sha512_256 = createMethod(256);
      exports2.sha512_224 = createMethod(224);
      exports2.sha512.hmac = createHmacMethod(512);
      exports2.sha384.hmac = createHmacMethod(384);
      exports2.sha512_256.hmac = createHmacMethod(256);
      exports2.sha512_224.hmac = createHmacMethod(224);
      if (COMMON_JS) {
        module.exports = exports2;
      } else {
        root.sha512 = exports2.sha512;
        root.sha384 = exports2.sha384;
        root.sha512_256 = exports2.sha512_256;
        root.sha512_224 = exports2.sha512_224;
        if (AMD) {
          define(function() {
            return exports2;
          });
        }
      }
    })();
  }
});

// node_modules/bignumber.js/bignumber.js
var require_bignumber = __commonJS({
  "node_modules/bignumber.js/bignumber.js"(exports, module) {
    (function(globalObject) {
      "use strict";
      var BigNumber, isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
      function clone(configObject) {
        var div, convertBase, parseNumeric, P2 = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
          prefix: "",
          groupSize: 3,
          secondaryGroupSize: 0,
          groupSeparator: ",",
          decimalSeparator: ".",
          fractionGroupSize: 0,
          fractionGroupSeparator: " ",
          // non-breaking space
          suffix: ""
        }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
        function BigNumber2(v2, b2) {
          var alphabet, c2, caseChanged, e2, i2, isNum, len, str, x2 = this;
          if (!(x2 instanceof BigNumber2)) return new BigNumber2(v2, b2);
          if (b2 == null) {
            if (v2 && v2._isBigNumber === true) {
              x2.s = v2.s;
              if (!v2.c || v2.e > MAX_EXP) {
                x2.c = x2.e = null;
              } else if (v2.e < MIN_EXP) {
                x2.c = [x2.e = 0];
              } else {
                x2.e = v2.e;
                x2.c = v2.c.slice();
              }
              return;
            }
            if ((isNum = typeof v2 == "number") && v2 * 0 == 0) {
              x2.s = 1 / v2 < 0 ? (v2 = -v2, -1) : 1;
              if (v2 === ~~v2) {
                for (e2 = 0, i2 = v2; i2 >= 10; i2 /= 10, e2++) ;
                if (e2 > MAX_EXP) {
                  x2.c = x2.e = null;
                } else {
                  x2.e = e2;
                  x2.c = [v2];
                }
                return;
              }
              str = String(v2);
            } else {
              if (!isNumeric.test(str = String(v2))) return parseNumeric(x2, str, isNum);
              x2.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
            }
            if ((e2 = str.indexOf(".")) > -1) str = str.replace(".", "");
            if ((i2 = str.search(/e/i)) > 0) {
              if (e2 < 0) e2 = i2;
              e2 += +str.slice(i2 + 1);
              str = str.substring(0, i2);
            } else if (e2 < 0) {
              e2 = str.length;
            }
          } else {
            intCheck(b2, 2, ALPHABET.length, "Base");
            if (b2 == 10 && alphabetHasNormalDecimalDigits) {
              x2 = new BigNumber2(v2);
              return round(x2, DECIMAL_PLACES + x2.e + 1, ROUNDING_MODE);
            }
            str = String(v2);
            if (isNum = typeof v2 == "number") {
              if (v2 * 0 != 0) return parseNumeric(x2, str, isNum, b2);
              x2.s = 1 / v2 < 0 ? (str = str.slice(1), -1) : 1;
              if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
                throw Error(tooManyDigits + v2);
              }
            } else {
              x2.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
            }
            alphabet = ALPHABET.slice(0, b2);
            e2 = i2 = 0;
            for (len = str.length; i2 < len; i2++) {
              if (alphabet.indexOf(c2 = str.charAt(i2)) < 0) {
                if (c2 == ".") {
                  if (i2 > e2) {
                    e2 = len;
                    continue;
                  }
                } else if (!caseChanged) {
                  if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                    caseChanged = true;
                    i2 = -1;
                    e2 = 0;
                    continue;
                  }
                }
                return parseNumeric(x2, String(v2), isNum, b2);
              }
            }
            isNum = false;
            str = convertBase(str, b2, 10, x2.s);
            if ((e2 = str.indexOf(".")) > -1) str = str.replace(".", "");
            else e2 = str.length;
          }
          for (i2 = 0; str.charCodeAt(i2) === 48; i2++) ;
          for (len = str.length; str.charCodeAt(--len) === 48; ) ;
          if (str = str.slice(i2, ++len)) {
            len -= i2;
            if (isNum && BigNumber2.DEBUG && len > 15 && (v2 > MAX_SAFE_INTEGER || v2 !== mathfloor(v2))) {
              throw Error(tooManyDigits + x2.s * v2);
            }
            if ((e2 = e2 - i2 - 1) > MAX_EXP) {
              x2.c = x2.e = null;
            } else if (e2 < MIN_EXP) {
              x2.c = [x2.e = 0];
            } else {
              x2.e = e2;
              x2.c = [];
              i2 = (e2 + 1) % LOG_BASE;
              if (e2 < 0) i2 += LOG_BASE;
              if (i2 < len) {
                if (i2) x2.c.push(+str.slice(0, i2));
                for (len -= LOG_BASE; i2 < len; ) {
                  x2.c.push(+str.slice(i2, i2 += LOG_BASE));
                }
                i2 = LOG_BASE - (str = str.slice(i2)).length;
              } else {
                i2 -= len;
              }
              for (; i2--; str += "0") ;
              x2.c.push(+str);
            }
          } else {
            x2.c = [x2.e = 0];
          }
        }
        BigNumber2.clone = clone;
        BigNumber2.ROUND_UP = 0;
        BigNumber2.ROUND_DOWN = 1;
        BigNumber2.ROUND_CEIL = 2;
        BigNumber2.ROUND_FLOOR = 3;
        BigNumber2.ROUND_HALF_UP = 4;
        BigNumber2.ROUND_HALF_DOWN = 5;
        BigNumber2.ROUND_HALF_EVEN = 6;
        BigNumber2.ROUND_HALF_CEIL = 7;
        BigNumber2.ROUND_HALF_FLOOR = 8;
        BigNumber2.EUCLID = 9;
        BigNumber2.config = BigNumber2.set = function(obj) {
          var p2, v2;
          if (obj != null) {
            if (typeof obj == "object") {
              if (obj.hasOwnProperty(p2 = "DECIMAL_PLACES")) {
                v2 = obj[p2];
                intCheck(v2, 0, MAX, p2);
                DECIMAL_PLACES = v2;
              }
              if (obj.hasOwnProperty(p2 = "ROUNDING_MODE")) {
                v2 = obj[p2];
                intCheck(v2, 0, 8, p2);
                ROUNDING_MODE = v2;
              }
              if (obj.hasOwnProperty(p2 = "EXPONENTIAL_AT")) {
                v2 = obj[p2];
                if (v2 && v2.pop) {
                  intCheck(v2[0], -MAX, 0, p2);
                  intCheck(v2[1], 0, MAX, p2);
                  TO_EXP_NEG = v2[0];
                  TO_EXP_POS = v2[1];
                } else {
                  intCheck(v2, -MAX, MAX, p2);
                  TO_EXP_NEG = -(TO_EXP_POS = v2 < 0 ? -v2 : v2);
                }
              }
              if (obj.hasOwnProperty(p2 = "RANGE")) {
                v2 = obj[p2];
                if (v2 && v2.pop) {
                  intCheck(v2[0], -MAX, -1, p2);
                  intCheck(v2[1], 1, MAX, p2);
                  MIN_EXP = v2[0];
                  MAX_EXP = v2[1];
                } else {
                  intCheck(v2, -MAX, MAX, p2);
                  if (v2) {
                    MIN_EXP = -(MAX_EXP = v2 < 0 ? -v2 : v2);
                  } else {
                    throw Error(bignumberError + p2 + " cannot be zero: " + v2);
                  }
                }
              }
              if (obj.hasOwnProperty(p2 = "CRYPTO")) {
                v2 = obj[p2];
                if (v2 === !!v2) {
                  if (v2) {
                    if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                      CRYPTO = v2;
                    } else {
                      CRYPTO = !v2;
                      throw Error(bignumberError + "crypto unavailable");
                    }
                  } else {
                    CRYPTO = v2;
                  }
                } else {
                  throw Error(bignumberError + p2 + " not true or false: " + v2);
                }
              }
              if (obj.hasOwnProperty(p2 = "MODULO_MODE")) {
                v2 = obj[p2];
                intCheck(v2, 0, 9, p2);
                MODULO_MODE = v2;
              }
              if (obj.hasOwnProperty(p2 = "POW_PRECISION")) {
                v2 = obj[p2];
                intCheck(v2, 0, MAX, p2);
                POW_PRECISION = v2;
              }
              if (obj.hasOwnProperty(p2 = "FORMAT")) {
                v2 = obj[p2];
                if (typeof v2 == "object") FORMAT = v2;
                else throw Error(bignumberError + p2 + " not an object: " + v2);
              }
              if (obj.hasOwnProperty(p2 = "ALPHABET")) {
                v2 = obj[p2];
                if (typeof v2 == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v2)) {
                  alphabetHasNormalDecimalDigits = v2.slice(0, 10) == "0123456789";
                  ALPHABET = v2;
                } else {
                  throw Error(bignumberError + p2 + " invalid: " + v2);
                }
              }
            } else {
              throw Error(bignumberError + "Object expected: " + obj);
            }
          }
          return {
            DECIMAL_PLACES,
            ROUNDING_MODE,
            EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
            RANGE: [MIN_EXP, MAX_EXP],
            CRYPTO,
            MODULO_MODE,
            POW_PRECISION,
            FORMAT,
            ALPHABET
          };
        };
        BigNumber2.isBigNumber = function(v2) {
          if (!v2 || v2._isBigNumber !== true) return false;
          if (!BigNumber2.DEBUG) return true;
          var i2, n2, c2 = v2.c, e2 = v2.e, s2 = v2.s;
          out: if ({}.toString.call(c2) == "[object Array]") {
            if ((s2 === 1 || s2 === -1) && e2 >= -MAX && e2 <= MAX && e2 === mathfloor(e2)) {
              if (c2[0] === 0) {
                if (e2 === 0 && c2.length === 1) return true;
                break out;
              }
              i2 = (e2 + 1) % LOG_BASE;
              if (i2 < 1) i2 += LOG_BASE;
              if (String(c2[0]).length == i2) {
                for (i2 = 0; i2 < c2.length; i2++) {
                  n2 = c2[i2];
                  if (n2 < 0 || n2 >= BASE || n2 !== mathfloor(n2)) break out;
                }
                if (n2 !== 0) return true;
              }
            }
          } else if (c2 === null && e2 === null && (s2 === null || s2 === 1 || s2 === -1)) {
            return true;
          }
          throw Error(bignumberError + "Invalid BigNumber: " + v2);
        };
        BigNumber2.maximum = BigNumber2.max = function() {
          return maxOrMin(arguments, -1);
        };
        BigNumber2.minimum = BigNumber2.min = function() {
          return maxOrMin(arguments, 1);
        };
        BigNumber2.random = (function() {
          var pow2_53 = 9007199254740992;
          var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
            return mathfloor(Math.random() * pow2_53);
          } : function() {
            return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
          };
          return function(dp) {
            var a2, b2, e2, k2, v2, i2 = 0, c2 = [], rand = new BigNumber2(ONE);
            if (dp == null) dp = DECIMAL_PLACES;
            else intCheck(dp, 0, MAX);
            k2 = mathceil(dp / LOG_BASE);
            if (CRYPTO) {
              if (crypto.getRandomValues) {
                a2 = crypto.getRandomValues(new Uint32Array(k2 *= 2));
                for (; i2 < k2; ) {
                  v2 = a2[i2] * 131072 + (a2[i2 + 1] >>> 11);
                  if (v2 >= 9e15) {
                    b2 = crypto.getRandomValues(new Uint32Array(2));
                    a2[i2] = b2[0];
                    a2[i2 + 1] = b2[1];
                  } else {
                    c2.push(v2 % 1e14);
                    i2 += 2;
                  }
                }
                i2 = k2 / 2;
              } else if (crypto.randomBytes) {
                a2 = crypto.randomBytes(k2 *= 7);
                for (; i2 < k2; ) {
                  v2 = (a2[i2] & 31) * 281474976710656 + a2[i2 + 1] * 1099511627776 + a2[i2 + 2] * 4294967296 + a2[i2 + 3] * 16777216 + (a2[i2 + 4] << 16) + (a2[i2 + 5] << 8) + a2[i2 + 6];
                  if (v2 >= 9e15) {
                    crypto.randomBytes(7).copy(a2, i2);
                  } else {
                    c2.push(v2 % 1e14);
                    i2 += 7;
                  }
                }
                i2 = k2 / 7;
              } else {
                CRYPTO = false;
                throw Error(bignumberError + "crypto unavailable");
              }
            }
            if (!CRYPTO) {
              for (; i2 < k2; ) {
                v2 = random53bitInt();
                if (v2 < 9e15) c2[i2++] = v2 % 1e14;
              }
            }
            k2 = c2[--i2];
            dp %= LOG_BASE;
            if (k2 && dp) {
              v2 = POWS_TEN[LOG_BASE - dp];
              c2[i2] = mathfloor(k2 / v2) * v2;
            }
            for (; c2[i2] === 0; c2.pop(), i2--) ;
            if (i2 < 0) {
              c2 = [e2 = 0];
            } else {
              for (e2 = -1; c2[0] === 0; c2.splice(0, 1), e2 -= LOG_BASE) ;
              for (i2 = 1, v2 = c2[0]; v2 >= 10; v2 /= 10, i2++) ;
              if (i2 < LOG_BASE) e2 -= LOG_BASE - i2;
            }
            rand.e = e2;
            rand.c = c2;
            return rand;
          };
        })();
        BigNumber2.sum = function() {
          var i2 = 1, args = arguments, sum = new BigNumber2(args[0]);
          for (; i2 < args.length; ) sum = sum.plus(args[i2++]);
          return sum;
        };
        convertBase = /* @__PURE__ */ (function() {
          var decimal = "0123456789";
          function toBaseOut(str, baseIn, baseOut, alphabet) {
            var j2, arr = [0], arrL, i2 = 0, len = str.length;
            for (; i2 < len; ) {
              for (arrL = arr.length; arrL--; arr[arrL] *= baseIn) ;
              arr[0] += alphabet.indexOf(str.charAt(i2++));
              for (j2 = 0; j2 < arr.length; j2++) {
                if (arr[j2] > baseOut - 1) {
                  if (arr[j2 + 1] == null) arr[j2 + 1] = 0;
                  arr[j2 + 1] += arr[j2] / baseOut | 0;
                  arr[j2] %= baseOut;
                }
              }
            }
            return arr.reverse();
          }
          return function(str, baseIn, baseOut, sign2, callerIsToString) {
            var alphabet, d2, e2, k2, r3, x2, xc, y2, i2 = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
            if (i2 >= 0) {
              k2 = POW_PRECISION;
              POW_PRECISION = 0;
              str = str.replace(".", "");
              y2 = new BigNumber2(baseIn);
              x2 = y2.pow(str.length - i2);
              POW_PRECISION = k2;
              y2.c = toBaseOut(
                toFixedPoint(coeffToString(x2.c), x2.e, "0"),
                10,
                baseOut,
                decimal
              );
              y2.e = y2.c.length;
            }
            xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
            e2 = k2 = xc.length;
            for (; xc[--k2] == 0; xc.pop()) ;
            if (!xc[0]) return alphabet.charAt(0);
            if (i2 < 0) {
              --e2;
            } else {
              x2.c = xc;
              x2.e = e2;
              x2.s = sign2;
              x2 = div(x2, y2, dp, rm, baseOut);
              xc = x2.c;
              r3 = x2.r;
              e2 = x2.e;
            }
            d2 = e2 + dp + 1;
            i2 = xc[d2];
            k2 = baseOut / 2;
            r3 = r3 || d2 < 0 || xc[d2 + 1] != null;
            r3 = rm < 4 ? (i2 != null || r3) && (rm == 0 || rm == (x2.s < 0 ? 3 : 2)) : i2 > k2 || i2 == k2 && (rm == 4 || r3 || rm == 6 && xc[d2 - 1] & 1 || rm == (x2.s < 0 ? 8 : 7));
            if (d2 < 1 || !xc[0]) {
              str = r3 ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
            } else {
              xc.length = d2;
              if (r3) {
                for (--baseOut; ++xc[--d2] > baseOut; ) {
                  xc[d2] = 0;
                  if (!d2) {
                    ++e2;
                    xc = [1].concat(xc);
                  }
                }
              }
              for (k2 = xc.length; !xc[--k2]; ) ;
              for (i2 = 0, str = ""; i2 <= k2; str += alphabet.charAt(xc[i2++])) ;
              str = toFixedPoint(str, e2, alphabet.charAt(0));
            }
            return str;
          };
        })();
        div = /* @__PURE__ */ (function() {
          function multiply(x2, k2, base) {
            var m2, temp, xlo, xhi, carry = 0, i2 = x2.length, klo = k2 % SQRT_BASE, khi = k2 / SQRT_BASE | 0;
            for (x2 = x2.slice(); i2--; ) {
              xlo = x2[i2] % SQRT_BASE;
              xhi = x2[i2] / SQRT_BASE | 0;
              m2 = khi * xlo + xhi * klo;
              temp = klo * xlo + m2 % SQRT_BASE * SQRT_BASE + carry;
              carry = (temp / base | 0) + (m2 / SQRT_BASE | 0) + khi * xhi;
              x2[i2] = temp % base;
            }
            if (carry) x2 = [carry].concat(x2);
            return x2;
          }
          function compare2(a2, b2, aL, bL) {
            var i2, cmp;
            if (aL != bL) {
              cmp = aL > bL ? 1 : -1;
            } else {
              for (i2 = cmp = 0; i2 < aL; i2++) {
                if (a2[i2] != b2[i2]) {
                  cmp = a2[i2] > b2[i2] ? 1 : -1;
                  break;
                }
              }
            }
            return cmp;
          }
          function subtract(a2, b2, aL, base) {
            var i2 = 0;
            for (; aL--; ) {
              a2[aL] -= i2;
              i2 = a2[aL] < b2[aL] ? 1 : 0;
              a2[aL] = i2 * base + a2[aL] - b2[aL];
            }
            for (; !a2[0] && a2.length > 1; a2.splice(0, 1)) ;
          }
          return function(x2, y2, dp, rm, base) {
            var cmp, e2, i2, more, n2, prod, prodL, q2, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s2 = x2.s == y2.s ? 1 : -1, xc = x2.c, yc = y2.c;
            if (!xc || !xc[0] || !yc || !yc[0]) {
              return new BigNumber2(
                // Return NaN if either NaN, or both Infinity or 0.
                !x2.s || !y2.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : (
                  // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
                  xc && xc[0] == 0 || !yc ? s2 * 0 : s2 / 0
                )
              );
            }
            q2 = new BigNumber2(s2);
            qc = q2.c = [];
            e2 = x2.e - y2.e;
            s2 = dp + e2 + 1;
            if (!base) {
              base = BASE;
              e2 = bitFloor(x2.e / LOG_BASE) - bitFloor(y2.e / LOG_BASE);
              s2 = s2 / LOG_BASE | 0;
            }
            for (i2 = 0; yc[i2] == (xc[i2] || 0); i2++) ;
            if (yc[i2] > (xc[i2] || 0)) e2--;
            if (s2 < 0) {
              qc.push(1);
              more = true;
            } else {
              xL = xc.length;
              yL = yc.length;
              i2 = 0;
              s2 += 2;
              n2 = mathfloor(base / (yc[0] + 1));
              if (n2 > 1) {
                yc = multiply(yc, n2, base);
                xc = multiply(xc, n2, base);
                yL = yc.length;
                xL = xc.length;
              }
              xi = yL;
              rem = xc.slice(0, yL);
              remL = rem.length;
              for (; remL < yL; rem[remL++] = 0) ;
              yz = yc.slice();
              yz = [0].concat(yz);
              yc0 = yc[0];
              if (yc[1] >= base / 2) yc0++;
              do {
                n2 = 0;
                cmp = compare2(yc, rem, yL, remL);
                if (cmp < 0) {
                  rem0 = rem[0];
                  if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);
                  n2 = mathfloor(rem0 / yc0);
                  if (n2 > 1) {
                    if (n2 >= base) n2 = base - 1;
                    prod = multiply(yc, n2, base);
                    prodL = prod.length;
                    remL = rem.length;
                    while (compare2(prod, rem, prodL, remL) == 1) {
                      n2--;
                      subtract(prod, yL < prodL ? yz : yc, prodL, base);
                      prodL = prod.length;
                      cmp = 1;
                    }
                  } else {
                    if (n2 == 0) {
                      cmp = n2 = 1;
                    }
                    prod = yc.slice();
                    prodL = prod.length;
                  }
                  if (prodL < remL) prod = [0].concat(prod);
                  subtract(rem, prod, remL, base);
                  remL = rem.length;
                  if (cmp == -1) {
                    while (compare2(yc, rem, yL, remL) < 1) {
                      n2++;
                      subtract(rem, yL < remL ? yz : yc, remL, base);
                      remL = rem.length;
                    }
                  }
                } else if (cmp === 0) {
                  n2++;
                  rem = [0];
                }
                qc[i2++] = n2;
                if (rem[0]) {
                  rem[remL++] = xc[xi] || 0;
                } else {
                  rem = [xc[xi]];
                  remL = 1;
                }
              } while ((xi++ < xL || rem[0] != null) && s2--);
              more = rem[0] != null;
              if (!qc[0]) qc.splice(0, 1);
            }
            if (base == BASE) {
              for (i2 = 1, s2 = qc[0]; s2 >= 10; s2 /= 10, i2++) ;
              round(q2, dp + (q2.e = i2 + e2 * LOG_BASE - 1) + 1, rm, more);
            } else {
              q2.e = e2;
              q2.r = +more;
            }
            return q2;
          };
        })();
        function format(n2, i2, rm, id) {
          var c0, e2, ne, len, str;
          if (rm == null) rm = ROUNDING_MODE;
          else intCheck(rm, 0, 8);
          if (!n2.c) return n2.toString();
          c0 = n2.c[0];
          ne = n2.e;
          if (i2 == null) {
            str = coeffToString(n2.c);
            str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
          } else {
            n2 = round(new BigNumber2(n2), i2, rm);
            e2 = n2.e;
            str = coeffToString(n2.c);
            len = str.length;
            if (id == 1 || id == 2 && (i2 <= e2 || e2 <= TO_EXP_NEG)) {
              for (; len < i2; str += "0", len++) ;
              str = toExponential(str, e2);
            } else {
              i2 -= ne + (id === 2 && e2 > ne);
              str = toFixedPoint(str, e2, "0");
              if (e2 + 1 > len) {
                if (--i2 > 0) for (str += "."; i2--; str += "0") ;
              } else {
                i2 += e2 - len;
                if (i2 > 0) {
                  if (e2 + 1 == len) str += ".";
                  for (; i2--; str += "0") ;
                }
              }
            }
          }
          return n2.s < 0 && c0 ? "-" + str : str;
        }
        function maxOrMin(args, n2) {
          var k2, y2, i2 = 1, x2 = new BigNumber2(args[0]);
          for (; i2 < args.length; i2++) {
            y2 = new BigNumber2(args[i2]);
            if (!y2.s || (k2 = compare(x2, y2)) === n2 || k2 === 0 && x2.s === n2) {
              x2 = y2;
            }
          }
          return x2;
        }
        function normalise(n2, c2, e2) {
          var i2 = 1, j2 = c2.length;
          for (; !c2[--j2]; c2.pop()) ;
          for (j2 = c2[0]; j2 >= 10; j2 /= 10, i2++) ;
          if ((e2 = i2 + e2 * LOG_BASE - 1) > MAX_EXP) {
            n2.c = n2.e = null;
          } else if (e2 < MIN_EXP) {
            n2.c = [n2.e = 0];
          } else {
            n2.e = e2;
            n2.c = c2;
          }
          return n2;
        }
        parseNumeric = /* @__PURE__ */ (function() {
          var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
          return function(x2, str, isNum, b2) {
            var base, s2 = isNum ? str : str.replace(whitespaceOrPlus, "");
            if (isInfinityOrNaN.test(s2)) {
              x2.s = isNaN(s2) ? null : s2 < 0 ? -1 : 1;
            } else {
              if (!isNum) {
                s2 = s2.replace(basePrefix, function(m2, p1, p2) {
                  base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
                  return !b2 || b2 == base ? p1 : m2;
                });
                if (b2) {
                  base = b2;
                  s2 = s2.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
                }
                if (str != s2) return new BigNumber2(s2, base);
              }
              if (BigNumber2.DEBUG) {
                throw Error(bignumberError + "Not a" + (b2 ? " base " + b2 : "") + " number: " + str);
              }
              x2.s = null;
            }
            x2.c = x2.e = null;
          };
        })();
        function round(x2, sd, rm, r3) {
          var d2, i2, j2, k2, n2, ni, rd, xc = x2.c, pows10 = POWS_TEN;
          if (xc) {
            out: {
              for (d2 = 1, k2 = xc[0]; k2 >= 10; k2 /= 10, d2++) ;
              i2 = sd - d2;
              if (i2 < 0) {
                i2 += LOG_BASE;
                j2 = sd;
                n2 = xc[ni = 0];
                rd = mathfloor(n2 / pows10[d2 - j2 - 1] % 10);
              } else {
                ni = mathceil((i2 + 1) / LOG_BASE);
                if (ni >= xc.length) {
                  if (r3) {
                    for (; xc.length <= ni; xc.push(0)) ;
                    n2 = rd = 0;
                    d2 = 1;
                    i2 %= LOG_BASE;
                    j2 = i2 - LOG_BASE + 1;
                  } else {
                    break out;
                  }
                } else {
                  n2 = k2 = xc[ni];
                  for (d2 = 1; k2 >= 10; k2 /= 10, d2++) ;
                  i2 %= LOG_BASE;
                  j2 = i2 - LOG_BASE + d2;
                  rd = j2 < 0 ? 0 : mathfloor(n2 / pows10[d2 - j2 - 1] % 10);
                }
              }
              r3 = r3 || sd < 0 || // Are there any non-zero digits after the rounding digit?
              // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
              // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
              xc[ni + 1] != null || (j2 < 0 ? n2 : n2 % pows10[d2 - j2 - 1]);
              r3 = rm < 4 ? (rd || r3) && (rm == 0 || rm == (x2.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r3 || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
              (i2 > 0 ? j2 > 0 ? n2 / pows10[d2 - j2] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x2.s < 0 ? 8 : 7));
              if (sd < 1 || !xc[0]) {
                xc.length = 0;
                if (r3) {
                  sd -= x2.e + 1;
                  xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
                  x2.e = -sd || 0;
                } else {
                  xc[0] = x2.e = 0;
                }
                return x2;
              }
              if (i2 == 0) {
                xc.length = ni;
                k2 = 1;
                ni--;
              } else {
                xc.length = ni + 1;
                k2 = pows10[LOG_BASE - i2];
                xc[ni] = j2 > 0 ? mathfloor(n2 / pows10[d2 - j2] % pows10[j2]) * k2 : 0;
              }
              if (r3) {
                for (; ; ) {
                  if (ni == 0) {
                    for (i2 = 1, j2 = xc[0]; j2 >= 10; j2 /= 10, i2++) ;
                    j2 = xc[0] += k2;
                    for (k2 = 1; j2 >= 10; j2 /= 10, k2++) ;
                    if (i2 != k2) {
                      x2.e++;
                      if (xc[0] == BASE) xc[0] = 1;
                    }
                    break;
                  } else {
                    xc[ni] += k2;
                    if (xc[ni] != BASE) break;
                    xc[ni--] = 0;
                    k2 = 1;
                  }
                }
              }
              for (i2 = xc.length; xc[--i2] === 0; xc.pop()) ;
            }
            if (x2.e > MAX_EXP) {
              x2.c = x2.e = null;
            } else if (x2.e < MIN_EXP) {
              x2.c = [x2.e = 0];
            }
          }
          return x2;
        }
        function valueOf(n2) {
          var str, e2 = n2.e;
          if (e2 === null) return n2.toString();
          str = coeffToString(n2.c);
          str = e2 <= TO_EXP_NEG || e2 >= TO_EXP_POS ? toExponential(str, e2) : toFixedPoint(str, e2, "0");
          return n2.s < 0 ? "-" + str : str;
        }
        P2.absoluteValue = P2.abs = function() {
          var x2 = new BigNumber2(this);
          if (x2.s < 0) x2.s = 1;
          return x2;
        };
        P2.comparedTo = function(y2, b2) {
          return compare(this, new BigNumber2(y2, b2));
        };
        P2.decimalPlaces = P2.dp = function(dp, rm) {
          var c2, n2, v2, x2 = this;
          if (dp != null) {
            intCheck(dp, 0, MAX);
            if (rm == null) rm = ROUNDING_MODE;
            else intCheck(rm, 0, 8);
            return round(new BigNumber2(x2), dp + x2.e + 1, rm);
          }
          if (!(c2 = x2.c)) return null;
          n2 = ((v2 = c2.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
          if (v2 = c2[v2]) for (; v2 % 10 == 0; v2 /= 10, n2--) ;
          if (n2 < 0) n2 = 0;
          return n2;
        };
        P2.dividedBy = P2.div = function(y2, b2) {
          return div(this, new BigNumber2(y2, b2), DECIMAL_PLACES, ROUNDING_MODE);
        };
        P2.dividedToIntegerBy = P2.idiv = function(y2, b2) {
          return div(this, new BigNumber2(y2, b2), 0, 1);
        };
        P2.exponentiatedBy = P2.pow = function(n2, m2) {
          var half, isModExp, i2, k2, more, nIsBig, nIsNeg, nIsOdd, y2, x2 = this;
          n2 = new BigNumber2(n2);
          if (n2.c && !n2.isInteger()) {
            throw Error(bignumberError + "Exponent not an integer: " + valueOf(n2));
          }
          if (m2 != null) m2 = new BigNumber2(m2);
          nIsBig = n2.e > 14;
          if (!x2.c || !x2.c[0] || x2.c[0] == 1 && !x2.e && x2.c.length == 1 || !n2.c || !n2.c[0]) {
            y2 = new BigNumber2(Math.pow(+valueOf(x2), nIsBig ? n2.s * (2 - isOdd(n2)) : +valueOf(n2)));
            return m2 ? y2.mod(m2) : y2;
          }
          nIsNeg = n2.s < 0;
          if (m2) {
            if (m2.c ? !m2.c[0] : !m2.s) return new BigNumber2(NaN);
            isModExp = !nIsNeg && x2.isInteger() && m2.isInteger();
            if (isModExp) x2 = x2.mod(m2);
          } else if (n2.e > 9 && (x2.e > 0 || x2.e < -1 || (x2.e == 0 ? x2.c[0] > 1 || nIsBig && x2.c[1] >= 24e7 : x2.c[0] < 8e13 || nIsBig && x2.c[0] <= 9999975e7))) {
            k2 = x2.s < 0 && isOdd(n2) ? -0 : 0;
            if (x2.e > -1) k2 = 1 / k2;
            return new BigNumber2(nIsNeg ? 1 / k2 : k2);
          } else if (POW_PRECISION) {
            k2 = mathceil(POW_PRECISION / LOG_BASE + 2);
          }
          if (nIsBig) {
            half = new BigNumber2(0.5);
            if (nIsNeg) n2.s = 1;
            nIsOdd = isOdd(n2);
          } else {
            i2 = Math.abs(+valueOf(n2));
            nIsOdd = i2 % 2;
          }
          y2 = new BigNumber2(ONE);
          for (; ; ) {
            if (nIsOdd) {
              y2 = y2.times(x2);
              if (!y2.c) break;
              if (k2) {
                if (y2.c.length > k2) y2.c.length = k2;
              } else if (isModExp) {
                y2 = y2.mod(m2);
              }
            }
            if (i2) {
              i2 = mathfloor(i2 / 2);
              if (i2 === 0) break;
              nIsOdd = i2 % 2;
            } else {
              n2 = n2.times(half);
              round(n2, n2.e + 1, 1);
              if (n2.e > 14) {
                nIsOdd = isOdd(n2);
              } else {
                i2 = +valueOf(n2);
                if (i2 === 0) break;
                nIsOdd = i2 % 2;
              }
            }
            x2 = x2.times(x2);
            if (k2) {
              if (x2.c && x2.c.length > k2) x2.c.length = k2;
            } else if (isModExp) {
              x2 = x2.mod(m2);
            }
          }
          if (isModExp) return y2;
          if (nIsNeg) y2 = ONE.div(y2);
          return m2 ? y2.mod(m2) : k2 ? round(y2, POW_PRECISION, ROUNDING_MODE, more) : y2;
        };
        P2.integerValue = function(rm) {
          var n2 = new BigNumber2(this);
          if (rm == null) rm = ROUNDING_MODE;
          else intCheck(rm, 0, 8);
          return round(n2, n2.e + 1, rm);
        };
        P2.isEqualTo = P2.eq = function(y2, b2) {
          return compare(this, new BigNumber2(y2, b2)) === 0;
        };
        P2.isFinite = function() {
          return !!this.c;
        };
        P2.isGreaterThan = P2.gt = function(y2, b2) {
          return compare(this, new BigNumber2(y2, b2)) > 0;
        };
        P2.isGreaterThanOrEqualTo = P2.gte = function(y2, b2) {
          return (b2 = compare(this, new BigNumber2(y2, b2))) === 1 || b2 === 0;
        };
        P2.isInteger = function() {
          return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
        };
        P2.isLessThan = P2.lt = function(y2, b2) {
          return compare(this, new BigNumber2(y2, b2)) < 0;
        };
        P2.isLessThanOrEqualTo = P2.lte = function(y2, b2) {
          return (b2 = compare(this, new BigNumber2(y2, b2))) === -1 || b2 === 0;
        };
        P2.isNaN = function() {
          return !this.s;
        };
        P2.isNegative = function() {
          return this.s < 0;
        };
        P2.isPositive = function() {
          return this.s > 0;
        };
        P2.isZero = function() {
          return !!this.c && this.c[0] == 0;
        };
        P2.minus = function(y2, b2) {
          var i2, j2, t, xLTy, x2 = this, a2 = x2.s;
          y2 = new BigNumber2(y2, b2);
          b2 = y2.s;
          if (!a2 || !b2) return new BigNumber2(NaN);
          if (a2 != b2) {
            y2.s = -b2;
            return x2.plus(y2);
          }
          var xe = x2.e / LOG_BASE, ye = y2.e / LOG_BASE, xc = x2.c, yc = y2.c;
          if (!xe || !ye) {
            if (!xc || !yc) return xc ? (y2.s = -b2, y2) : new BigNumber2(yc ? x2 : NaN);
            if (!xc[0] || !yc[0]) {
              return yc[0] ? (y2.s = -b2, y2) : new BigNumber2(xc[0] ? x2 : (
                // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
                ROUNDING_MODE == 3 ? -0 : 0
              ));
            }
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a2 = xe - ye) {
            if (xLTy = a2 < 0) {
              a2 = -a2;
              t = xc;
            } else {
              ye = xe;
              t = yc;
            }
            t.reverse();
            for (b2 = a2; b2--; t.push(0)) ;
            t.reverse();
          } else {
            j2 = (xLTy = (a2 = xc.length) < (b2 = yc.length)) ? a2 : b2;
            for (a2 = b2 = 0; b2 < j2; b2++) {
              if (xc[b2] != yc[b2]) {
                xLTy = xc[b2] < yc[b2];
                break;
              }
            }
          }
          if (xLTy) {
            t = xc;
            xc = yc;
            yc = t;
            y2.s = -y2.s;
          }
          b2 = (j2 = yc.length) - (i2 = xc.length);
          if (b2 > 0) for (; b2--; xc[i2++] = 0) ;
          b2 = BASE - 1;
          for (; j2 > a2; ) {
            if (xc[--j2] < yc[j2]) {
              for (i2 = j2; i2 && !xc[--i2]; xc[i2] = b2) ;
              --xc[i2];
              xc[j2] += BASE;
            }
            xc[j2] -= yc[j2];
          }
          for (; xc[0] == 0; xc.splice(0, 1), --ye) ;
          if (!xc[0]) {
            y2.s = ROUNDING_MODE == 3 ? -1 : 1;
            y2.c = [y2.e = 0];
            return y2;
          }
          return normalise(y2, xc, ye);
        };
        P2.modulo = P2.mod = function(y2, b2) {
          var q2, s2, x2 = this;
          y2 = new BigNumber2(y2, b2);
          if (!x2.c || !y2.s || y2.c && !y2.c[0]) {
            return new BigNumber2(NaN);
          } else if (!y2.c || x2.c && !x2.c[0]) {
            return new BigNumber2(x2);
          }
          if (MODULO_MODE == 9) {
            s2 = y2.s;
            y2.s = 1;
            q2 = div(x2, y2, 0, 3);
            y2.s = s2;
            q2.s *= s2;
          } else {
            q2 = div(x2, y2, 0, MODULO_MODE);
          }
          y2 = x2.minus(q2.times(y2));
          if (!y2.c[0] && MODULO_MODE == 1) y2.s = x2.s;
          return y2;
        };
        P2.multipliedBy = P2.times = function(y2, b2) {
          var c2, e2, i2, j2, k2, m2, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x2 = this, xc = x2.c, yc = (y2 = new BigNumber2(y2, b2)).c;
          if (!xc || !yc || !xc[0] || !yc[0]) {
            if (!x2.s || !y2.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
              y2.c = y2.e = y2.s = null;
            } else {
              y2.s *= x2.s;
              if (!xc || !yc) {
                y2.c = y2.e = null;
              } else {
                y2.c = [0];
                y2.e = 0;
              }
            }
            return y2;
          }
          e2 = bitFloor(x2.e / LOG_BASE) + bitFloor(y2.e / LOG_BASE);
          y2.s *= x2.s;
          xcL = xc.length;
          ycL = yc.length;
          if (xcL < ycL) {
            zc = xc;
            xc = yc;
            yc = zc;
            i2 = xcL;
            xcL = ycL;
            ycL = i2;
          }
          for (i2 = xcL + ycL, zc = []; i2--; zc.push(0)) ;
          base = BASE;
          sqrtBase = SQRT_BASE;
          for (i2 = ycL; --i2 >= 0; ) {
            c2 = 0;
            ylo = yc[i2] % sqrtBase;
            yhi = yc[i2] / sqrtBase | 0;
            for (k2 = xcL, j2 = i2 + k2; j2 > i2; ) {
              xlo = xc[--k2] % sqrtBase;
              xhi = xc[k2] / sqrtBase | 0;
              m2 = yhi * xlo + xhi * ylo;
              xlo = ylo * xlo + m2 % sqrtBase * sqrtBase + zc[j2] + c2;
              c2 = (xlo / base | 0) + (m2 / sqrtBase | 0) + yhi * xhi;
              zc[j2--] = xlo % base;
            }
            zc[j2] = c2;
          }
          if (c2) {
            ++e2;
          } else {
            zc.splice(0, 1);
          }
          return normalise(y2, zc, e2);
        };
        P2.negated = function() {
          var x2 = new BigNumber2(this);
          x2.s = -x2.s || null;
          return x2;
        };
        P2.plus = function(y2, b2) {
          var t, x2 = this, a2 = x2.s;
          y2 = new BigNumber2(y2, b2);
          b2 = y2.s;
          if (!a2 || !b2) return new BigNumber2(NaN);
          if (a2 != b2) {
            y2.s = -b2;
            return x2.minus(y2);
          }
          var xe = x2.e / LOG_BASE, ye = y2.e / LOG_BASE, xc = x2.c, yc = y2.c;
          if (!xe || !ye) {
            if (!xc || !yc) return new BigNumber2(a2 / 0);
            if (!xc[0] || !yc[0]) return yc[0] ? y2 : new BigNumber2(xc[0] ? x2 : a2 * 0);
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a2 = xe - ye) {
            if (a2 > 0) {
              ye = xe;
              t = yc;
            } else {
              a2 = -a2;
              t = xc;
            }
            t.reverse();
            for (; a2--; t.push(0)) ;
            t.reverse();
          }
          a2 = xc.length;
          b2 = yc.length;
          if (a2 - b2 < 0) {
            t = yc;
            yc = xc;
            xc = t;
            b2 = a2;
          }
          for (a2 = 0; b2; ) {
            a2 = (xc[--b2] = xc[b2] + yc[b2] + a2) / BASE | 0;
            xc[b2] = BASE === xc[b2] ? 0 : xc[b2] % BASE;
          }
          if (a2) {
            xc = [a2].concat(xc);
            ++ye;
          }
          return normalise(y2, xc, ye);
        };
        P2.precision = P2.sd = function(sd, rm) {
          var c2, n2, v2, x2 = this;
          if (sd != null && sd !== !!sd) {
            intCheck(sd, 1, MAX);
            if (rm == null) rm = ROUNDING_MODE;
            else intCheck(rm, 0, 8);
            return round(new BigNumber2(x2), sd, rm);
          }
          if (!(c2 = x2.c)) return null;
          v2 = c2.length - 1;
          n2 = v2 * LOG_BASE + 1;
          if (v2 = c2[v2]) {
            for (; v2 % 10 == 0; v2 /= 10, n2--) ;
            for (v2 = c2[0]; v2 >= 10; v2 /= 10, n2++) ;
          }
          if (sd && x2.e + 1 > n2) n2 = x2.e + 1;
          return n2;
        };
        P2.shiftedBy = function(k2) {
          intCheck(k2, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
          return this.times("1e" + k2);
        };
        P2.squareRoot = P2.sqrt = function() {
          var m2, n2, r3, rep, t, x2 = this, c2 = x2.c, s2 = x2.s, e2 = x2.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
          if (s2 !== 1 || !c2 || !c2[0]) {
            return new BigNumber2(!s2 || s2 < 0 && (!c2 || c2[0]) ? NaN : c2 ? x2 : 1 / 0);
          }
          s2 = Math.sqrt(+valueOf(x2));
          if (s2 == 0 || s2 == 1 / 0) {
            n2 = coeffToString(c2);
            if ((n2.length + e2) % 2 == 0) n2 += "0";
            s2 = Math.sqrt(+n2);
            e2 = bitFloor((e2 + 1) / 2) - (e2 < 0 || e2 % 2);
            if (s2 == 1 / 0) {
              n2 = "5e" + e2;
            } else {
              n2 = s2.toExponential();
              n2 = n2.slice(0, n2.indexOf("e") + 1) + e2;
            }
            r3 = new BigNumber2(n2);
          } else {
            r3 = new BigNumber2(s2 + "");
          }
          if (r3.c[0]) {
            e2 = r3.e;
            s2 = e2 + dp;
            if (s2 < 3) s2 = 0;
            for (; ; ) {
              t = r3;
              r3 = half.times(t.plus(div(x2, t, dp, 1)));
              if (coeffToString(t.c).slice(0, s2) === (n2 = coeffToString(r3.c)).slice(0, s2)) {
                if (r3.e < e2) --s2;
                n2 = n2.slice(s2 - 3, s2 + 1);
                if (n2 == "9999" || !rep && n2 == "4999") {
                  if (!rep) {
                    round(t, t.e + DECIMAL_PLACES + 2, 0);
                    if (t.times(t).eq(x2)) {
                      r3 = t;
                      break;
                    }
                  }
                  dp += 4;
                  s2 += 4;
                  rep = 1;
                } else {
                  if (!+n2 || !+n2.slice(1) && n2.charAt(0) == "5") {
                    round(r3, r3.e + DECIMAL_PLACES + 2, 1);
                    m2 = !r3.times(r3).eq(x2);
                  }
                  break;
                }
              }
            }
          }
          return round(r3, r3.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m2);
        };
        P2.toExponential = function(dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp++;
          }
          return format(this, dp, rm, 1);
        };
        P2.toFixed = function(dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp = dp + this.e + 1;
          }
          return format(this, dp, rm);
        };
        P2.toFormat = function(dp, rm, format2) {
          var str, x2 = this;
          if (format2 == null) {
            if (dp != null && rm && typeof rm == "object") {
              format2 = rm;
              rm = null;
            } else if (dp && typeof dp == "object") {
              format2 = dp;
              dp = rm = null;
            } else {
              format2 = FORMAT;
            }
          } else if (typeof format2 != "object") {
            throw Error(bignumberError + "Argument not an object: " + format2);
          }
          str = x2.toFixed(dp, rm);
          if (x2.c) {
            var i2, arr = str.split("."), g1 = +format2.groupSize, g2 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x2.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
            if (g2) {
              i2 = g1;
              g1 = g2;
              g2 = i2;
              len -= i2;
            }
            if (g1 > 0 && len > 0) {
              i2 = len % g1 || g1;
              intPart = intDigits.substr(0, i2);
              for (; i2 < len; i2 += g1) intPart += groupSeparator + intDigits.substr(i2, g1);
              if (g2 > 0) intPart += groupSeparator + intDigits.slice(i2);
              if (isNeg) intPart = "-" + intPart;
            }
            str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g2 = +format2.fractionGroupSize) ? fractionPart.replace(
              new RegExp("\\d{" + g2 + "}\\B", "g"),
              "$&" + (format2.fractionGroupSeparator || "")
            ) : fractionPart) : intPart;
          }
          return (format2.prefix || "") + str + (format2.suffix || "");
        };
        P2.toFraction = function(md) {
          var d2, d0, d1, d22, e2, exp, n2, n0, n1, q2, r3, s2, x2 = this, xc = x2.c;
          if (md != null) {
            n2 = new BigNumber2(md);
            if (!n2.isInteger() && (n2.c || n2.s !== 1) || n2.lt(ONE)) {
              throw Error(bignumberError + "Argument " + (n2.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n2));
            }
          }
          if (!xc) return new BigNumber2(x2);
          d2 = new BigNumber2(ONE);
          n1 = d0 = new BigNumber2(ONE);
          d1 = n0 = new BigNumber2(ONE);
          s2 = coeffToString(xc);
          e2 = d2.e = s2.length - x2.e - 1;
          d2.c[0] = POWS_TEN[(exp = e2 % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
          md = !md || n2.comparedTo(d2) > 0 ? e2 > 0 ? d2 : n1 : n2;
          exp = MAX_EXP;
          MAX_EXP = 1 / 0;
          n2 = new BigNumber2(s2);
          n0.c[0] = 0;
          for (; ; ) {
            q2 = div(n2, d2, 0, 1);
            d22 = d0.plus(q2.times(d1));
            if (d22.comparedTo(md) == 1) break;
            d0 = d1;
            d1 = d22;
            n1 = n0.plus(q2.times(d22 = n1));
            n0 = d22;
            d2 = n2.minus(q2.times(d22 = d2));
            n2 = d22;
          }
          d22 = div(md.minus(d0), d1, 0, 1);
          n0 = n0.plus(d22.times(n1));
          d0 = d0.plus(d22.times(d1));
          n0.s = n1.s = x2.s;
          e2 = e2 * 2;
          r3 = div(n1, d1, e2, ROUNDING_MODE).minus(x2).abs().comparedTo(
            div(n0, d0, e2, ROUNDING_MODE).minus(x2).abs()
          ) < 1 ? [n1, d1] : [n0, d0];
          MAX_EXP = exp;
          return r3;
        };
        P2.toNumber = function() {
          return +valueOf(this);
        };
        P2.toPrecision = function(sd, rm) {
          if (sd != null) intCheck(sd, 1, MAX);
          return format(this, sd, rm, 2);
        };
        P2.toString = function(b2) {
          var str, n2 = this, s2 = n2.s, e2 = n2.e;
          if (e2 === null) {
            if (s2) {
              str = "Infinity";
              if (s2 < 0) str = "-" + str;
            } else {
              str = "NaN";
            }
          } else {
            if (b2 == null) {
              str = e2 <= TO_EXP_NEG || e2 >= TO_EXP_POS ? toExponential(coeffToString(n2.c), e2) : toFixedPoint(coeffToString(n2.c), e2, "0");
            } else if (b2 === 10 && alphabetHasNormalDecimalDigits) {
              n2 = round(new BigNumber2(n2), DECIMAL_PLACES + e2 + 1, ROUNDING_MODE);
              str = toFixedPoint(coeffToString(n2.c), n2.e, "0");
            } else {
              intCheck(b2, 2, ALPHABET.length, "Base");
              str = convertBase(toFixedPoint(coeffToString(n2.c), e2, "0"), 10, b2, s2, true);
            }
            if (s2 < 0 && n2.c[0]) str = "-" + str;
          }
          return str;
        };
        P2.valueOf = P2.toJSON = function() {
          return valueOf(this);
        };
        P2._isBigNumber = true;
        if (configObject != null) BigNumber2.set(configObject);
        return BigNumber2;
      }
      function bitFloor(n2) {
        var i2 = n2 | 0;
        return n2 > 0 || n2 === i2 ? i2 : i2 - 1;
      }
      function coeffToString(a2) {
        var s2, z2, i2 = 1, j2 = a2.length, r3 = a2[0] + "";
        for (; i2 < j2; ) {
          s2 = a2[i2++] + "";
          z2 = LOG_BASE - s2.length;
          for (; z2--; s2 = "0" + s2) ;
          r3 += s2;
        }
        for (j2 = r3.length; r3.charCodeAt(--j2) === 48; ) ;
        return r3.slice(0, j2 + 1 || 1);
      }
      function compare(x2, y2) {
        var a2, b2, xc = x2.c, yc = y2.c, i2 = x2.s, j2 = y2.s, k2 = x2.e, l2 = y2.e;
        if (!i2 || !j2) return null;
        a2 = xc && !xc[0];
        b2 = yc && !yc[0];
        if (a2 || b2) return a2 ? b2 ? 0 : -j2 : i2;
        if (i2 != j2) return i2;
        a2 = i2 < 0;
        b2 = k2 == l2;
        if (!xc || !yc) return b2 ? 0 : !xc ^ a2 ? 1 : -1;
        if (!b2) return k2 > l2 ^ a2 ? 1 : -1;
        j2 = (k2 = xc.length) < (l2 = yc.length) ? k2 : l2;
        for (i2 = 0; i2 < j2; i2++) if (xc[i2] != yc[i2]) return xc[i2] > yc[i2] ^ a2 ? 1 : -1;
        return k2 == l2 ? 0 : k2 > l2 ^ a2 ? 1 : -1;
      }
      function intCheck(n2, min, max, name) {
        if (n2 < min || n2 > max || n2 !== mathfloor(n2)) {
          throw Error(bignumberError + (name || "Argument") + (typeof n2 == "number" ? n2 < min || n2 > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n2));
        }
      }
      function isOdd(n2) {
        var k2 = n2.c.length - 1;
        return bitFloor(n2.e / LOG_BASE) == k2 && n2.c[k2] % 2 != 0;
      }
      function toExponential(str, e2) {
        return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e2 < 0 ? "e" : "e+") + e2;
      }
      function toFixedPoint(str, e2, z2) {
        var len, zs;
        if (e2 < 0) {
          for (zs = z2 + "."; ++e2; zs += z2) ;
          str = zs + str;
        } else {
          len = str.length;
          if (++e2 > len) {
            for (zs = z2, e2 -= len; --e2; zs += z2) ;
            str += zs;
          } else if (e2 < len) {
            str = str.slice(0, e2) + "." + str.slice(e2);
          }
        }
        return str;
      }
      BigNumber = clone();
      BigNumber["default"] = BigNumber.BigNumber = BigNumber;
      if (typeof define == "function" && define.amd) {
        define(function() {
          return BigNumber;
        });
      } else if (typeof module != "undefined" && module.exports) {
        module.exports = BigNumber;
      } else {
        if (!globalObject) {
          globalObject = typeof self != "undefined" && self ? self : window;
        }
        globalObject.BigNumber = BigNumber;
      }
    })(exports);
  }
});

// node_modules/json-bigint/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/json-bigint/lib/stringify.js"(exports, module) {
    var BigNumber = require_bignumber();
    var JSON2 = module.exports;
    (function() {
      "use strict";
      function f2(n2) {
        return n2 < 10 ? "0" + n2 : n2;
      }
      var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, gap, indent, meta = {
        // table of character substitutions
        "\b": "\\b",
        "	": "\\t",
        "\n": "\\n",
        "\f": "\\f",
        "\r": "\\r",
        '"': '\\"',
        "\\": "\\\\"
      }, rep;
      function quote(string) {
        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function(a2) {
          var c2 = meta[a2];
          return typeof c2 === "string" ? c2 : "\\u" + ("0000" + a2.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
      }
      function str(key, holder) {
        var i2, k2, v2, length, mind = gap, partial, value = holder[key], isBigNumber = value != null && (value instanceof BigNumber || BigNumber.isBigNumber(value));
        if (value && typeof value === "object" && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        if (typeof rep === "function") {
          value = rep.call(holder, key, value);
        }
        switch (typeof value) {
          case "string":
            if (isBigNumber) {
              return value;
            } else {
              return quote(value);
            }
          case "number":
            return isFinite(value) ? String(value) : "null";
          case "boolean":
          case "null":
          case "bigint":
            return String(value);
          // If the type is 'object', we might be dealing with an object or an array or
          // null.
          case "object":
            if (!value) {
              return "null";
            }
            gap += indent;
            partial = [];
            if (Object.prototype.toString.apply(value) === "[object Array]") {
              length = value.length;
              for (i2 = 0; i2 < length; i2 += 1) {
                partial[i2] = str(i2, value) || "null";
              }
              v2 = partial.length === 0 ? "[]" : gap ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]" : "[" + partial.join(",") + "]";
              gap = mind;
              return v2;
            }
            if (rep && typeof rep === "object") {
              length = rep.length;
              for (i2 = 0; i2 < length; i2 += 1) {
                if (typeof rep[i2] === "string") {
                  k2 = rep[i2];
                  v2 = str(k2, value);
                  if (v2) {
                    partial.push(quote(k2) + (gap ? ": " : ":") + v2);
                  }
                }
              }
            } else {
              Object.keys(value).forEach(function(k3) {
                var v3 = str(k3, value);
                if (v3) {
                  partial.push(quote(k3) + (gap ? ": " : ":") + v3);
                }
              });
            }
            v2 = partial.length === 0 ? "{}" : gap ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}" : "{" + partial.join(",") + "}";
            gap = mind;
            return v2;
        }
      }
      if (typeof JSON2.stringify !== "function") {
        JSON2.stringify = function(value, replacer, space) {
          var i2;
          gap = "";
          indent = "";
          if (typeof space === "number") {
            for (i2 = 0; i2 < space; i2 += 1) {
              indent += " ";
            }
          } else if (typeof space === "string") {
            indent = space;
          }
          rep = replacer;
          if (replacer && typeof replacer !== "function" && (typeof replacer !== "object" || typeof replacer.length !== "number")) {
            throw new Error("JSON.stringify");
          }
          return str("", { "": value });
        };
      }
    })();
  }
});

// node_modules/json-bigint/lib/parse.js
var require_parse = __commonJS({
  "node_modules/json-bigint/lib/parse.js"(exports, module) {
    var BigNumber = null;
    var suspectProtoRx = /(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])/;
    var suspectConstructorRx = /(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)/;
    var json_parse = function(options) {
      "use strict";
      var _options = {
        strict: false,
        // not being strict means do not generate syntax errors for "duplicate key"
        storeAsString: false,
        // toggles whether the values should be stored as BigNumber (default) or a string
        alwaysParseAsBig: false,
        // toggles whether all numbers should be Big
        useNativeBigInt: false,
        // toggles whether to use native BigInt instead of bignumber.js
        protoAction: "error",
        constructorAction: "error"
      };
      if (options !== void 0 && options !== null) {
        if (options.strict === true) {
          _options.strict = true;
        }
        if (options.storeAsString === true) {
          _options.storeAsString = true;
        }
        _options.alwaysParseAsBig = options.alwaysParseAsBig === true ? options.alwaysParseAsBig : false;
        _options.useNativeBigInt = options.useNativeBigInt === true ? options.useNativeBigInt : false;
        if (typeof options.constructorAction !== "undefined") {
          if (options.constructorAction === "error" || options.constructorAction === "ignore" || options.constructorAction === "preserve") {
            _options.constructorAction = options.constructorAction;
          } else {
            throw new Error(
              `Incorrect value for constructorAction option, must be "error", "ignore" or undefined but passed ${options.constructorAction}`
            );
          }
        }
        if (typeof options.protoAction !== "undefined") {
          if (options.protoAction === "error" || options.protoAction === "ignore" || options.protoAction === "preserve") {
            _options.protoAction = options.protoAction;
          } else {
            throw new Error(
              `Incorrect value for protoAction option, must be "error", "ignore" or undefined but passed ${options.protoAction}`
            );
          }
        }
      }
      var at2, ch, escapee = {
        '"': '"',
        "\\": "\\",
        "/": "/",
        b: "\b",
        f: "\f",
        n: "\n",
        r: "\r",
        t: "	"
      }, text, error = function(m2) {
        throw {
          name: "SyntaxError",
          message: m2,
          at: at2,
          text
        };
      }, next = function(c2) {
        if (c2 && c2 !== ch) {
          error("Expected '" + c2 + "' instead of '" + ch + "'");
        }
        ch = text.charAt(at2);
        at2 += 1;
        return ch;
      }, number = function() {
        var number2, string2 = "";
        if (ch === "-") {
          string2 = "-";
          next("-");
        }
        while (ch >= "0" && ch <= "9") {
          string2 += ch;
          next();
        }
        if (ch === ".") {
          string2 += ".";
          while (next() && ch >= "0" && ch <= "9") {
            string2 += ch;
          }
        }
        if (ch === "e" || ch === "E") {
          string2 += ch;
          next();
          if (ch === "-" || ch === "+") {
            string2 += ch;
            next();
          }
          while (ch >= "0" && ch <= "9") {
            string2 += ch;
            next();
          }
        }
        number2 = +string2;
        if (!isFinite(number2)) {
          error("Bad number");
        } else {
          if (BigNumber == null) BigNumber = require_bignumber();
          if (string2.length > 15)
            return _options.storeAsString ? string2 : _options.useNativeBigInt ? BigInt(string2) : new BigNumber(string2);
          else
            return !_options.alwaysParseAsBig ? number2 : _options.useNativeBigInt ? BigInt(number2) : new BigNumber(number2);
        }
      }, string = function() {
        var hex, i2, string2 = "", uffff;
        if (ch === '"') {
          var startAt = at2;
          while (next()) {
            if (ch === '"') {
              if (at2 - 1 > startAt) string2 += text.substring(startAt, at2 - 1);
              next();
              return string2;
            }
            if (ch === "\\") {
              if (at2 - 1 > startAt) string2 += text.substring(startAt, at2 - 1);
              next();
              if (ch === "u") {
                uffff = 0;
                for (i2 = 0; i2 < 4; i2 += 1) {
                  hex = parseInt(next(), 16);
                  if (!isFinite(hex)) {
                    break;
                  }
                  uffff = uffff * 16 + hex;
                }
                string2 += String.fromCharCode(uffff);
              } else if (typeof escapee[ch] === "string") {
                string2 += escapee[ch];
              } else {
                break;
              }
              startAt = at2;
            }
          }
        }
        error("Bad string");
      }, white = function() {
        while (ch && ch <= " ") {
          next();
        }
      }, word = function() {
        switch (ch) {
          case "t":
            next("t");
            next("r");
            next("u");
            next("e");
            return true;
          case "f":
            next("f");
            next("a");
            next("l");
            next("s");
            next("e");
            return false;
          case "n":
            next("n");
            next("u");
            next("l");
            next("l");
            return null;
        }
        error("Unexpected '" + ch + "'");
      }, value, array = function() {
        var array2 = [];
        if (ch === "[") {
          next("[");
          white();
          if (ch === "]") {
            next("]");
            return array2;
          }
          while (ch) {
            array2.push(value());
            white();
            if (ch === "]") {
              next("]");
              return array2;
            }
            next(",");
            white();
          }
        }
        error("Bad array");
      }, object = function() {
        var key, object2 = /* @__PURE__ */ Object.create(null);
        if (ch === "{") {
          next("{");
          white();
          if (ch === "}") {
            next("}");
            return object2;
          }
          while (ch) {
            key = string();
            white();
            next(":");
            if (_options.strict === true && Object.hasOwnProperty.call(object2, key)) {
              error('Duplicate key "' + key + '"');
            }
            if (suspectProtoRx.test(key) === true) {
              if (_options.protoAction === "error") {
                error("Object contains forbidden prototype property");
              } else if (_options.protoAction === "ignore") {
                value();
              } else {
                object2[key] = value();
              }
            } else if (suspectConstructorRx.test(key) === true) {
              if (_options.constructorAction === "error") {
                error("Object contains forbidden constructor property");
              } else if (_options.constructorAction === "ignore") {
                value();
              } else {
                object2[key] = value();
              }
            } else {
              object2[key] = value();
            }
            white();
            if (ch === "}") {
              next("}");
              return object2;
            }
            next(",");
            white();
          }
        }
        error("Bad object");
      };
      value = function() {
        white();
        switch (ch) {
          case "{":
            return object();
          case "[":
            return array();
          case '"':
            return string();
          case "-":
            return number();
          default:
            return ch >= "0" && ch <= "9" ? number() : word();
        }
      };
      return function(source, reviver) {
        var result;
        text = source + "";
        at2 = 0;
        ch = " ";
        result = value();
        white();
        if (ch) {
          error("Syntax error");
        }
        return typeof reviver === "function" ? (function walk(holder, key) {
          var k2, v2, value2 = holder[key];
          if (value2 && typeof value2 === "object") {
            Object.keys(value2).forEach(function(k3) {
              v2 = walk(value2, k3);
              if (v2 !== void 0) {
                value2[k3] = v2;
              } else {
                delete value2[k3];
              }
            });
          }
          return reviver.call(holder, key, value2);
        })({ "": result }, "") : result;
      };
    };
    module.exports = json_parse;
  }
});

// node_modules/json-bigint/index.js
var require_json_bigint = __commonJS({
  "node_modules/json-bigint/index.js"(exports, module) {
    var json_stringify = require_stringify().stringify;
    var json_parse = require_parse();
    module.exports = function(options) {
      return {
        parse: json_parse(options),
        stringify: json_stringify
      };
    };
    module.exports.parse = json_parse();
    module.exports.stringify = json_stringify;
  }
});

// node_modules/hi-base32/src/base32.js
var require_base32 = __commonJS({
  "node_modules/hi-base32/src/base32.js"(exports, module) {
    (function() {
      "use strict";
      var root = typeof window === "object" ? window : {};
      var NODE_JS = !root.HI_BASE32_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS) {
        root = global;
      }
      var COMMON_JS = !root.HI_BASE32_NO_COMMON_JS && typeof module === "object" && module.exports;
      var AMD = typeof define === "function" && define.amd;
      var BASE32_ENCODE_CHAR = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567".split("");
      var BASE32_DECODE_CHAR = {
        "A": 0,
        "B": 1,
        "C": 2,
        "D": 3,
        "E": 4,
        "F": 5,
        "G": 6,
        "H": 7,
        "I": 8,
        "J": 9,
        "K": 10,
        "L": 11,
        "M": 12,
        "N": 13,
        "O": 14,
        "P": 15,
        "Q": 16,
        "R": 17,
        "S": 18,
        "T": 19,
        "U": 20,
        "V": 21,
        "W": 22,
        "X": 23,
        "Y": 24,
        "Z": 25,
        "2": 26,
        "3": 27,
        "4": 28,
        "5": 29,
        "6": 30,
        "7": 31
      };
      var blocks = [0, 0, 0, 0, 0, 0, 0, 0];
      var throwInvalidUtf8 = function(position, partial) {
        if (partial.length > 10) {
          partial = "..." + partial.substr(-10);
        }
        var err = new Error("Decoded data is not valid UTF-8. Maybe try base32.decode.asBytes()? Partial data after reading " + position + " bytes: " + partial + " <-");
        err.position = position;
        throw err;
      };
      var toUtf8String = function(bytes) {
        var str = "", length = bytes.length, i2 = 0, followingChars = 0, b2, c2;
        while (i2 < length) {
          b2 = bytes[i2++];
          if (b2 <= 127) {
            str += String.fromCharCode(b2);
            continue;
          } else if (b2 > 191 && b2 <= 223) {
            c2 = b2 & 31;
            followingChars = 1;
          } else if (b2 <= 239) {
            c2 = b2 & 15;
            followingChars = 2;
          } else if (b2 <= 247) {
            c2 = b2 & 7;
            followingChars = 3;
          } else {
            throwInvalidUtf8(i2, str);
          }
          for (var j2 = 0; j2 < followingChars; ++j2) {
            b2 = bytes[i2++];
            if (b2 < 128 || b2 > 191) {
              throwInvalidUtf8(i2, str);
            }
            c2 <<= 6;
            c2 += b2 & 63;
          }
          if (c2 >= 55296 && c2 <= 57343) {
            throwInvalidUtf8(i2, str);
          }
          if (c2 > 1114111) {
            throwInvalidUtf8(i2, str);
          }
          if (c2 <= 65535) {
            str += String.fromCharCode(c2);
          } else {
            c2 -= 65536;
            str += String.fromCharCode((c2 >> 10) + 55296);
            str += String.fromCharCode((c2 & 1023) + 56320);
          }
        }
        return str;
      };
      var decodeAsBytes = function(base32Str) {
        if (base32Str === "") {
          return [];
        } else if (!/^[A-Z2-7=]+$/.test(base32Str)) {
          throw new Error("Invalid base32 characters");
        }
        base32Str = base32Str.replace(/=/g, "");
        var v1, v2, v3, v4, v5, v6, v7, v8, bytes = [], index = 0, length = base32Str.length;
        for (var i2 = 0, count = length >> 3 << 3; i2 < count; ) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v3 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v4 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v5 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v6 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v7 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v8 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          bytes[index++] = (v1 << 3 | v2 >>> 2) & 255;
          bytes[index++] = (v2 << 6 | v3 << 1 | v4 >>> 4) & 255;
          bytes[index++] = (v4 << 4 | v5 >>> 1) & 255;
          bytes[index++] = (v5 << 7 | v6 << 2 | v7 >>> 3) & 255;
          bytes[index++] = (v7 << 5 | v8) & 255;
        }
        var remain = length - count;
        if (remain === 2) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          bytes[index++] = (v1 << 3 | v2 >>> 2) & 255;
        } else if (remain === 4) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v3 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v4 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          bytes[index++] = (v1 << 3 | v2 >>> 2) & 255;
          bytes[index++] = (v2 << 6 | v3 << 1 | v4 >>> 4) & 255;
        } else if (remain === 5) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v3 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v4 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v5 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          bytes[index++] = (v1 << 3 | v2 >>> 2) & 255;
          bytes[index++] = (v2 << 6 | v3 << 1 | v4 >>> 4) & 255;
          bytes[index++] = (v4 << 4 | v5 >>> 1) & 255;
        } else if (remain === 7) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v3 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v4 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v5 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v6 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v7 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          bytes[index++] = (v1 << 3 | v2 >>> 2) & 255;
          bytes[index++] = (v2 << 6 | v3 << 1 | v4 >>> 4) & 255;
          bytes[index++] = (v4 << 4 | v5 >>> 1) & 255;
          bytes[index++] = (v5 << 7 | v6 << 2 | v7 >>> 3) & 255;
        }
        return bytes;
      };
      var encodeAscii = function(str) {
        var v1, v2, v3, v4, v5, base32Str = "", length = str.length;
        for (var i2 = 0, count = parseInt(length / 5) * 5; i2 < count; ) {
          v1 = str.charCodeAt(i2++);
          v2 = str.charCodeAt(i2++);
          v3 = str.charCodeAt(i2++);
          v4 = str.charCodeAt(i2++);
          v5 = str.charCodeAt(i2++);
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v4 >>> 7) & 31] + BASE32_ENCODE_CHAR[v4 >>> 2 & 31] + BASE32_ENCODE_CHAR[(v4 << 3 | v5 >>> 5) & 31] + BASE32_ENCODE_CHAR[v5 & 31];
        }
        var remain = length - count;
        if (remain === 1) {
          v1 = str.charCodeAt(i2);
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[v1 << 2 & 31] + "======";
        } else if (remain === 2) {
          v1 = str.charCodeAt(i2++);
          v2 = str.charCodeAt(i2);
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[v2 << 4 & 31] + "====";
        } else if (remain === 3) {
          v1 = str.charCodeAt(i2++);
          v2 = str.charCodeAt(i2++);
          v3 = str.charCodeAt(i2);
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[v3 << 1 & 31] + "===";
        } else if (remain === 4) {
          v1 = str.charCodeAt(i2++);
          v2 = str.charCodeAt(i2++);
          v3 = str.charCodeAt(i2++);
          v4 = str.charCodeAt(i2);
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v4 >>> 7) & 31] + BASE32_ENCODE_CHAR[v4 >>> 2 & 31] + BASE32_ENCODE_CHAR[v4 << 3 & 31] + "=";
        }
        return base32Str;
      };
      var encodeUtf8 = function(str) {
        var v1, v2, v3, v4, v5, code, end = false, base32Str = "", index = 0, i2, start = 0, bytes = 0, length = str.length;
        if (str === "") {
          return base32Str;
        }
        do {
          blocks[0] = blocks[5];
          blocks[1] = blocks[6];
          blocks[2] = blocks[7];
          for (i2 = start; index < length && i2 < 5; ++index) {
            code = str.charCodeAt(index);
            if (code < 128) {
              blocks[i2++] = code;
            } else if (code < 2048) {
              blocks[i2++] = 192 | code >> 6;
              blocks[i2++] = 128 | code & 63;
            } else if (code < 55296 || code >= 57344) {
              blocks[i2++] = 224 | code >> 12;
              blocks[i2++] = 128 | code >> 6 & 63;
              blocks[i2++] = 128 | code & 63;
            } else {
              code = 65536 + ((code & 1023) << 10 | str.charCodeAt(++index) & 1023);
              blocks[i2++] = 240 | code >> 18;
              blocks[i2++] = 128 | code >> 12 & 63;
              blocks[i2++] = 128 | code >> 6 & 63;
              blocks[i2++] = 128 | code & 63;
            }
          }
          bytes += i2 - start;
          start = i2 - 5;
          if (index === length) {
            ++index;
          }
          if (index > length && i2 < 6) {
            end = true;
          }
          v1 = blocks[0];
          if (i2 > 4) {
            v2 = blocks[1];
            v3 = blocks[2];
            v4 = blocks[3];
            v5 = blocks[4];
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v4 >>> 7) & 31] + BASE32_ENCODE_CHAR[v4 >>> 2 & 31] + BASE32_ENCODE_CHAR[(v4 << 3 | v5 >>> 5) & 31] + BASE32_ENCODE_CHAR[v5 & 31];
          } else if (i2 === 1) {
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[v1 << 2 & 31] + "======";
          } else if (i2 === 2) {
            v2 = blocks[1];
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[v2 << 4 & 31] + "====";
          } else if (i2 === 3) {
            v2 = blocks[1];
            v3 = blocks[2];
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[v3 << 1 & 31] + "===";
          } else {
            v2 = blocks[1];
            v3 = blocks[2];
            v4 = blocks[3];
            base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v4 >>> 7) & 31] + BASE32_ENCODE_CHAR[v4 >>> 2 & 31] + BASE32_ENCODE_CHAR[v4 << 3 & 31] + "=";
          }
        } while (!end);
        return base32Str;
      };
      var encodeBytes = function(bytes) {
        var v1, v2, v3, v4, v5, base32Str = "", length = bytes.length;
        for (var i2 = 0, count = parseInt(length / 5) * 5; i2 < count; ) {
          v1 = bytes[i2++];
          v2 = bytes[i2++];
          v3 = bytes[i2++];
          v4 = bytes[i2++];
          v5 = bytes[i2++];
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v4 >>> 7) & 31] + BASE32_ENCODE_CHAR[v4 >>> 2 & 31] + BASE32_ENCODE_CHAR[(v4 << 3 | v5 >>> 5) & 31] + BASE32_ENCODE_CHAR[v5 & 31];
        }
        var remain = length - count;
        if (remain === 1) {
          v1 = bytes[i2];
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[v1 << 2 & 31] + "======";
        } else if (remain === 2) {
          v1 = bytes[i2++];
          v2 = bytes[i2];
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[v2 << 4 & 31] + "====";
        } else if (remain === 3) {
          v1 = bytes[i2++];
          v2 = bytes[i2++];
          v3 = bytes[i2];
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[v3 << 1 & 31] + "===";
        } else if (remain === 4) {
          v1 = bytes[i2++];
          v2 = bytes[i2++];
          v3 = bytes[i2++];
          v4 = bytes[i2];
          base32Str += BASE32_ENCODE_CHAR[v1 >>> 3] + BASE32_ENCODE_CHAR[(v1 << 2 | v2 >>> 6) & 31] + BASE32_ENCODE_CHAR[v2 >>> 1 & 31] + BASE32_ENCODE_CHAR[(v2 << 4 | v3 >>> 4) & 31] + BASE32_ENCODE_CHAR[(v3 << 1 | v4 >>> 7) & 31] + BASE32_ENCODE_CHAR[v4 >>> 2 & 31] + BASE32_ENCODE_CHAR[v4 << 3 & 31] + "=";
        }
        return base32Str;
      };
      var encode2 = function(input, asciiOnly) {
        var notString = typeof input !== "string";
        if (notString && input.constructor === ArrayBuffer) {
          input = new Uint8Array(input);
        }
        if (notString) {
          return encodeBytes(input);
        } else if (asciiOnly) {
          return encodeAscii(input);
        } else {
          return encodeUtf8(input);
        }
      };
      var decode3 = function(base32Str, asciiOnly) {
        if (!asciiOnly) {
          return toUtf8String(decodeAsBytes(base32Str));
        }
        if (base32Str === "") {
          return "";
        } else if (!/^[A-Z2-7=]+$/.test(base32Str)) {
          throw new Error("Invalid base32 characters");
        }
        var v1, v2, v3, v4, v5, v6, v7, v8, str = "", length = base32Str.indexOf("=");
        if (length === -1) {
          length = base32Str.length;
        }
        for (var i2 = 0, count = length >> 3 << 3; i2 < count; ) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v3 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v4 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v5 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v6 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v7 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v8 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255) + String.fromCharCode((v2 << 6 | v3 << 1 | v4 >>> 4) & 255) + String.fromCharCode((v4 << 4 | v5 >>> 1) & 255) + String.fromCharCode((v5 << 7 | v6 << 2 | v7 >>> 3) & 255) + String.fromCharCode((v7 << 5 | v8) & 255);
        }
        var remain = length - count;
        if (remain === 2) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255);
        } else if (remain === 4) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v3 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v4 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255) + String.fromCharCode((v2 << 6 | v3 << 1 | v4 >>> 4) & 255);
        } else if (remain === 5) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v3 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v4 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v5 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255) + String.fromCharCode((v2 << 6 | v3 << 1 | v4 >>> 4) & 255) + String.fromCharCode((v4 << 4 | v5 >>> 1) & 255);
        } else if (remain === 7) {
          v1 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v2 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v3 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v4 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v5 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v6 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          v7 = BASE32_DECODE_CHAR[base32Str.charAt(i2++)];
          str += String.fromCharCode((v1 << 3 | v2 >>> 2) & 255) + String.fromCharCode((v2 << 6 | v3 << 1 | v4 >>> 4) & 255) + String.fromCharCode((v4 << 4 | v5 >>> 1) & 255) + String.fromCharCode((v5 << 7 | v6 << 2 | v7 >>> 3) & 255);
        }
        return str;
      };
      var exports2 = {
        encode: encode2,
        decode: decode3
      };
      decode3.asBytes = decodeAsBytes;
      if (COMMON_JS) {
        module.exports = exports2;
      } else {
        root.base32 = exports2;
        if (AMD) {
          define(function() {
            return exports2;
          });
        }
      }
    })();
  }
});

// node_modules/@walletconnect/browser-utils/dist/esm/browser.js
var windowMetadata = __toESM(require_cjs2());
var windowGetters = __toESM(require_cjs());

// node_modules/detect-browser/es/index.js
var __spreadArrays = function() {
  for (var s2 = 0, i2 = 0, il = arguments.length; i2 < il; i2++) s2 += arguments[i2].length;
  for (var r3 = Array(s2), k2 = 0, i2 = 0; i2 < il; i2++)
    for (var a2 = arguments[i2], j2 = 0, jl = a2.length; j2 < jl; j2++, k2++)
      r3[k2] = a2[j2];
  return r3;
};
var BrowserInfo = (
  /** @class */
  /* @__PURE__ */ (function() {
    function BrowserInfo2(name, version, os) {
      this.name = name;
      this.version = version;
      this.os = os;
      this.type = "browser";
    }
    return BrowserInfo2;
  })()
);
var NodeInfo = (
  /** @class */
  /* @__PURE__ */ (function() {
    function NodeInfo2(version) {
      this.version = version;
      this.type = "node";
      this.name = "node";
      this.os = process.platform;
    }
    return NodeInfo2;
  })()
);
var SearchBotDeviceInfo = (
  /** @class */
  /* @__PURE__ */ (function() {
    function SearchBotDeviceInfo2(name, version, os, bot) {
      this.name = name;
      this.version = version;
      this.os = os;
      this.bot = bot;
      this.type = "bot-device";
    }
    return SearchBotDeviceInfo2;
  })()
);
var BotInfo = (
  /** @class */
  /* @__PURE__ */ (function() {
    function BotInfo2() {
      this.type = "bot";
      this.bot = true;
      this.name = "bot";
      this.version = null;
      this.os = null;
    }
    return BotInfo2;
  })()
);
var ReactNativeInfo = (
  /** @class */
  /* @__PURE__ */ (function() {
    function ReactNativeInfo2() {
      this.type = "react-native";
      this.name = "react-native";
      this.version = null;
      this.os = null;
    }
    return ReactNativeInfo2;
  })()
);
var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
var SEARCHBOT_OS_REGEX = /(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
var REQUIRED_VERSION_PARTS = 3;
var userAgentRules = [
  ["aol", /AOLShield\/([0-9\._]+)/],
  ["edge", /Edge\/([0-9\._]+)/],
  ["edge-ios", /EdgiOS\/([0-9\._]+)/],
  ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
  ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
  ["samsung", /SamsungBrowser\/([0-9\.]+)/],
  ["silk", /\bSilk\/([0-9._-]+)\b/],
  ["miui", /MiuiBrowser\/([0-9\.]+)$/],
  ["beaker", /BeakerBrowser\/([0-9\.]+)/],
  ["edge-chromium", /EdgA?\/([0-9\.]+)/],
  [
    "chromium-webview",
    /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
  ],
  ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
  ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
  ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
  ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
  ["fxios", /FxiOS\/([0-9\.]+)/],
  ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
  ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
  ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
  ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
  ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
  ["ie", /MSIE\s(7\.0)/],
  ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
  ["android", /Android\s([0-9\.]+)/],
  ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
  ["safari", /Version\/([0-9\._]+).*Safari/],
  ["facebook", /FBAV\/([0-9\.]+)/],
  ["instagram", /Instagram\s([0-9\.]+)/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
  ["searchbot", SEARCHBOX_UA_REGEX]
];
var operatingSystemRules = [
  ["iOS", /iP(hone|od|ad)/],
  ["Android OS", /Android/],
  ["BlackBerry OS", /BlackBerry|BB10/],
  ["Windows Mobile", /IEMobile/],
  ["Amazon OS", /Kindle/],
  ["Windows 3.11", /Win16/],
  ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
  ["Windows 98", /(Windows 98)|(Win98)/],
  ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
  ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
  ["Windows Server 2003", /(Windows NT 5.2)/],
  ["Windows Vista", /(Windows NT 6.0)/],
  ["Windows 7", /(Windows NT 6.1)/],
  ["Windows 8", /(Windows NT 6.2)/],
  ["Windows 8.1", /(Windows NT 6.3)/],
  ["Windows 10", /(Windows NT 10.0)/],
  ["Windows ME", /Windows ME/],
  ["Open BSD", /OpenBSD/],
  ["Sun OS", /SunOS/],
  ["Chrome OS", /CrOS/],
  ["Linux", /(Linux)|(X11)/],
  ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
  ["QNX", /QNX/],
  ["BeOS", /BeOS/],
  ["OS/2", /OS\/2/]
];
function detect(userAgent) {
  if (!!userAgent) {
    return parseUserAgent(userAgent);
  }
  if (typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative") {
    return new ReactNativeInfo();
  }
  if (typeof navigator !== "undefined") {
    return parseUserAgent(navigator.userAgent);
  }
  return getNodeVersion();
}
function matchUserAgent(ua) {
  return ua !== "" && userAgentRules.reduce(function(matched, _a) {
    var browser = _a[0], regex = _a[1];
    if (matched) {
      return matched;
    }
    var uaMatch = regex.exec(ua);
    return !!uaMatch && [browser, uaMatch];
  }, false);
}
function parseUserAgent(ua) {
  var matchedRule = matchUserAgent(ua);
  if (!matchedRule) {
    return null;
  }
  var name = matchedRule[0], match = matchedRule[1];
  if (name === "searchbot") {
    return new BotInfo();
  }
  var versionParts = match[1] && match[1].split(/[._]/).slice(0, 3);
  if (versionParts) {
    if (versionParts.length < REQUIRED_VERSION_PARTS) {
      versionParts = __spreadArrays(versionParts, createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length));
    }
  } else {
    versionParts = [];
  }
  var version = versionParts.join(".");
  var os = detectOS(ua);
  var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua);
  if (searchBotMatch && searchBotMatch[1]) {
    return new SearchBotDeviceInfo(name, version, os, searchBotMatch[1]);
  }
  return new BrowserInfo(name, version, os);
}
function detectOS(ua) {
  for (var ii = 0, count = operatingSystemRules.length; ii < count; ii++) {
    var _a = operatingSystemRules[ii], os = _a[0], regex = _a[1];
    var match = regex.exec(ua);
    if (match) {
      return os;
    }
  }
  return null;
}
function getNodeVersion() {
  var isNode4 = typeof process !== "undefined" && process.version;
  return isNode4 ? new NodeInfo(process.version.slice(1)) : null;
}
function createVersionParts(count) {
  var output = [];
  for (var ii = 0; ii < count; ii++) {
    output.push("0");
  }
  return output;
}

// node_modules/@walletconnect/browser-utils/dist/esm/browser.js
function detectEnv(userAgent) {
  return detect(userAgent);
}
function detectOS2() {
  const env3 = detectEnv();
  return env3 && env3.os ? env3.os : void 0;
}
function isAndroid() {
  const os = detectOS2();
  return os ? os.toLowerCase().includes("android") : false;
}
function isIOS() {
  const os = detectOS2();
  return os ? os.toLowerCase().includes("ios") || os.toLowerCase().includes("mac") && navigator.maxTouchPoints > 1 : false;
}
function isMobile() {
  const os = detectOS2();
  return os ? isAndroid() || isIOS() : false;
}
function isNode() {
  const env3 = detectEnv();
  const result = env3 && env3.name ? env3.name.toLowerCase() === "node" : false;
  return result;
}
function isBrowser() {
  const result = !isNode() && !!getNavigator2();
  return result;
}
var getNavigator2 = windowGetters.getNavigator;
var getLocation2 = windowGetters.getLocation;
var getLocalStorage2 = windowGetters.getLocalStorage;
function getClientMeta() {
  return windowMetadata.getWindowMetadata();
}

// node_modules/@walletconnect/safe-json/dist/esm/index.js
function safeJsonParse(value) {
  if (typeof value !== "string") {
    throw new Error(`Cannot safe json parse value of type ${typeof value}`);
  }
  try {
    return JSON.parse(value);
  } catch (_a) {
    return value;
  }
}
function safeJsonStringify(value) {
  return typeof value === "string" ? value : JSON.stringify(value);
}

// node_modules/@walletconnect/browser-utils/dist/esm/json.js
var safeJsonParse2 = safeJsonParse;
var safeJsonStringify2 = safeJsonStringify;

// node_modules/@walletconnect/browser-utils/dist/esm/local.js
function setLocal(key, data) {
  const raw = safeJsonStringify2(data);
  const local = getLocalStorage2();
  if (local) {
    local.setItem(key, raw);
  }
}
function getLocal(key) {
  let data = null;
  let raw = null;
  const local = getLocalStorage2();
  if (local) {
    raw = local.getItem(key);
  }
  data = raw ? safeJsonParse2(raw) : raw;
  return data;
}
function removeLocal(key) {
  const local = getLocalStorage2();
  if (local) {
    local.removeItem(key);
  }
}

// node_modules/@walletconnect/browser-utils/dist/esm/mobile.js
var mobileLinkChoiceKey = "WALLETCONNECT_DEEPLINK_CHOICE";

// node_modules/@walletconnect/utils/dist/esm/constants.js
var reservedEvents = [
  "session_request",
  "session_update",
  "exchange_key",
  "connect",
  "disconnect",
  "display_uri",
  "modal_closed",
  "transport_open",
  "transport_close",
  "transport_error"
];
var signingMethods = [
  "eth_sendTransaction",
  "eth_signTransaction",
  "eth_sign",
  "eth_signTypedData",
  "eth_signTypedData_v1",
  "eth_signTypedData_v2",
  "eth_signTypedData_v3",
  "eth_signTypedData_v4",
  "personal_sign",
  "wallet_addEthereumChain",
  "wallet_switchEthereumChain",
  "wallet_getPermissions",
  "wallet_requestPermissions",
  "wallet_registerOnboarding",
  "wallet_watchAsset",
  "wallet_scanQRCode"
];

// node_modules/@walletconnect/utils/dist/esm/encoding.js
var import_bn = __toESM(require_bn());

// node_modules/@walletconnect/encoding/dist/esm/index.js
var import_is_typedarray = __toESM(require_is_typedarray());
var import_typedarray_to_buffer = __toESM(require_typedarray_to_buffer());
var ENC_HEX = "hex";
var ENC_UTF8 = "utf8";
var STRING_ZERO = "0";
function bufferToArray(buf) {
  return new Uint8Array(buf);
}
function bufferToHex(buf, prefixed = false) {
  const hex = buf.toString(ENC_HEX);
  return prefixed ? addHexPrefix(hex) : hex;
}
function bufferToUtf8(buf) {
  return buf.toString(ENC_UTF8);
}
function arrayToBuffer(arr) {
  return (0, import_typedarray_to_buffer.default)(arr);
}
function arrayToHex(arr, prefixed = false) {
  return bufferToHex(arrayToBuffer(arr), prefixed);
}
function arrayToUtf8(arr) {
  return bufferToUtf8(arrayToBuffer(arr));
}
function hexToBuffer(hex) {
  return Buffer.from(removeHexPrefix(hex), ENC_HEX);
}
function hexToArray(hex) {
  return bufferToArray(hexToBuffer(hex));
}
function utf8ToBuffer(utf8) {
  return Buffer.from(utf8, ENC_UTF8);
}
function utf8ToArray(utf8) {
  return bufferToArray(utf8ToBuffer(utf8));
}
function utf8ToHex(utf8, prefixed = false) {
  return bufferToHex(utf8ToBuffer(utf8), prefixed);
}
function isHexString(str, length) {
  if (typeof str !== "string" || !str.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (length && str.length !== 2 + 2 * length) {
    return false;
  }
  return true;
}
function concatArrays(...args) {
  let result = [];
  args.forEach((arg) => result = result.concat(Array.from(arg)));
  return new Uint8Array([...result]);
}
function calcByteLength(length, byteSize = 8) {
  const remainder = length % byteSize;
  return remainder ? (length - remainder) / byteSize * byteSize + byteSize : length;
}
function sanitizeBytes(str, byteSize = 8, padding = STRING_ZERO) {
  return padLeft(str, calcByteLength(str.length, byteSize), padding);
}
function padLeft(str, length, padding = STRING_ZERO) {
  return padString(str, length, true, padding);
}
function removeHexPrefix(hex) {
  return hex.replace(/^0x/, "");
}
function addHexPrefix(hex) {
  return hex.startsWith("0x") ? hex : `0x${hex}`;
}
function sanitizeHex(hex) {
  hex = removeHexPrefix(hex);
  hex = sanitizeBytes(hex, 2);
  if (hex) {
    hex = addHexPrefix(hex);
  }
  return hex;
}
function removeHexLeadingZeros(hex) {
  const prefixed = hex.startsWith("0x");
  hex = removeHexPrefix(hex);
  hex = hex.startsWith(STRING_ZERO) ? hex.substring(1) : hex;
  return prefixed ? addHexPrefix(hex) : hex;
}
function padString(str, length, left, padding = STRING_ZERO) {
  const diff = length - str.length;
  let result = str;
  if (diff > 0) {
    const pad = padding.repeat(diff);
    result = left ? pad + str : str + pad;
  }
  return result;
}

// node_modules/@walletconnect/utils/dist/esm/encoding.js
function convertArrayBufferToBuffer(arrBuf) {
  return arrayToBuffer(new Uint8Array(arrBuf));
}
function convertArrayBufferToHex(arrBuf, noPrefix) {
  return arrayToHex(new Uint8Array(arrBuf), !noPrefix);
}
function convertBufferToArrayBuffer(buf) {
  return bufferToArray(buf).buffer;
}
function convertUtf8ToBuffer(utf8) {
  return utf8ToBuffer(utf8);
}
function convertUtf8ToHex(utf8, noPrefix) {
  return utf8ToHex(utf8, !noPrefix);
}
function convertHexToArrayBuffer(hex) {
  return hexToArray(hex).buffer;
}
function convertNumberToHex(num, noPrefix) {
  const hex = removeHexPrefix(sanitizeHex(new import_bn.default(num).toString(16)));
  return noPrefix ? hex : addHexPrefix(hex);
}

// node_modules/@walletconnect/utils/dist/esm/ethereum.js
var import_js_sha3 = __toESM(require_sha3());

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/index.js
var esm_exports3 = {};
__export(esm_exports3, {
  DEFAULT_ERROR: () => DEFAULT_ERROR,
  IBaseJsonRpcProvider: () => n,
  IEvents: () => e,
  IJsonRpcConnection: () => o,
  IJsonRpcProvider: () => r,
  INTERNAL_ERROR: () => INTERNAL_ERROR,
  INVALID_PARAMS: () => INVALID_PARAMS,
  INVALID_REQUEST: () => INVALID_REQUEST,
  METHOD_NOT_FOUND: () => METHOD_NOT_FOUND,
  PARSE_ERROR: () => PARSE_ERROR,
  RESERVED_ERROR_CODES: () => RESERVED_ERROR_CODES,
  SERVER_ERROR: () => SERVER_ERROR,
  SERVER_ERROR_CODE_RANGE: () => SERVER_ERROR_CODE_RANGE,
  STANDARD_ERROR_MAP: () => STANDARD_ERROR_MAP,
  formatErrorMessage: () => formatErrorMessage,
  formatJsonRpcError: () => formatJsonRpcError,
  formatJsonRpcRequest: () => formatJsonRpcRequest,
  formatJsonRpcResult: () => formatJsonRpcResult,
  getBigIntRpcId: () => getBigIntRpcId,
  getError: () => getError,
  getErrorByCode: () => getErrorByCode,
  isHttpUrl: () => isHttpUrl,
  isJsonRpcError: () => isJsonRpcError,
  isJsonRpcPayload: () => isJsonRpcPayload,
  isJsonRpcRequest: () => isJsonRpcRequest,
  isJsonRpcResponse: () => isJsonRpcResponse,
  isJsonRpcResult: () => isJsonRpcResult,
  isJsonRpcValidationInvalid: () => isJsonRpcValidationInvalid,
  isLocalhostUrl: () => isLocalhostUrl,
  isNodeJs: () => isNodeJs,
  isReservedErrorCode: () => isReservedErrorCode,
  isServerErrorCode: () => isServerErrorCode,
  isValidDefaultRoute: () => isValidDefaultRoute,
  isValidErrorCode: () => isValidErrorCode,
  isValidLeadingWildcardRoute: () => isValidLeadingWildcardRoute,
  isValidRoute: () => isValidRoute,
  isValidTrailingWildcardRoute: () => isValidTrailingWildcardRoute,
  isValidWildcardRoute: () => isValidWildcardRoute,
  isWsUrl: () => isWsUrl,
  parseConnectionError: () => parseConnectionError,
  payloadId: () => payloadId,
  validateJsonRpcError: () => validateJsonRpcError
});

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/constants.js
var PARSE_ERROR = "PARSE_ERROR";
var INVALID_REQUEST = "INVALID_REQUEST";
var METHOD_NOT_FOUND = "METHOD_NOT_FOUND";
var INVALID_PARAMS = "INVALID_PARAMS";
var INTERNAL_ERROR = "INTERNAL_ERROR";
var SERVER_ERROR = "SERVER_ERROR";
var RESERVED_ERROR_CODES = [-32700, -32600, -32601, -32602, -32603];
var SERVER_ERROR_CODE_RANGE = [-32e3, -32099];
var STANDARD_ERROR_MAP = {
  [PARSE_ERROR]: { code: -32700, message: "Parse error" },
  [INVALID_REQUEST]: { code: -32600, message: "Invalid Request" },
  [METHOD_NOT_FOUND]: { code: -32601, message: "Method not found" },
  [INVALID_PARAMS]: { code: -32602, message: "Invalid params" },
  [INTERNAL_ERROR]: { code: -32603, message: "Internal error" },
  [SERVER_ERROR]: { code: -32e3, message: "Server error" }
};
var DEFAULT_ERROR = SERVER_ERROR;

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/error.js
function isServerErrorCode(code) {
  return code <= SERVER_ERROR_CODE_RANGE[0] && code >= SERVER_ERROR_CODE_RANGE[1];
}
function isReservedErrorCode(code) {
  return RESERVED_ERROR_CODES.includes(code);
}
function isValidErrorCode(code) {
  return typeof code === "number";
}
function getError(type) {
  if (!Object.keys(STANDARD_ERROR_MAP).includes(type)) {
    return STANDARD_ERROR_MAP[DEFAULT_ERROR];
  }
  return STANDARD_ERROR_MAP[type];
}
function getErrorByCode(code) {
  const match = Object.values(STANDARD_ERROR_MAP).find((e2) => e2.code === code);
  if (!match) {
    return STANDARD_ERROR_MAP[DEFAULT_ERROR];
  }
  return match;
}
function validateJsonRpcError(response) {
  if (typeof response.error.code === "undefined") {
    return { valid: false, error: "Missing code for JSON-RPC error" };
  }
  if (typeof response.error.message === "undefined") {
    return { valid: false, error: "Missing message for JSON-RPC error" };
  }
  if (!isValidErrorCode(response.error.code)) {
    return {
      valid: false,
      error: `Invalid error code type for JSON-RPC: ${response.error.code}`
    };
  }
  if (isReservedErrorCode(response.error.code)) {
    const error = getErrorByCode(response.error.code);
    if (error.message !== STANDARD_ERROR_MAP[DEFAULT_ERROR].message && response.error.message === error.message) {
      return {
        valid: false,
        error: `Invalid error code message for JSON-RPC: ${response.error.code}`
      };
    }
  }
  return { valid: true };
}
function parseConnectionError(e2, url, type) {
  return e2.message.includes("getaddrinfo ENOTFOUND") || e2.message.includes("connect ECONNREFUSED") ? new Error(`Unavailable ${type} RPC url at ${url}`) : e2;
}

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/env.js
var env_exports = {};
__export(env_exports, {
  isNodeJs: () => isNodeJs
});
var import_environment = __toESM(require_cjs3());
__reExport(env_exports, __toESM(require_cjs3()));
var isNodeJs = import_environment.isNode;

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/index.js
__reExport(esm_exports3, env_exports);

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/format.js
function payloadId(entropy = 3) {
  const date = Date.now() * Math.pow(10, entropy);
  const extra = Math.floor(Math.random() * Math.pow(10, entropy));
  return date + extra;
}
function getBigIntRpcId(entropy = 6) {
  return BigInt(payloadId(entropy));
}
function formatJsonRpcRequest(method, params, id) {
  return {
    id: id || payloadId(),
    jsonrpc: "2.0",
    method,
    params
  };
}
function formatJsonRpcResult(id, result) {
  return {
    id,
    jsonrpc: "2.0",
    result
  };
}
function formatJsonRpcError(id, error, data) {
  return {
    id,
    jsonrpc: "2.0",
    error: formatErrorMessage(error, data)
  };
}
function formatErrorMessage(error, data) {
  if (typeof error === "undefined") {
    return getError(INTERNAL_ERROR);
  }
  if (typeof error === "string") {
    error = Object.assign(Object.assign({}, getError(SERVER_ERROR)), { message: error });
  }
  if (typeof data !== "undefined") {
    error.data = data;
  }
  if (isReservedErrorCode(error.code)) {
    error = getErrorByCode(error.code);
  }
  return error;
}

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/routing.js
function isValidRoute(route) {
  if (route.includes("*")) {
    return isValidWildcardRoute(route);
  }
  if (/\W/g.test(route)) {
    return false;
  }
  return true;
}
function isValidDefaultRoute(route) {
  return route === "*";
}
function isValidWildcardRoute(route) {
  if (isValidDefaultRoute(route)) {
    return true;
  }
  if (!route.includes("*")) {
    return false;
  }
  if (route.split("*").length !== 2) {
    return false;
  }
  if (route.split("*").filter((x2) => x2.trim() === "").length !== 1) {
    return false;
  }
  return true;
}
function isValidLeadingWildcardRoute(route) {
  return !isValidDefaultRoute(route) && isValidWildcardRoute(route) && !route.split("*")[0].trim();
}
function isValidTrailingWildcardRoute(route) {
  return !isValidDefaultRoute(route) && isValidWildcardRoute(route) && !route.split("*")[1].trim();
}

// node_modules/@walletconnect/jsonrpc-types/dist/index.es.js
var e = class {
};
var o = class extends e {
  constructor(c2) {
    super();
  }
};
var n = class extends e {
  constructor() {
    super();
  }
};
var r = class extends n {
  constructor(c2) {
    super();
  }
};

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/url.js
var HTTP_REGEX = "^https?:";
var WS_REGEX = "^wss?:";
function getUrlProtocol(url) {
  const matches = url.match(new RegExp(/^\w+:/, "gi"));
  if (!matches || !matches.length)
    return;
  return matches[0];
}
function matchRegexProtocol(url, regex) {
  const protocol = getUrlProtocol(url);
  if (typeof protocol === "undefined")
    return false;
  return new RegExp(regex).test(protocol);
}
function isHttpUrl(url) {
  return matchRegexProtocol(url, HTTP_REGEX);
}
function isWsUrl(url) {
  return matchRegexProtocol(url, WS_REGEX);
}
function isLocalhostUrl(url) {
  return new RegExp("wss?://localhost(:d{2,5})?").test(url);
}

// node_modules/@walletconnect/jsonrpc-utils/dist/esm/validators.js
function isJsonRpcPayload(payload) {
  return typeof payload === "object" && "id" in payload && "jsonrpc" in payload && payload.jsonrpc === "2.0";
}
function isJsonRpcRequest(payload) {
  return isJsonRpcPayload(payload) && "method" in payload;
}
function isJsonRpcResponse(payload) {
  return isJsonRpcPayload(payload) && (isJsonRpcResult(payload) || isJsonRpcError(payload));
}
function isJsonRpcResult(payload) {
  return "result" in payload;
}
function isJsonRpcError(payload) {
  return "error" in payload;
}
function isJsonRpcValidationInvalid(validation) {
  return "error" in validation && validation.valid === false;
}

// node_modules/@walletconnect/utils/dist/esm/misc.js
function sanitizeHex2(hex) {
  return sanitizeHex(hex);
}
function removeHexLeadingZeros2(hex) {
  return removeHexLeadingZeros(addHexPrefix(hex));
}
var payloadId2 = payloadId;
function uuid() {
  const result = ((a2, b2) => {
    for (b2 = a2 = ""; a2++ < 36; b2 += a2 * 51 & 52 ? (a2 ^ 15 ? 8 ^ Math.random() * (a2 ^ 20 ? 16 : 4) : 4).toString(16) : "-") {
    }
    return b2;
  })();
  return result;
}

// node_modules/@walletconnect/utils/dist/esm/validators.js
function isEmptyString(value) {
  return value === "" || typeof value === "string" && value.trim() === "";
}
function isEmptyArray(array) {
  return !(array && array.length);
}
function isHexString2(value, length) {
  return isHexString(value, length);
}
function isJsonRpcRequest2(object) {
  return typeof object.method !== "undefined";
}
function isJsonRpcResponseSuccess(object) {
  return typeof object.result !== "undefined";
}
function isJsonRpcResponseError(object) {
  return typeof object.error !== "undefined";
}
function isInternalEvent(object) {
  return typeof object.event !== "undefined";
}
function isReservedEvent(event) {
  return reservedEvents.includes(event) || event.startsWith("wc_");
}
function isSilentPayload(request) {
  if (request.method.startsWith("wc_")) {
    return true;
  }
  if (signingMethods.includes(request.method)) {
    return false;
  }
  return true;
}

// node_modules/@walletconnect/utils/dist/esm/ethereum.js
function toChecksumAddress(address) {
  address = removeHexPrefix(address.toLowerCase());
  const hash = removeHexPrefix((0, import_js_sha3.keccak_256)(convertUtf8ToBuffer(address)));
  let checksum = "";
  for (let i2 = 0; i2 < address.length; i2++) {
    if (parseInt(hash[i2], 16) > 7) {
      checksum += address[i2].toUpperCase();
    } else {
      checksum += address[i2];
    }
  }
  return addHexPrefix(checksum);
}
var isValidAddress = (address) => {
  if (!address) {
    return false;
  } else if (address.toLowerCase().substring(0, 2) !== "0x") {
    return false;
  } else if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) {
    return false;
  } else if (/^(0x)?[0-9a-f]{40}$/.test(address) || /^(0x)?[0-9A-F]{40}$/.test(address)) {
    return true;
  } else {
    return address === toChecksumAddress(address);
  }
};
function parsePersonalSign(params) {
  if (!isEmptyArray(params) && !isHexString2(params[0])) {
    params[0] = convertUtf8ToHex(params[0]);
  }
  return params;
}
function parseTransactionData(txData) {
  if (typeof txData.type !== "undefined" && txData.type !== "0")
    return txData;
  if (typeof txData.from === "undefined" || !isValidAddress(txData.from)) {
    throw new Error(`Transaction object must include a valid 'from' value.`);
  }
  function parseHexValues(value) {
    let result = value;
    if (typeof value === "number" || typeof value === "string" && !isEmptyString(value)) {
      if (!isHexString2(value)) {
        result = convertNumberToHex(value);
      } else if (typeof value === "string") {
        result = sanitizeHex2(value);
      }
    }
    if (typeof result === "string") {
      result = removeHexLeadingZeros2(result);
    }
    return result;
  }
  const txDataRPC = {
    from: sanitizeHex2(txData.from),
    to: typeof txData.to === "undefined" ? void 0 : sanitizeHex2(txData.to),
    gasPrice: typeof txData.gasPrice === "undefined" ? "" : parseHexValues(txData.gasPrice),
    gas: typeof txData.gas === "undefined" ? typeof txData.gasLimit === "undefined" ? "" : parseHexValues(txData.gasLimit) : parseHexValues(txData.gas),
    value: typeof txData.value === "undefined" ? "" : parseHexValues(txData.value),
    nonce: typeof txData.nonce === "undefined" ? "" : parseHexValues(txData.nonce),
    data: typeof txData.data === "undefined" ? "" : sanitizeHex2(txData.data) || "0x"
  };
  const prunable = ["gasPrice", "gas", "value", "nonce"];
  Object.keys(txDataRPC).forEach((key) => {
    if ((typeof txDataRPC[key] === "undefined" || typeof txDataRPC[key] === "string" && !txDataRPC[key].trim().length) && prunable.includes(key)) {
      delete txDataRPC[key];
    }
  });
  return txDataRPC;
}

// node_modules/@walletconnect/utils/dist/esm/payload.js
function formatRpcError(error) {
  const message = error.message || "Failed or Rejected Request";
  let code = -32e3;
  if (error && !error.code) {
    switch (message) {
      case "Parse error":
        code = -32700;
        break;
      case "Invalid request":
        code = -32600;
        break;
      case "Method not found":
        code = -32601;
        break;
      case "Invalid params":
        code = -32602;
        break;
      case "Internal error":
        code = -32603;
        break;
      default:
        code = -32e3;
        break;
    }
  }
  const result = {
    code,
    message
  };
  if (error.data) {
    result.data = error.data;
  }
  return result;
}

// node_modules/@walletconnect/utils/dist/esm/url.js
var queryStringUtils = __toESM(require_query_string());
function getQueryString(url) {
  const pathEnd = url.indexOf("?") !== -1 ? url.indexOf("?") : void 0;
  const queryString = typeof pathEnd !== "undefined" ? url.substr(pathEnd) : "";
  return queryString;
}
function appendToQueryString(queryString, newQueryParams) {
  let queryParams = parseQueryString(queryString);
  queryParams = Object.assign(Object.assign({}, queryParams), newQueryParams);
  queryString = formatQueryString(queryParams);
  return queryString;
}
function parseQueryString(queryString) {
  return queryStringUtils.parse(queryString);
}
function formatQueryString(queryParams) {
  return queryStringUtils.stringify(queryParams);
}

// node_modules/@walletconnect/utils/dist/esm/session.js
function isWalletConnectSession(object) {
  return typeof object.bridge !== "undefined";
}
function parseWalletConnectUri(str) {
  const pathStart = str.indexOf(":");
  const pathEnd = str.indexOf("?") !== -1 ? str.indexOf("?") : void 0;
  const protocol = str.substring(0, pathStart);
  const path = str.substring(pathStart + 1, pathEnd);
  function parseRequiredParams(path2) {
    const separator = "@";
    const values = path2.split(separator);
    const requiredParams2 = {
      handshakeTopic: values[0],
      version: parseInt(values[1], 10)
    };
    return requiredParams2;
  }
  const requiredParams = parseRequiredParams(path);
  const queryString = typeof pathEnd !== "undefined" ? str.substr(pathEnd) : "";
  function parseQueryParams(queryString2) {
    const result2 = parseQueryString(queryString2);
    const parameters = {
      key: result2.key || "",
      bridge: result2.bridge || ""
    };
    return parameters;
  }
  const queryParams = parseQueryParams(queryString);
  const result = Object.assign(Object.assign({ protocol }, requiredParams), queryParams);
  return result;
}

// node_modules/@walletconnect/socket-transport/dist/esm/network.js
var NetworkMonitor = class {
  constructor() {
    this._eventEmitters = [];
    if (typeof window !== "undefined" && typeof window.addEventListener !== "undefined") {
      window.addEventListener("online", () => this.trigger("online"));
      window.addEventListener("offline", () => this.trigger("offline"));
    }
  }
  on(event, callback) {
    this._eventEmitters.push({
      event,
      callback
    });
  }
  trigger(event) {
    let eventEmitters = [];
    if (event) {
      eventEmitters = this._eventEmitters.filter((eventEmitter) => eventEmitter.event === event);
    }
    eventEmitters.forEach((eventEmitter) => {
      eventEmitter.callback();
    });
  }
};
var network_default = NetworkMonitor;

// node_modules/@walletconnect/socket-transport/dist/esm/index.js
var WS = typeof global.WebSocket !== "undefined" ? global.WebSocket : require_browser();
var SocketTransport = class {
  constructor(opts) {
    this.opts = opts;
    this._queue = [];
    this._events = [];
    this._subscriptions = [];
    this._protocol = opts.protocol;
    this._version = opts.version;
    this._url = "";
    this._netMonitor = null;
    this._socket = null;
    this._nextSocket = null;
    this._subscriptions = opts.subscriptions || [];
    this._netMonitor = opts.netMonitor || new network_default();
    if (!opts.url || typeof opts.url !== "string") {
      throw new Error("Missing or invalid WebSocket url");
    }
    this._url = opts.url;
    this._netMonitor.on("online", () => this._socketCreate());
  }
  set readyState(value) {
  }
  get readyState() {
    return this._socket ? this._socket.readyState : -1;
  }
  set connecting(value) {
  }
  get connecting() {
    return this.readyState === 0;
  }
  set connected(value) {
  }
  get connected() {
    return this.readyState === 1;
  }
  set closing(value) {
  }
  get closing() {
    return this.readyState === 2;
  }
  set closed(value) {
  }
  get closed() {
    return this.readyState === 3;
  }
  open() {
    this._socketCreate();
  }
  close() {
    this._socketClose();
  }
  send(message, topic, silent) {
    if (!topic || typeof topic !== "string") {
      throw new Error("Missing or invalid topic field");
    }
    this._socketSend({
      topic,
      type: "pub",
      payload: message,
      silent: !!silent
    });
  }
  subscribe(topic) {
    this._socketSend({
      topic,
      type: "sub",
      payload: "",
      silent: true
    });
  }
  on(event, callback) {
    this._events.push({ event, callback });
  }
  _socketCreate() {
    if (this._nextSocket) {
      return;
    }
    const url = getWebSocketUrl(this._url, this._protocol, this._version);
    this._nextSocket = new WS(url);
    if (!this._nextSocket) {
      throw new Error("Failed to create socket");
    }
    this._nextSocket.onmessage = (event) => this._socketReceive(event);
    this._nextSocket.onopen = () => this._socketOpen();
    this._nextSocket.onerror = (event) => this._socketError(event);
    this._nextSocket.onclose = () => {
      setTimeout(() => {
        this._nextSocket = null;
        this._socketCreate();
      }, 1e3);
    };
  }
  _socketOpen() {
    this._socketClose();
    this._socket = this._nextSocket;
    this._nextSocket = null;
    this._queueSubscriptions();
    this._pushQueue();
  }
  _socketClose() {
    if (this._socket) {
      this._socket.onclose = () => {
      };
      this._socket.close();
    }
  }
  _socketSend(socketMessage) {
    const message = JSON.stringify(socketMessage);
    if (this._socket && this._socket.readyState === 1) {
      this._socket.send(message);
    } else {
      this._setToQueue(socketMessage);
      this._socketCreate();
    }
  }
  async _socketReceive(event) {
    let socketMessage;
    try {
      socketMessage = JSON.parse(event.data);
    } catch (error) {
      return;
    }
    this._socketSend({
      topic: socketMessage.topic,
      type: "ack",
      payload: "",
      silent: true
    });
    if (this._socket && this._socket.readyState === 1) {
      const events = this._events.filter((event2) => event2.event === "message");
      if (events && events.length) {
        events.forEach((event2) => event2.callback(socketMessage));
      }
    }
  }
  _socketError(e2) {
    const events = this._events.filter((event) => event.event === "error");
    if (events && events.length) {
      events.forEach((event) => event.callback(e2));
    }
  }
  _queueSubscriptions() {
    const subscriptions = this._subscriptions;
    subscriptions.forEach((topic) => this._queue.push({
      topic,
      type: "sub",
      payload: "",
      silent: true
    }));
    this._subscriptions = this.opts.subscriptions || [];
  }
  _setToQueue(socketMessage) {
    this._queue.push(socketMessage);
  }
  _pushQueue() {
    const queue = this._queue;
    queue.forEach((socketMessage) => this._socketSend(socketMessage));
    this._queue = [];
  }
};
function getWebSocketUrl(_url, protocol, version) {
  var _a, _b;
  const url = _url.startsWith("https") ? _url.replace("https", "wss") : _url.startsWith("http") ? _url.replace("http", "ws") : _url;
  const splitUrl = url.split("?");
  const params = isBrowser() ? {
    protocol,
    version,
    env: "browser",
    host: ((_a = getLocation2()) === null || _a === void 0 ? void 0 : _a.host) || ""
  } : {
    protocol,
    version,
    env: ((_b = detectEnv()) === null || _b === void 0 ? void 0 : _b.name) || ""
  };
  const queryString = appendToQueryString(getQueryString(splitUrl[1] || ""), params);
  return splitUrl[0] + "?" + queryString;
}
var esm_default = SocketTransport;

// node_modules/@walletconnect/core/dist/esm/errors.js
var ERROR_SESSION_CONNECTED = "Session currently connected";
var ERROR_SESSION_DISCONNECTED = "Session currently disconnected";
var ERROR_SESSION_REJECTED = "Session Rejected";
var ERROR_MISSING_JSON_RPC = "Missing JSON RPC response";
var ERROR_MISSING_RESULT = `JSON-RPC success response must include "result" field`;
var ERROR_MISSING_ERROR = `JSON-RPC error response must include "error" field`;
var ERROR_MISSING_METHOD = `JSON RPC request must have valid "method" value`;
var ERROR_MISSING_ID = `JSON RPC request must have valid "id" value`;
var ERROR_MISSING_REQUIRED = "Missing one of the required parameters: bridge / uri / session";
var ERROR_INVALID_RESPONSE = "JSON RPC response format is invalid";
var ERROR_INVALID_URI = "URI format is invalid";
var ERROR_QRCODE_MODAL_NOT_PROVIDED = "QRCode Modal not provided";
var ERROR_QRCODE_MODAL_USER_CLOSED = "User close QRCode Modal";

// node_modules/@walletconnect/core/dist/esm/events.js
var EventManager = class {
  constructor() {
    this._eventEmitters = [];
  }
  subscribe(eventEmitter) {
    this._eventEmitters.push(eventEmitter);
  }
  unsubscribe(event) {
    this._eventEmitters = this._eventEmitters.filter((x2) => x2.event !== event);
  }
  trigger(payload) {
    let eventEmitters = [];
    let event;
    if (isJsonRpcRequest2(payload)) {
      event = payload.method;
    } else if (isJsonRpcResponseSuccess(payload) || isJsonRpcResponseError(payload)) {
      event = `response:${payload.id}`;
    } else if (isInternalEvent(payload)) {
      event = payload.event;
    } else {
      event = "";
    }
    if (event) {
      eventEmitters = this._eventEmitters.filter((eventEmitter) => eventEmitter.event === event);
    }
    if ((!eventEmitters || !eventEmitters.length) && !isReservedEvent(event) && !isInternalEvent(event)) {
      eventEmitters = this._eventEmitters.filter((eventEmitter) => eventEmitter.event === "call_request");
    }
    eventEmitters.forEach((eventEmitter) => {
      if (isJsonRpcResponseError(payload)) {
        const error = new Error(payload.error.message);
        eventEmitter.callback(error, null);
      } else {
        eventEmitter.callback(null, payload);
      }
    });
  }
};
var events_default = EventManager;

// node_modules/@walletconnect/core/dist/esm/storage.js
var SessionStorage = class {
  constructor(storageId = "walletconnect") {
    this.storageId = storageId;
  }
  getSession() {
    let session = null;
    const json = getLocal(this.storageId);
    if (json && isWalletConnectSession(json)) {
      session = json;
    }
    return session;
  }
  setSession(session) {
    setLocal(this.storageId, session);
    return session;
  }
  removeSession() {
    removeLocal(this.storageId);
  }
};
var storage_default = SessionStorage;

// node_modules/@walletconnect/core/dist/esm/url.js
var domain = "walletconnect.org";
var alphanumerical = "abcdefghijklmnopqrstuvwxyz0123456789";
var bridges = alphanumerical.split("").map((char) => `https://${char}.bridge.walletconnect.org`);
function extractHostname(url) {
  let hostname = url.indexOf("//") > -1 ? url.split("/")[2] : url.split("/")[0];
  hostname = hostname.split(":")[0];
  hostname = hostname.split("?")[0];
  return hostname;
}
function extractRootDomain(url) {
  return extractHostname(url).split(".").slice(-2).join(".");
}
function randomBridgeIndex() {
  return Math.floor(Math.random() * bridges.length);
}
function selectRandomBridgeUrl() {
  return bridges[randomBridgeIndex()];
}
function shouldSelectRandomly(url) {
  return extractRootDomain(url) === domain;
}
function getBridgeUrl(url) {
  if (shouldSelectRandomly(url)) {
    return selectRandomBridgeUrl();
  }
  return url;
}

// node_modules/@walletconnect/core/dist/esm/index.js
var Connector = class {
  constructor(opts) {
    this.protocol = "wc";
    this.version = 1;
    this._bridge = "";
    this._key = null;
    this._clientId = "";
    this._clientMeta = null;
    this._peerId = "";
    this._peerMeta = null;
    this._handshakeId = 0;
    this._handshakeTopic = "";
    this._connected = false;
    this._accounts = [];
    this._chainId = 0;
    this._networkId = 0;
    this._rpcUrl = "";
    this._eventManager = new events_default();
    this._clientMeta = getClientMeta() || opts.connectorOpts.clientMeta || null;
    this._cryptoLib = opts.cryptoLib;
    this._sessionStorage = opts.sessionStorage || new storage_default(opts.connectorOpts.storageId);
    this._qrcodeModal = opts.connectorOpts.qrcodeModal;
    this._qrcodeModalOptions = opts.connectorOpts.qrcodeModalOptions;
    this._signingMethods = [...signingMethods, ...opts.connectorOpts.signingMethods || []];
    if (!opts.connectorOpts.bridge && !opts.connectorOpts.uri && !opts.connectorOpts.session) {
      throw new Error(ERROR_MISSING_REQUIRED);
    }
    if (opts.connectorOpts.bridge) {
      this.bridge = getBridgeUrl(opts.connectorOpts.bridge);
    }
    if (opts.connectorOpts.uri) {
      this.uri = opts.connectorOpts.uri;
    }
    const session = opts.connectorOpts.session || this._getStorageSession();
    if (session) {
      this.session = session;
    }
    if (this.handshakeId) {
      this._subscribeToSessionResponse(this.handshakeId, "Session request rejected");
    }
    this._transport = opts.transport || new esm_default({
      protocol: this.protocol,
      version: this.version,
      url: this.bridge,
      subscriptions: [this.clientId]
    });
    this._subscribeToInternalEvents();
    this._initTransport();
    if (opts.connectorOpts.uri) {
      this._subscribeToSessionRequest();
    }
    if (opts.pushServerOpts) {
      this._registerPushServer(opts.pushServerOpts);
    }
  }
  set bridge(value) {
    if (!value) {
      return;
    }
    this._bridge = value;
  }
  get bridge() {
    return this._bridge;
  }
  set key(value) {
    if (!value) {
      return;
    }
    const key = convertHexToArrayBuffer(value);
    this._key = key;
  }
  get key() {
    if (this._key) {
      const key = convertArrayBufferToHex(this._key, true);
      return key;
    }
    return "";
  }
  set clientId(value) {
    if (!value) {
      return;
    }
    this._clientId = value;
  }
  get clientId() {
    let clientId = this._clientId;
    if (!clientId) {
      clientId = this._clientId = uuid();
    }
    return this._clientId;
  }
  set peerId(value) {
    if (!value) {
      return;
    }
    this._peerId = value;
  }
  get peerId() {
    return this._peerId;
  }
  set clientMeta(value) {
  }
  get clientMeta() {
    let clientMeta = this._clientMeta;
    if (!clientMeta) {
      clientMeta = this._clientMeta = getClientMeta();
    }
    return clientMeta;
  }
  set peerMeta(value) {
    this._peerMeta = value;
  }
  get peerMeta() {
    const peerMeta = this._peerMeta;
    return peerMeta;
  }
  set handshakeTopic(value) {
    if (!value) {
      return;
    }
    this._handshakeTopic = value;
  }
  get handshakeTopic() {
    return this._handshakeTopic;
  }
  set handshakeId(value) {
    if (!value) {
      return;
    }
    this._handshakeId = value;
  }
  get handshakeId() {
    return this._handshakeId;
  }
  get uri() {
    const _uri = this._formatUri();
    return _uri;
  }
  set uri(value) {
    if (!value) {
      return;
    }
    const { handshakeTopic, bridge, key } = this._parseUri(value);
    this.handshakeTopic = handshakeTopic;
    this.bridge = bridge;
    this.key = key;
  }
  set chainId(value) {
    this._chainId = value;
  }
  get chainId() {
    const chainId = this._chainId;
    return chainId;
  }
  set networkId(value) {
    this._networkId = value;
  }
  get networkId() {
    const networkId = this._networkId;
    return networkId;
  }
  set accounts(value) {
    this._accounts = value;
  }
  get accounts() {
    const accounts = this._accounts;
    return accounts;
  }
  set rpcUrl(value) {
    this._rpcUrl = value;
  }
  get rpcUrl() {
    const rpcUrl = this._rpcUrl;
    return rpcUrl;
  }
  set connected(value) {
  }
  get connected() {
    return this._connected;
  }
  set pending(value) {
  }
  get pending() {
    return !!this._handshakeTopic;
  }
  get session() {
    return {
      connected: this.connected,
      accounts: this.accounts,
      chainId: this.chainId,
      bridge: this.bridge,
      key: this.key,
      clientId: this.clientId,
      clientMeta: this.clientMeta,
      peerId: this.peerId,
      peerMeta: this.peerMeta,
      handshakeId: this.handshakeId,
      handshakeTopic: this.handshakeTopic
    };
  }
  set session(value) {
    if (!value) {
      return;
    }
    this._connected = value.connected;
    this.accounts = value.accounts;
    this.chainId = value.chainId;
    this.bridge = value.bridge;
    this.key = value.key;
    this.clientId = value.clientId;
    this.clientMeta = value.clientMeta;
    this.peerId = value.peerId;
    this.peerMeta = value.peerMeta;
    this.handshakeId = value.handshakeId;
    this.handshakeTopic = value.handshakeTopic;
  }
  on(event, callback) {
    const eventEmitter = {
      event,
      callback
    };
    this._eventManager.subscribe(eventEmitter);
  }
  off(event) {
    this._eventManager.unsubscribe(event);
  }
  async createInstantRequest(instantRequest) {
    this._key = await this._generateKey();
    const request = this._formatRequest({
      method: "wc_instantRequest",
      params: [
        {
          peerId: this.clientId,
          peerMeta: this.clientMeta,
          request: this._formatRequest(instantRequest)
        }
      ]
    });
    this.handshakeId = request.id;
    this.handshakeTopic = uuid();
    this._eventManager.trigger({
      event: "display_uri",
      params: [this.uri]
    });
    this.on("modal_closed", () => {
      throw new Error(ERROR_QRCODE_MODAL_USER_CLOSED);
    });
    const endInstantRequest = () => {
      this.killSession();
    };
    try {
      const result = await this._sendCallRequest(request);
      if (result) {
        endInstantRequest();
      }
      return result;
    } catch (error) {
      endInstantRequest();
      throw error;
    }
  }
  async connect(opts) {
    if (!this._qrcodeModal) {
      throw new Error(ERROR_QRCODE_MODAL_NOT_PROVIDED);
    }
    if (this.connected) {
      return {
        chainId: this.chainId,
        accounts: this.accounts
      };
    }
    await this.createSession(opts);
    return new Promise(async (resolve, reject) => {
      this.on("modal_closed", () => reject(new Error(ERROR_QRCODE_MODAL_USER_CLOSED)));
      this.on("connect", (error, payload) => {
        if (error) {
          return reject(error);
        }
        resolve(payload.params[0]);
      });
    });
  }
  async createSession(opts) {
    if (this._connected) {
      throw new Error(ERROR_SESSION_CONNECTED);
    }
    if (this.pending) {
      return;
    }
    this._key = await this._generateKey();
    const request = this._formatRequest({
      method: "wc_sessionRequest",
      params: [
        {
          peerId: this.clientId,
          peerMeta: this.clientMeta,
          chainId: opts && opts.chainId ? opts.chainId : null
        }
      ]
    });
    this.handshakeId = request.id;
    this.handshakeTopic = uuid();
    this._sendSessionRequest(request, "Session update rejected", {
      topic: this.handshakeTopic
    });
    this._eventManager.trigger({
      event: "display_uri",
      params: [this.uri]
    });
  }
  approveSession(sessionStatus) {
    if (this._connected) {
      throw new Error(ERROR_SESSION_CONNECTED);
    }
    this.chainId = sessionStatus.chainId;
    this.accounts = sessionStatus.accounts;
    this.networkId = sessionStatus.networkId || 0;
    this.rpcUrl = sessionStatus.rpcUrl || "";
    const sessionParams = {
      approved: true,
      chainId: this.chainId,
      networkId: this.networkId,
      accounts: this.accounts,
      rpcUrl: this.rpcUrl,
      peerId: this.clientId,
      peerMeta: this.clientMeta
    };
    const response = {
      id: this.handshakeId,
      jsonrpc: "2.0",
      result: sessionParams
    };
    this._sendResponse(response);
    this._connected = true;
    this._setStorageSession();
    this._eventManager.trigger({
      event: "connect",
      params: [
        {
          peerId: this.peerId,
          peerMeta: this.peerMeta,
          chainId: this.chainId,
          accounts: this.accounts
        }
      ]
    });
  }
  rejectSession(sessionError) {
    if (this._connected) {
      throw new Error(ERROR_SESSION_CONNECTED);
    }
    const message = sessionError && sessionError.message ? sessionError.message : ERROR_SESSION_REJECTED;
    const response = this._formatResponse({
      id: this.handshakeId,
      error: { message }
    });
    this._sendResponse(response);
    this._connected = false;
    this._eventManager.trigger({
      event: "disconnect",
      params: [{ message }]
    });
    this._removeStorageSession();
  }
  updateSession(sessionStatus) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    this.chainId = sessionStatus.chainId;
    this.accounts = sessionStatus.accounts;
    this.networkId = sessionStatus.networkId || 0;
    this.rpcUrl = sessionStatus.rpcUrl || "";
    const sessionParams = {
      approved: true,
      chainId: this.chainId,
      networkId: this.networkId,
      accounts: this.accounts,
      rpcUrl: this.rpcUrl
    };
    const request = this._formatRequest({
      method: "wc_sessionUpdate",
      params: [sessionParams]
    });
    this._sendSessionRequest(request, "Session update rejected");
    this._eventManager.trigger({
      event: "session_update",
      params: [
        {
          chainId: this.chainId,
          accounts: this.accounts
        }
      ]
    });
    this._manageStorageSession();
  }
  async killSession(sessionError) {
    const message = sessionError ? sessionError.message : "Session Disconnected";
    const sessionParams = {
      approved: false,
      chainId: null,
      networkId: null,
      accounts: null
    };
    const request = this._formatRequest({
      method: "wc_sessionUpdate",
      params: [sessionParams]
    });
    await this._sendRequest(request);
    this._handleSessionDisconnect(message);
  }
  async sendTransaction(tx) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    const parsedTx = parseTransactionData(tx);
    const request = this._formatRequest({
      method: "eth_sendTransaction",
      params: [parsedTx]
    });
    const result = await this._sendCallRequest(request);
    return result;
  }
  async signTransaction(tx) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    const parsedTx = parseTransactionData(tx);
    const request = this._formatRequest({
      method: "eth_signTransaction",
      params: [parsedTx]
    });
    const result = await this._sendCallRequest(request);
    return result;
  }
  async signMessage(params) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    const request = this._formatRequest({
      method: "eth_sign",
      params
    });
    const result = await this._sendCallRequest(request);
    return result;
  }
  async signPersonalMessage(params) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    params = parsePersonalSign(params);
    const request = this._formatRequest({
      method: "personal_sign",
      params
    });
    const result = await this._sendCallRequest(request);
    return result;
  }
  async signTypedData(params) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    const request = this._formatRequest({
      method: "eth_signTypedData",
      params
    });
    const result = await this._sendCallRequest(request);
    return result;
  }
  async updateChain(chainParams) {
    if (!this._connected) {
      throw new Error("Session currently disconnected");
    }
    const request = this._formatRequest({
      method: "wallet_updateChain",
      params: [chainParams]
    });
    const result = await this._sendCallRequest(request);
    return result;
  }
  unsafeSend(request, options) {
    this._sendRequest(request, options);
    this._eventManager.trigger({
      event: "call_request_sent",
      params: [{ request, options }]
    });
    return new Promise((resolve, reject) => {
      this._subscribeToResponse(request.id, (error, payload) => {
        if (error) {
          reject(error);
          return;
        }
        if (!payload) {
          throw new Error(ERROR_MISSING_JSON_RPC);
        }
        resolve(payload);
      });
    });
  }
  async sendCustomRequest(request, options) {
    if (!this._connected) {
      throw new Error(ERROR_SESSION_DISCONNECTED);
    }
    switch (request.method) {
      case "eth_accounts":
        return this.accounts;
      case "eth_chainId":
        return convertNumberToHex(this.chainId);
      case "eth_sendTransaction":
      case "eth_signTransaction":
        if (request.params) {
          request.params[0] = parseTransactionData(request.params[0]);
        }
        break;
      case "personal_sign":
        if (request.params) {
          request.params = parsePersonalSign(request.params);
        }
        break;
      default:
        break;
    }
    const formattedRequest = this._formatRequest(request);
    const result = await this._sendCallRequest(formattedRequest, options);
    return result;
  }
  approveRequest(response) {
    if (isJsonRpcResponseSuccess(response)) {
      const formattedResponse = this._formatResponse(response);
      this._sendResponse(formattedResponse);
    } else {
      throw new Error(ERROR_MISSING_RESULT);
    }
  }
  rejectRequest(response) {
    if (isJsonRpcResponseError(response)) {
      const formattedResponse = this._formatResponse(response);
      this._sendResponse(formattedResponse);
    } else {
      throw new Error(ERROR_MISSING_ERROR);
    }
  }
  transportClose() {
    this._transport.close();
  }
  async _sendRequest(request, options) {
    const callRequest = this._formatRequest(request);
    const encryptionPayload = await this._encrypt(callRequest);
    const topic = typeof (options === null || options === void 0 ? void 0 : options.topic) !== "undefined" ? options.topic : this.peerId;
    const payload = JSON.stringify(encryptionPayload);
    const silent = typeof (options === null || options === void 0 ? void 0 : options.forcePushNotification) !== "undefined" ? !options.forcePushNotification : isSilentPayload(callRequest);
    this._transport.send(payload, topic, silent);
  }
  async _sendResponse(response) {
    const encryptionPayload = await this._encrypt(response);
    const topic = this.peerId;
    const payload = JSON.stringify(encryptionPayload);
    const silent = true;
    this._transport.send(payload, topic, silent);
  }
  async _sendSessionRequest(request, errorMsg, options) {
    this._sendRequest(request, options);
    this._subscribeToSessionResponse(request.id, errorMsg);
  }
  _sendCallRequest(request, options) {
    this._sendRequest(request, options);
    this._eventManager.trigger({
      event: "call_request_sent",
      params: [{ request, options }]
    });
    return this._subscribeToCallResponse(request.id);
  }
  _formatRequest(request) {
    if (typeof request.method === "undefined") {
      throw new Error(ERROR_MISSING_METHOD);
    }
    const formattedRequest = {
      id: typeof request.id === "undefined" ? payloadId2() : request.id,
      jsonrpc: "2.0",
      method: request.method,
      params: typeof request.params === "undefined" ? [] : request.params
    };
    return formattedRequest;
  }
  _formatResponse(response) {
    if (typeof response.id === "undefined") {
      throw new Error(ERROR_MISSING_ID);
    }
    const baseResponse = { id: response.id, jsonrpc: "2.0" };
    if (isJsonRpcResponseError(response)) {
      const error = formatRpcError(response.error);
      const errorResponse = Object.assign(Object.assign(Object.assign({}, baseResponse), response), { error });
      return errorResponse;
    } else if (isJsonRpcResponseSuccess(response)) {
      const successResponse = Object.assign(Object.assign({}, baseResponse), response);
      return successResponse;
    }
    throw new Error(ERROR_INVALID_RESPONSE);
  }
  _handleSessionDisconnect(errorMsg) {
    const message = errorMsg || "Session Disconnected";
    if (!this._connected) {
      if (this._qrcodeModal) {
        this._qrcodeModal.close();
      }
      removeLocal(mobileLinkChoiceKey);
    }
    if (this._connected) {
      this._connected = false;
    }
    if (this._handshakeId) {
      this._handshakeId = 0;
    }
    if (this._handshakeTopic) {
      this._handshakeTopic = "";
    }
    if (this._peerId) {
      this._peerId = "";
    }
    this._eventManager.trigger({
      event: "disconnect",
      params: [{ message }]
    });
    this._removeStorageSession();
    this.transportClose();
  }
  _handleSessionResponse(errorMsg, sessionParams) {
    if (sessionParams) {
      if (sessionParams.approved) {
        if (!this._connected) {
          this._connected = true;
          if (sessionParams.chainId) {
            this.chainId = sessionParams.chainId;
          }
          if (sessionParams.accounts) {
            this.accounts = sessionParams.accounts;
          }
          if (sessionParams.peerId && !this.peerId) {
            this.peerId = sessionParams.peerId;
          }
          if (sessionParams.peerMeta && !this.peerMeta) {
            this.peerMeta = sessionParams.peerMeta;
          }
          this._eventManager.trigger({
            event: "connect",
            params: [
              {
                peerId: this.peerId,
                peerMeta: this.peerMeta,
                chainId: this.chainId,
                accounts: this.accounts
              }
            ]
          });
        } else {
          if (sessionParams.chainId) {
            this.chainId = sessionParams.chainId;
          }
          if (sessionParams.accounts) {
            this.accounts = sessionParams.accounts;
          }
          this._eventManager.trigger({
            event: "session_update",
            params: [
              {
                chainId: this.chainId,
                accounts: this.accounts
              }
            ]
          });
        }
        this._manageStorageSession();
      } else {
        this._handleSessionDisconnect(errorMsg);
      }
    } else {
      this._handleSessionDisconnect(errorMsg);
    }
  }
  async _handleIncomingMessages(socketMessage) {
    const activeTopics = [this.clientId, this.handshakeTopic];
    if (!activeTopics.includes(socketMessage.topic)) {
      return;
    }
    let encryptionPayload;
    try {
      encryptionPayload = JSON.parse(socketMessage.payload);
    } catch (error) {
      return;
    }
    const payload = await this._decrypt(encryptionPayload);
    if (payload) {
      this._eventManager.trigger(payload);
    }
  }
  _subscribeToSessionRequest() {
    this._transport.subscribe(this.handshakeTopic);
  }
  _subscribeToResponse(id, callback) {
    this.on(`response:${id}`, callback);
  }
  _subscribeToSessionResponse(id, errorMsg) {
    this._subscribeToResponse(id, (error, payload) => {
      if (error) {
        this._handleSessionResponse(error.message);
        return;
      }
      if (isJsonRpcResponseSuccess(payload)) {
        this._handleSessionResponse(errorMsg, payload.result);
      } else if (payload.error && payload.error.message) {
        this._handleSessionResponse(payload.error.message);
      } else {
        this._handleSessionResponse(errorMsg);
      }
    });
  }
  _subscribeToCallResponse(id) {
    return new Promise((resolve, reject) => {
      this._subscribeToResponse(id, (error, payload) => {
        if (error) {
          reject(error);
          return;
        }
        if (isJsonRpcResponseSuccess(payload)) {
          resolve(payload.result);
        } else if (payload.error && payload.error.message) {
          reject(payload.error);
        } else {
          reject(new Error(ERROR_INVALID_RESPONSE));
        }
      });
    });
  }
  _subscribeToInternalEvents() {
    this.on("display_uri", () => {
      if (this._qrcodeModal) {
        this._qrcodeModal.open(this.uri, () => {
          this._eventManager.trigger({
            event: "modal_closed",
            params: []
          });
        }, this._qrcodeModalOptions);
      }
    });
    this.on("connect", () => {
      if (this._qrcodeModal) {
        this._qrcodeModal.close();
      }
    });
    this.on("call_request_sent", (error, payload) => {
      const { request } = payload.params[0];
      if (isMobile() && this._signingMethods.includes(request.method)) {
        const mobileLinkUrl = getLocal(mobileLinkChoiceKey);
        if (mobileLinkUrl) {
          window.location.href = mobileLinkUrl.href;
        }
      }
    });
    this.on("wc_sessionRequest", (error, payload) => {
      if (error) {
        this._eventManager.trigger({
          event: "error",
          params: [
            {
              code: "SESSION_REQUEST_ERROR",
              message: error.toString()
            }
          ]
        });
      }
      this.handshakeId = payload.id;
      this.peerId = payload.params[0].peerId;
      this.peerMeta = payload.params[0].peerMeta;
      const internalPayload = Object.assign(Object.assign({}, payload), { method: "session_request" });
      this._eventManager.trigger(internalPayload);
    });
    this.on("wc_sessionUpdate", (error, payload) => {
      if (error) {
        this._handleSessionResponse(error.message);
      }
      this._handleSessionResponse("Session disconnected", payload.params[0]);
    });
  }
  _initTransport() {
    this._transport.on("message", (socketMessage) => this._handleIncomingMessages(socketMessage));
    this._transport.on("open", () => this._eventManager.trigger({ event: "transport_open", params: [] }));
    this._transport.on("close", () => this._eventManager.trigger({ event: "transport_close", params: [] }));
    this._transport.on("error", () => this._eventManager.trigger({
      event: "transport_error",
      params: ["Websocket connection failed"]
    }));
    this._transport.open();
  }
  _formatUri() {
    const protocol = this.protocol;
    const handshakeTopic = this.handshakeTopic;
    const version = this.version;
    const bridge = encodeURIComponent(this.bridge);
    const key = this.key;
    const uri = `${protocol}:${handshakeTopic}@${version}?bridge=${bridge}&key=${key}`;
    return uri;
  }
  _parseUri(uri) {
    const result = parseWalletConnectUri(uri);
    if (result.protocol === this.protocol) {
      if (!result.handshakeTopic) {
        throw Error("Invalid or missing handshakeTopic parameter value");
      }
      const handshakeTopic = result.handshakeTopic;
      if (!result.bridge) {
        throw Error("Invalid or missing bridge url parameter value");
      }
      const bridge = decodeURIComponent(result.bridge);
      if (!result.key) {
        throw Error("Invalid or missing key parameter value");
      }
      const key = result.key;
      return { handshakeTopic, bridge, key };
    } else {
      throw new Error(ERROR_INVALID_URI);
    }
  }
  async _generateKey() {
    if (this._cryptoLib) {
      const result = await this._cryptoLib.generateKey();
      return result;
    }
    return null;
  }
  async _encrypt(data) {
    const key = this._key;
    if (this._cryptoLib && key) {
      const result = await this._cryptoLib.encrypt(data, key);
      return result;
    }
    return null;
  }
  async _decrypt(payload) {
    const key = this._key;
    if (this._cryptoLib && key) {
      const result = await this._cryptoLib.decrypt(payload, key);
      return result;
    }
    return null;
  }
  _getStorageSession() {
    let result = null;
    if (this._sessionStorage) {
      result = this._sessionStorage.getSession();
    }
    return result;
  }
  _setStorageSession() {
    if (this._sessionStorage) {
      this._sessionStorage.setSession(this.session);
    }
  }
  _removeStorageSession() {
    if (this._sessionStorage) {
      this._sessionStorage.removeSession();
    }
  }
  _manageStorageSession() {
    if (this._connected) {
      this._setStorageSession();
    } else {
      this._removeStorageSession();
    }
  }
  _registerPushServer(pushServerOpts) {
    if (!pushServerOpts.url || typeof pushServerOpts.url !== "string") {
      throw Error("Invalid or missing pushServerOpts.url parameter value");
    }
    if (!pushServerOpts.type || typeof pushServerOpts.type !== "string") {
      throw Error("Invalid or missing pushServerOpts.type parameter value");
    }
    if (!pushServerOpts.token || typeof pushServerOpts.token !== "string") {
      throw Error("Invalid or missing pushServerOpts.token parameter value");
    }
    const pushSubscription = {
      bridge: this.bridge,
      topic: this.clientId,
      type: pushServerOpts.type,
      token: pushServerOpts.token,
      peerName: "",
      language: pushServerOpts.language || ""
    };
    this.on("connect", async (error, payload) => {
      if (error) {
        throw error;
      }
      if (pushServerOpts.peerMeta) {
        const peerName = payload.params[0].peerMeta.name;
        pushSubscription.peerName = peerName;
      }
      try {
        const response = await fetch(`${pushServerOpts.url}/new`, {
          method: "POST",
          headers: {
            Accept: "application/json",
            "Content-Type": "application/json"
          },
          body: JSON.stringify(pushSubscription)
        });
        const json = await response.json();
        if (!json.success) {
          throw Error("Failed to register in Push Server");
        }
      } catch (error2) {
        throw Error("Failed to register in Push Server");
      }
    });
  }
};
var esm_default2 = Connector;

// node_modules/@walletconnect/iso-crypto/dist/esm/index.js
var esm_exports4 = {};
__export(esm_exports4, {
  decrypt: () => decrypt,
  encrypt: () => encrypt,
  generateKey: () => generateKey,
  verifyHmac: () => verifyHmac
});

// node_modules/@walletconnect/crypto/dist/esm/browser/index.js
var browser_exports = {};
__export(browser_exports, {
  AES_BROWSER_ALGO: () => AES_BROWSER_ALGO,
  AES_LENGTH: () => AES_LENGTH,
  AES_NODE_ALGO: () => AES_NODE_ALGO,
  DECRYPT_OP: () => DECRYPT_OP,
  ENCRYPT_OP: () => ENCRYPT_OP,
  ERROR_BAD_MAC: () => ERROR_BAD_MAC,
  HEX_ENC: () => HEX_ENC,
  HMAC_BROWSER: () => HMAC_BROWSER,
  HMAC_BROWSER_ALGO: () => HMAC_BROWSER_ALGO,
  HMAC_LENGTH: () => HMAC_LENGTH,
  HMAC_NODE_ALGO: () => HMAC_NODE_ALGO,
  IV_LENGTH: () => IV_LENGTH,
  KEY_LENGTH: () => KEY_LENGTH,
  LENGTH_0: () => LENGTH_0,
  LENGTH_1: () => LENGTH_1,
  LENGTH_1024: () => LENGTH_1024,
  LENGTH_128: () => LENGTH_128,
  LENGTH_16: () => LENGTH_16,
  LENGTH_256: () => LENGTH_256,
  LENGTH_32: () => LENGTH_32,
  LENGTH_512: () => LENGTH_512,
  LENGTH_64: () => LENGTH_64,
  MAC_LENGTH: () => MAC_LENGTH,
  PREFIX_LENGTH: () => PREFIX_LENGTH,
  RIPEMD160_NODE_ALGO: () => RIPEMD160_NODE_ALGO,
  SHA256_BROWSER_ALGO: () => SHA256_BROWSER_ALGO,
  SHA256_NODE_ALGO: () => SHA256_NODE_ALGO,
  SHA512_BROWSER_ALGO: () => SHA512_BROWSER_ALGO,
  SHA512_NODE_ALGO: () => SHA512_NODE_ALGO,
  SIGN_OP: () => SIGN_OP,
  UTF8_ENC: () => UTF8_ENC,
  VERIFY_OP: () => VERIFY_OP,
  aesCbcDecrypt: () => aesCbcDecrypt,
  aesCbcEncrypt: () => aesCbcEncrypt,
  assert: () => assert,
  hmacSha256Sign: () => hmacSha256Sign,
  hmacSha256Verify: () => hmacSha256Verify,
  hmacSha512Sign: () => hmacSha512Sign,
  hmacSha512Verify: () => hmacSha512Verify,
  isConstantTime: () => isConstantTime,
  pkcs7: () => pkcs7,
  randomBytes: () => randomBytes,
  ripemd160: () => ripemd160,
  sha256: () => sha256,
  sha512: () => sha512
});

// node_modules/@walletconnect/randombytes/dist/esm/browser/index.js
var env = __toESM(require_cjs3());
function randomBytes(length) {
  const browserCrypto = env.getBrowerCrypto();
  return browserCrypto.getRandomValues(new Uint8Array(length));
}

// node_modules/@walletconnect/crypto/dist/esm/lib/browser.js
var env2 = __toESM(require_cjs3());

// node_modules/@walletconnect/crypto/dist/esm/constants/length.js
var LENGTH_0 = 0;
var LENGTH_1 = 1;
var LENGTH_16 = 16;
var LENGTH_32 = 32;
var LENGTH_64 = 64;
var LENGTH_128 = 128;
var LENGTH_256 = 256;
var LENGTH_512 = 512;
var LENGTH_1024 = 1024;

// node_modules/@walletconnect/crypto/dist/esm/constants/default.js
var AES_LENGTH = LENGTH_256;
var HMAC_LENGTH = LENGTH_256;
var AES_BROWSER_ALGO = "AES-CBC";
var HMAC_BROWSER_ALGO = `SHA-${AES_LENGTH}`;
var HMAC_BROWSER = "HMAC";
var SHA256_BROWSER_ALGO = "SHA-256";
var SHA512_BROWSER_ALGO = "SHA-512";
var AES_NODE_ALGO = `aes-${AES_LENGTH}-cbc`;
var HMAC_NODE_ALGO = `sha${HMAC_LENGTH}`;
var SHA256_NODE_ALGO = "sha256";
var SHA512_NODE_ALGO = "sha512";
var RIPEMD160_NODE_ALGO = "ripemd160";
var PREFIX_LENGTH = LENGTH_1;
var KEY_LENGTH = LENGTH_32;
var IV_LENGTH = LENGTH_16;
var MAC_LENGTH = LENGTH_32;

// node_modules/@walletconnect/crypto/dist/esm/constants/encoding.js
var HEX_ENC = "hex";
var UTF8_ENC = "utf8";

// node_modules/@walletconnect/crypto/dist/esm/constants/error.js
var ERROR_BAD_MAC = "Bad MAC";

// node_modules/@walletconnect/crypto/dist/esm/constants/operations.js
var ENCRYPT_OP = "encrypt";
var DECRYPT_OP = "decrypt";
var SIGN_OP = "sign";
var VERIFY_OP = "verify";

// node_modules/@walletconnect/crypto/dist/esm/lib/browser.js
function getAlgo(type) {
  return type === AES_BROWSER_ALGO ? { length: AES_LENGTH, name: AES_BROWSER_ALGO } : {
    hash: { name: HMAC_BROWSER_ALGO },
    name: HMAC_BROWSER
  };
}
function getOps(type) {
  return type === AES_BROWSER_ALGO ? [ENCRYPT_OP, DECRYPT_OP] : [SIGN_OP, VERIFY_OP];
}
async function browserImportKey(buffer, type = AES_BROWSER_ALGO) {
  return env2.getSubtleCrypto().importKey("raw", buffer, getAlgo(type), true, getOps(type));
}
async function browserAesEncrypt(iv, key, data) {
  const subtle = env2.getSubtleCrypto();
  const cryptoKey = await browserImportKey(key, AES_BROWSER_ALGO);
  const result = await subtle.encrypt({
    iv,
    name: AES_BROWSER_ALGO
  }, cryptoKey, data);
  return new Uint8Array(result);
}
async function browserAesDecrypt(iv, key, data) {
  const subtle = env2.getSubtleCrypto();
  const cryptoKey = await browserImportKey(key, AES_BROWSER_ALGO);
  const result = await subtle.decrypt({
    iv,
    name: AES_BROWSER_ALGO
  }, cryptoKey, data);
  return new Uint8Array(result);
}
async function browserHmacSha256Sign(key, data) {
  const subtle = env2.getSubtleCrypto();
  const cryptoKey = await browserImportKey(key, HMAC_BROWSER);
  const signature = await subtle.sign({
    length: HMAC_LENGTH,
    name: HMAC_BROWSER
  }, cryptoKey, data);
  return new Uint8Array(signature);
}
async function browserHmacSha512Sign(key, data) {
  const subtle = env2.getSubtleCrypto();
  const cryptoKey = await browserImportKey(key, HMAC_BROWSER);
  const signature = await subtle.sign({
    length: LENGTH_512,
    name: HMAC_BROWSER
  }, cryptoKey, data);
  return new Uint8Array(signature);
}
async function browserSha256(data) {
  const subtle = env2.getSubtleCrypto();
  const result = await subtle.digest({
    name: SHA256_BROWSER_ALGO
  }, data);
  return new Uint8Array(result);
}
async function browserSha512(data) {
  const subtle = env2.getSubtleCrypto();
  const result = await subtle.digest({
    name: SHA512_BROWSER_ALGO
  }, data);
  return new Uint8Array(result);
}

// node_modules/@walletconnect/crypto/dist/esm/browser/aes.js
function aesCbcEncrypt(iv, key, data) {
  return browserAesEncrypt(iv, key, data);
}
function aesCbcDecrypt(iv, key, data) {
  return browserAesDecrypt(iv, key, data);
}

// node_modules/@walletconnect/crypto/dist/esm/helpers/index.js
var helpers_exports = {};
__export(helpers_exports, {
  assert: () => assert,
  isConstantTime: () => isConstantTime,
  pkcs7: () => pkcs7
});

// node_modules/@walletconnect/crypto/dist/esm/helpers/env.js
var env_exports2 = {};
__reExport(env_exports2, __toESM(require_cjs3()));

// node_modules/@walletconnect/crypto/dist/esm/helpers/index.js
__reExport(helpers_exports, env_exports2);

// node_modules/@walletconnect/crypto/dist/esm/helpers/pkcs7.js
var PADDING = [
  [16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16],
  [15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15],
  [14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14],
  [13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13],
  [12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12],
  [11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11],
  [10, 10, 10, 10, 10, 10, 10, 10, 10, 10],
  [9, 9, 9, 9, 9, 9, 9, 9, 9],
  [8, 8, 8, 8, 8, 8, 8, 8],
  [7, 7, 7, 7, 7, 7, 7],
  [6, 6, 6, 6, 6, 6],
  [5, 5, 5, 5, 5],
  [4, 4, 4, 4],
  [3, 3, 3],
  [2, 2],
  [1]
];
var pkcs7 = {
  pad(plaintext) {
    const padding = PADDING[plaintext.byteLength % 16 || 0];
    const result = new Uint8Array(plaintext.byteLength + padding.length);
    result.set(plaintext);
    result.set(padding, plaintext.byteLength);
    return result;
  },
  unpad(padded) {
    return padded.subarray(0, padded.byteLength - padded[padded.byteLength - 1]);
  }
};

// node_modules/@walletconnect/crypto/dist/esm/helpers/validators.js
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || "Assertion failed");
  }
}
function isConstantTime(arr1, arr2) {
  if (arr1.length !== arr2.length) {
    return false;
  }
  let res = 0;
  for (let i2 = 0; i2 < arr1.length; i2++) {
    res |= arr1[i2] ^ arr2[i2];
  }
  return res === 0;
}

// node_modules/@walletconnect/crypto/dist/esm/browser/hmac.js
async function hmacSha256Sign(key, msg) {
  const result = await browserHmacSha256Sign(key, msg);
  return result;
}
async function hmacSha256Verify(key, msg, sig) {
  const expectedSig = await browserHmacSha256Sign(key, msg);
  const result = isConstantTime(expectedSig, sig);
  return result;
}
async function hmacSha512Sign(key, msg) {
  const result = await browserHmacSha512Sign(key, msg);
  return result;
}
async function hmacSha512Verify(key, msg, sig) {
  const expectedSig = await browserHmacSha512Sign(key, msg);
  const result = isConstantTime(expectedSig, sig);
  return result;
}

// node_modules/@walletconnect/crypto/dist/esm/browser/sha2.js
async function sha256(msg) {
  const result = await browserSha256(msg);
  return result;
}
async function sha512(msg) {
  const result = await browserSha512(msg);
  return result;
}
async function ripemd160(_msg) {
  throw new Error("Not supported for Browser async methods, use sync instead!");
}

// node_modules/@walletconnect/crypto/dist/esm/browser/index.js
__reExport(browser_exports, helpers_exports);

// node_modules/@walletconnect/iso-crypto/dist/esm/index.js
async function generateKey(length) {
  const _length = (length || 256) / 8;
  const bytes = randomBytes(_length);
  const result = convertBufferToArrayBuffer(arrayToBuffer(bytes));
  return result;
}
async function verifyHmac(payload, key) {
  const cipherText = hexToArray(payload.data);
  const iv = hexToArray(payload.iv);
  const hmac = hexToArray(payload.hmac);
  const hmacHex = arrayToHex(hmac, false);
  const unsigned = concatArrays(cipherText, iv);
  const chmac = await hmacSha256Sign(key, unsigned);
  const chmacHex = arrayToHex(chmac, false);
  if (removeHexPrefix(hmacHex) === removeHexPrefix(chmacHex)) {
    return true;
  }
  return false;
}
async function encrypt(data, key, providedIv) {
  const _key = bufferToArray(convertArrayBufferToBuffer(key));
  const ivArrayBuffer = providedIv || await generateKey(128);
  const iv = bufferToArray(convertArrayBufferToBuffer(ivArrayBuffer));
  const ivHex = arrayToHex(iv, false);
  const contentString = JSON.stringify(data);
  const content = utf8ToArray(contentString);
  const cipherText = await aesCbcEncrypt(iv, _key, content);
  const cipherTextHex = arrayToHex(cipherText, false);
  const unsigned = concatArrays(cipherText, iv);
  const hmac = await hmacSha256Sign(_key, unsigned);
  const hmacHex = arrayToHex(hmac, false);
  return {
    data: cipherTextHex,
    hmac: hmacHex,
    iv: ivHex
  };
}
async function decrypt(payload, key) {
  const _key = bufferToArray(convertArrayBufferToBuffer(key));
  if (!_key) {
    throw new Error("Missing key: required for decryption");
  }
  const verified = await verifyHmac(payload, _key);
  if (!verified) {
    return null;
  }
  const cipherText = hexToArray(payload.data);
  const iv = hexToArray(payload.iv);
  const buffer = await aesCbcDecrypt(iv, _key, cipherText);
  const utf8 = arrayToUtf8(buffer);
  let data;
  try {
    data = JSON.parse(utf8);
  } catch (error) {
    return null;
  }
  return data;
}

// node_modules/@walletconnect/client/dist/esm/index.js
var WalletConnect = class extends esm_default2 {
  constructor(connectorOpts, pushServerOpts) {
    super({
      cryptoLib: esm_exports4,
      connectorOpts,
      pushServerOpts
    });
  }
};
var esm_default3 = WalletConnect;

// node_modules/algosdk/dist/esm/main.js
var main_exports = {};
__export(main_exports, {
  ABIAddressType: () => ABIAddressType,
  ABIArrayDynamicType: () => ABIArrayDynamicType,
  ABIArrayStaticType: () => ABIArrayStaticType,
  ABIBoolType: () => ABIBoolType,
  ABIByteType: () => ABIByteType,
  ABIContract: () => ABIContract,
  ABIInterface: () => ABIInterface,
  ABIMethod: () => ABIMethod,
  ABIReferenceType: () => ABIReferenceType,
  ABIStringType: () => ABIStringType,
  ABITransactionType: () => ABITransactionType,
  ABITupleType: () => ABITupleType,
  ABIType: () => ABIType,
  ABIUfixedType: () => ABIUfixedType,
  ABIUintType: () => ABIUintType,
  ADDR_BYTE_SIZE: () => ADDR_BYTE_SIZE,
  ALGORAND_ZERO_ADDRESS_STRING: () => ALGORAND_ZERO_ADDRESS_STRING,
  AccountBaseData: () => AccountBaseData,
  AccountData: () => AccountData,
  AccountDeltas: () => AccountDeltas,
  AccountTotals: () => AccountTotals,
  Address: () => Address,
  AlgoCount: () => AlgoCount,
  Algodv2: () => AlgodClient,
  AppLocalState: () => AppLocalState,
  AppLocalStateDelta: () => AppLocalStateDelta,
  AppParams: () => AppParams,
  AppParamsDelta: () => AppParamsDelta,
  AppResourceRecord: () => AppResourceRecord,
  ApplyData: () => ApplyData,
  AssetHolding: () => AssetHolding,
  AssetHoldingDelta: () => AssetHoldingDelta,
  AssetParams: () => AssetParams,
  AssetParamsDelta: () => AssetParamsDelta,
  AssetResourceRecord: () => AssetResourceRecord,
  AtomicTransactionComposer: () => AtomicTransactionComposer,
  AtomicTransactionComposerStatus: () => AtomicTransactionComposerStatus,
  BalanceRecord: () => BalanceRecord,
  Block: () => Block,
  BlockHeader: () => BlockHeader,
  ENCODED_MULTISIG_SCHEMA: () => ENCODED_MULTISIG_SCHEMA,
  ENCODED_SUBSIG_SCHEMA: () => ENCODED_SUBSIG_SCHEMA,
  ERROR_INVALID_MICROALGOS: () => ERROR_INVALID_MICROALGOS,
  ERROR_MULTISIG_BAD_SENDER: () => ERROR_MULTISIG_BAD_SENDER,
  EvalDelta: () => EvalDelta,
  FalconSignatureStruct: () => FalconSignatureStruct,
  FalconVerifier: () => FalconVerifier,
  HashFactory: () => HashFactory,
  INVALID_MICROALGOS_ERROR_MSG: () => INVALID_MICROALGOS_ERROR_MSG,
  IncludedTransactions: () => IncludedTransactions,
  Indexer: () => IndexerClient,
  IntDecoding: () => intDecoding_default,
  Kmd: () => KmdClient,
  KvValueDelta: () => KvValueDelta,
  LENGTH_ENCODE_BYTE_SIZE: () => LENGTH_ENCODE_BYTE_SIZE,
  LedgerStateDelta: () => LedgerStateDelta,
  LogicSig: () => LogicSig,
  LogicSigAccount: () => LogicSigAccount,
  MAX_LEN: () => MAX_LEN,
  MULTISIG_BAD_SENDER_ERROR_MSG: () => MULTISIG_BAD_SENDER_ERROR_MSG,
  MerkleArrayProof: () => MerkleArrayProof,
  MerkleSignatureVerifier: () => MerkleSignatureVerifier,
  ModifiedCreatable: () => ModifiedCreatable,
  OnApplicationComplete: () => OnApplicationComplete,
  Participant: () => Participant,
  ParticipationUpdates: () => ParticipationUpdates,
  ProgramSourceMap: () => ProgramSourceMap,
  Reveal: () => Reveal,
  RewardState: () => RewardState,
  SINGLE_BOOL_SIZE: () => SINGLE_BOOL_SIZE,
  SINGLE_BYTE_SIZE: () => SINGLE_BYTE_SIZE,
  SignedTransaction: () => SignedTransaction,
  SignedTxnInBlock: () => SignedTxnInBlock,
  SignedTxnWithAD: () => SignedTxnWithAD,
  SigslotCommit: () => SigslotCommit,
  StateProof: () => StateProof,
  StateProofMessage: () => StateProofMessage,
  StateProofTrackingData: () => StateProofTrackingData,
  StateSchema: () => StateSchema,
  TealValue: () => TealValue,
  Transaction: () => Transaction,
  TransactionType: () => TransactionType,
  TxnCommitments: () => TxnCommitments,
  UntypedValue: () => UntypedValue,
  UpgradeState: () => UpgradeState,
  UpgradeVote: () => UpgradeVote,
  ValueDelta: () => ValueDelta,
  VotingData: () => VotingData,
  abiCheckTransactionType: () => abiCheckTransactionType,
  abiTypeIsReference: () => abiTypeIsReference,
  abiTypeIsTransaction: () => abiTypeIsTransaction,
  algosToMicroalgos: () => algosToMicroalgos,
  appendSignMultisigTransaction: () => appendSignMultisigTransaction,
  appendSignRawMultisigSignature: () => appendSignRawMultisigSignature,
  assignGroupID: () => assignGroupID,
  base64ToBytes: () => base64ToBytes,
  bigIntToBytes: () => bigIntToBytes,
  bytesToBase64: () => bytesToBase64,
  bytesToBigInt: () => bytesToBigInt,
  bytesToHex: () => bytesToHex,
  bytesToString: () => bytesToString,
  coerceToBytes: () => coerceToBytes,
  computeGroupID: () => computeGroupID,
  createDryrun: () => createDryrun,
  createMultisigTransaction: () => createMultisigTransaction,
  decodeAddress: () => decodeAddress,
  decodeJSON: () => decodeJSON,
  decodeMsgpack: () => decodeMsgpack,
  decodeObj: () => decodeObj,
  decodeSignedTransaction: () => decodeSignedTransaction,
  decodeUint64: () => decodeUint64,
  decodeUnsignedTransaction: () => decodeUnsignedTransaction,
  dryrunTxnResultAppTrace: () => dryrunTxnResultAppTrace,
  dryrunTxnResultLogicSigTrace: () => dryrunTxnResultLogicSigTrace,
  encodeAddress: () => encodeAddress,
  encodeJSON: () => encodeJSON,
  encodeMsgpack: () => encodeMsgpack,
  encodeObj: () => encodeObj,
  encodeUint64: () => encodeUint64,
  encodeUnsignedSimulateTransaction: () => encodeUnsignedSimulateTransaction,
  encodeUnsignedTransaction: () => encodeUnsignedTransaction,
  encodedMultiSigFromEncodingData: () => encodedMultiSigFromEncodingData,
  encodedMultiSigToEncodingData: () => encodedMultiSigToEncodingData,
  encodedSubsigFromEncodingData: () => encodedSubsigFromEncodingData,
  encodedSubsigToEncodingData: () => encodedSubsigToEncodingData,
  generateAccount: () => generateAccount,
  getApplicationAddress: () => getApplicationAddress,
  getMethodByName: () => getMethodByName,
  hexToBytes: () => hexToBytes,
  indexerModels: () => types_exports2,
  isOnApplicationComplete: () => isOnApplicationComplete,
  isTransactionType: () => isTransactionType,
  isTransactionWithSigner: () => isTransactionWithSigner,
  isValidAddress: () => isValidAddress2,
  logicSigFromByte: () => logicSigFromByte,
  makeApplicationCallTxnFromObject: () => makeApplicationCallTxnFromObject,
  makeApplicationClearStateTxnFromObject: () => makeApplicationClearStateTxnFromObject,
  makeApplicationCloseOutTxnFromObject: () => makeApplicationCloseOutTxnFromObject,
  makeApplicationCreateTxnFromObject: () => makeApplicationCreateTxnFromObject,
  makeApplicationDeleteTxnFromObject: () => makeApplicationDeleteTxnFromObject,
  makeApplicationNoOpTxnFromObject: () => makeApplicationNoOpTxnFromObject,
  makeApplicationOptInTxnFromObject: () => makeApplicationOptInTxnFromObject,
  makeApplicationUpdateTxnFromObject: () => makeApplicationUpdateTxnFromObject,
  makeAssetConfigTxnWithSuggestedParamsFromObject: () => makeAssetConfigTxnWithSuggestedParamsFromObject,
  makeAssetCreateTxnWithSuggestedParamsFromObject: () => makeAssetCreateTxnWithSuggestedParamsFromObject,
  makeAssetDestroyTxnWithSuggestedParamsFromObject: () => makeAssetDestroyTxnWithSuggestedParamsFromObject,
  makeAssetFreezeTxnWithSuggestedParamsFromObject: () => makeAssetFreezeTxnWithSuggestedParamsFromObject,
  makeAssetTransferTxnWithSuggestedParamsFromObject: () => makeAssetTransferTxnWithSuggestedParamsFromObject,
  makeBaseAssetConfigTxn: () => makeBaseAssetConfigTxn,
  makeBasicAccountTransactionSigner: () => makeBasicAccountTransactionSigner,
  makeEmptyTransactionSigner: () => makeEmptyTransactionSigner,
  makeKeyRegistrationTxnWithSuggestedParamsFromObject: () => makeKeyRegistrationTxnWithSuggestedParamsFromObject,
  makeLogicSigAccountTransactionSigner: () => makeLogicSigAccountTransactionSigner,
  makeMultiSigAccountTransactionSigner: () => makeMultiSigAccountTransactionSigner,
  makePaymentTxnWithSuggestedParamsFromObject: () => makePaymentTxnWithSuggestedParamsFromObject,
  masterDerivationKeyToMnemonic: () => masterDerivationKeyToMnemonic,
  mergeMultisigTransactions: () => mergeMultisigTransactions,
  microalgosToAlgos: () => microalgosToAlgos,
  mnemonicFromSeed: () => mnemonicFromSeed,
  mnemonicToMasterDerivationKey: () => mnemonicToMasterDerivationKey,
  mnemonicToSecretKey: () => mnemonicToSecretKey,
  modelsv2: () => types_exports,
  msgpackRawDecode: () => msgpackRawDecode,
  msgpackRawDecodeAsMap: () => msgpackRawDecodeAsMap,
  msgpackRawEncode: () => msgpackRawEncode,
  multisigAddress: () => multisigAddress,
  parseJSON: () => parseJSON,
  secretKeyToMnemonic: () => secretKeyToMnemonic,
  seedFromMnemonic: () => seedFromMnemonic,
  signBytes: () => signBytes,
  signLogicSigTransaction: () => signLogicSigTransaction,
  signLogicSigTransactionObject: () => signLogicSigTransactionObject,
  signMultisigTransaction: () => signMultisigTransaction,
  signTransaction: () => signTransaction,
  stringifyJSON: () => stringifyJSON,
  tealSign: () => tealSign,
  tealSignFromProgram: () => tealSignFromProgram,
  verifyBytes: () => verifyBytes,
  verifyMultisig: () => verifyMultisig,
  verifyTealSign: () => verifyTealSign,
  waitForConfirmation: () => waitForConfirmation
});

// node_modules/algosdk/dist/esm/nacl/naclWrappers.js
var import_tweetnacl = __toESM(require_nacl_fast(), 1);
var import_js_sha512 = __toESM(require_sha512(), 1);

// node_modules/algosdk/dist/esm/utils/utils.js
var import_json_bigint = __toESM(require_json_bigint(), 1);

// node_modules/algosdk/dist/esm/types/intDecoding.js
var IntDecoding;
(function(IntDecoding2) {
  IntDecoding2["UNSAFE"] = "unsafe";
  IntDecoding2["SAFE"] = "safe";
  IntDecoding2["MIXED"] = "mixed";
  IntDecoding2["BIGINT"] = "bigint";
})(IntDecoding || (IntDecoding = {}));
var intDecoding_default = IntDecoding;

// node_modules/algosdk/dist/esm/utils/utils.js
var JSONbig = (0, import_json_bigint.default)({
  useNativeBigInt: true,
  strict: true
});
function parseJSON(str, { intDecoding }) {
  if (intDecoding !== intDecoding_default.SAFE && intDecoding !== intDecoding_default.UNSAFE && intDecoding !== intDecoding_default.BIGINT && intDecoding !== intDecoding_default.MIXED) {
    throw new Error(`Invalid intDecoding option: ${intDecoding}`);
  }
  return JSONbig.parse(str, (_2, value) => {
    if (value != null && typeof value === "object" && Object.getPrototypeOf(value) == null) {
      Object.setPrototypeOf(value, Object.prototype);
    }
    if (typeof value === "bigint") {
      if (intDecoding === intDecoding_default.SAFE && value > Number.MAX_SAFE_INTEGER) {
        throw new Error(`Integer exceeds maximum safe integer: ${value.toString()}. Try parsing with a different intDecoding option.`);
      }
      if (intDecoding === intDecoding_default.BIGINT || intDecoding === intDecoding_default.MIXED && value > Number.MAX_SAFE_INTEGER) {
        return value;
      }
      return Number(value);
    }
    if (typeof value === "number") {
      if (intDecoding === intDecoding_default.BIGINT && Number.isInteger(value)) {
        return BigInt(value);
      }
    }
    return value;
  });
}
function stringifyJSON(value, replacer, space) {
  return JSONbig.stringify(value, replacer, space);
}
function arrayEqual(a2, b2) {
  if (a2.length !== b2.length) {
    return false;
  }
  return Array.from(a2).every((val, i2) => val === b2[i2]);
}
function concatArrays2(...arrs) {
  const size = arrs.reduce((sum, arr) => sum + arr.length, 0);
  const c2 = new Uint8Array(size);
  let offset = 0;
  for (let i2 = 0; i2 < arrs.length; i2++) {
    c2.set(arrs[i2], offset);
    offset += arrs[i2].length;
  }
  return c2;
}
function isNode3() {
  return (
    // @ts-ignore
    typeof process === "object" && // @ts-ignore
    typeof process.versions === "object" && // @ts-ignore
    typeof process.versions.node !== "undefined"
  );
}
function isReactNative() {
  const { navigator: navigator2 } = globalThis;
  if (typeof navigator2 === "object" && navigator2.product === "ReactNative") {
    return true;
  }
  return false;
}
function ensureSafeInteger(value) {
  if (typeof value === "undefined") {
    throw new Error("Value is undefined");
  }
  if (typeof value === "bigint") {
    if (value > BigInt(Number.MAX_SAFE_INTEGER) || value < BigInt(Number.MIN_SAFE_INTEGER)) {
      throw new Error(`BigInt value ${value} is not a safe integer`);
    }
    return Number(value);
  }
  if (typeof value === "number") {
    if (Number.isSafeInteger(value)) {
      return value;
    }
    throw new Error(`Value ${value} is not a safe integer`);
  }
  throw new Error(`Unexpected type ${typeof value}, ${value}`);
}
function ensureSafeUnsignedInteger(value) {
  const intValue = ensureSafeInteger(value);
  if (intValue < 0) {
    throw new Error(`Value ${intValue} is negative`);
  }
  return intValue;
}
function ensureBigInt(value) {
  if (typeof value === "undefined") {
    throw new Error("Value is undefined");
  }
  if (typeof value === "bigint") {
    return value;
  }
  if (typeof value === "number") {
    if (!Number.isSafeInteger(value)) {
      throw new Error(`Value ${value} is not a safe integer`);
    }
    return BigInt(value);
  }
  throw new Error(`Unexpected type ${typeof value}, ${value}`);
}
function ensureUint64(value) {
  const bigIntValue = ensureBigInt(value);
  if (bigIntValue < 0 || bigIntValue > BigInt("0xffffffffffffffff")) {
    throw new Error(`Value ${bigIntValue} is not a uint64`);
  }
  return bigIntValue;
}

// node_modules/algosdk/dist/esm/nacl/naclWrappers.js
function genericHash(arr) {
  return import_js_sha512.default.sha512_256.array(arr);
}
function randomBytes2(length) {
  if (isReactNative()) {
    console.warn(`It looks like you're running in react-native. In order to perform common crypto operations you will need to polyfill common operations such as crypto.getRandomValues`);
  }
  return import_tweetnacl.default.randomBytes(length);
}
function keyPairFromSeed(seed) {
  return import_tweetnacl.default.sign.keyPair.fromSeed(seed);
}
function keyPair() {
  const seed = randomBytes2(import_tweetnacl.default.box.secretKeyLength);
  return keyPairFromSeed(seed);
}
function isValidSignatureLength(len) {
  return len === import_tweetnacl.default.sign.signatureLength;
}
function keyPairFromSecretKey(sk) {
  return import_tweetnacl.default.sign.keyPair.fromSecretKey(sk);
}
function sign(msg, secretKey) {
  return import_tweetnacl.default.sign.detached(msg, secretKey);
}
function bytesEqual(a2, b2) {
  return import_tweetnacl.default.verify(a2, b2);
}
function verify(message, signature, verifyKey) {
  return import_tweetnacl.default.sign.detached.verify(message, signature, verifyKey);
}
var PUBLIC_KEY_LENGTH = import_tweetnacl.default.sign.publicKeyLength;
var SECRET_KEY_LENGTH = import_tweetnacl.default.sign.secretKeyLength;
var HASH_BYTES_LENGTH = 32;
var SEED_BTYES_LENGTH = 32;

// node_modules/algosdk/dist/esm/encoding/address.js
var import_hi_base32 = __toESM(require_base32(), 1);

// node_modules/algosdk/dist/esm/encoding/uint64.js
function encodeUint64(num) {
  const isInteger = typeof num === "bigint" || Number.isInteger(num);
  if (!isInteger || num < 0 || num > BigInt("0xffffffffffffffff")) {
    throw new Error("Input is not a 64-bit unsigned integer");
  }
  const encoding = new Uint8Array(8);
  const view = new DataView(encoding.buffer);
  view.setBigUint64(0, BigInt(num));
  return encoding;
}
function decodeUint64(data, decodingMode = "safe") {
  if (decodingMode !== "safe" && decodingMode !== "mixed" && decodingMode !== "bigint") {
    throw new Error(`Unknown decodingMode option: ${decodingMode}`);
  }
  if (data.byteLength === 0 || data.byteLength > 8) {
    throw new Error(`Data has unacceptable length. Expected length is between 1 and 8, got ${data.byteLength}`);
  }
  const padding = new Uint8Array(8 - data.byteLength);
  const encoding = concatArrays2(padding, data);
  const view = new DataView(encoding.buffer);
  const num = view.getBigUint64(0);
  const isBig = num > BigInt(Number.MAX_SAFE_INTEGER);
  if (decodingMode === "safe") {
    if (isBig) {
      throw new Error(`Integer exceeds maximum safe integer: ${num.toString()}. Try decoding with "mixed" or "safe" decodingMode.`);
    }
    return Number(num);
  }
  if (decodingMode === "mixed" && !isBig) {
    return Number(num);
  }
  return num;
}

// node_modules/algosdk/dist/esm/encoding/binarydata.js
function base64ToBytes(base64String) {
  if (isNode3()) {
    return new Uint8Array(Buffer.from(base64String, "base64"));
  }
  const binString = atob(base64String);
  return Uint8Array.from(binString, (m2) => m2.codePointAt(0));
}
function bytesToBase64(byteArray) {
  if (isNode3()) {
    return Buffer.from(byteArray).toString("base64");
  }
  const binString = Array.from(byteArray, (x2) => String.fromCodePoint(x2)).join("");
  return btoa(binString);
}
function bytesToString(byteArray) {
  return new TextDecoder().decode(byteArray);
}
function coerceToBytes(input) {
  if (typeof input === "string") {
    return new TextEncoder().encode(input);
  }
  return input;
}
function bytesToHex(byteArray) {
  if (isNode3()) {
    return Buffer.from(byteArray).toString("hex");
  }
  return Array.from(byteArray).map((i2) => i2.toString(16).padStart(2, "0")).join("");
}
function hexToBytes(hexString) {
  if (isNode3()) {
    return Buffer.from(hexString, "hex");
  }
  let hex = hexString;
  if (hexString.length % 2 !== 0) {
    hex = hexString.padStart(1, "0");
  }
  const byteArray = new Uint8Array(hex.length / 2);
  for (let i2 = 0; i2 < hex.length / 2; i2++) {
    byteArray[i2] = parseInt(hex.slice(2 * i2, 2 * i2 + 2), 16);
  }
  return byteArray;
}

// node_modules/algosdk/dist/esm/encoding/address.js
var ALGORAND_ADDRESS_BYTE_LENGTH = 36;
var ALGORAND_CHECKSUM_BYTE_LENGTH = 4;
var ALGORAND_ADDRESS_LENGTH = 58;
var ALGORAND_ZERO_ADDRESS_STRING = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY5HFKQ";
var MALFORMED_ADDRESS_ERROR_MSG = "address seems to be malformed";
var CHECKSUM_ADDRESS_ERROR_MSG = "wrong checksum for address";
function checksumFromPublicKey(pk) {
  return Uint8Array.from(genericHash(pk).slice(HASH_BYTES_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH, HASH_BYTES_LENGTH));
}
var Address = class _Address {
  /**
   * Create a new Address object from its binary form.
   * @param publicKey - The binary form of the address. Must be 32 bytes.
   */
  constructor(publicKey) {
    if (!(publicKey instanceof Uint8Array)) {
      throw new Error(`${MALFORMED_ADDRESS_ERROR_MSG}: ${publicKey} is not Uint8Array, type ${typeof publicKey}`);
    }
    if (publicKey.length !== ALGORAND_ADDRESS_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH)
      throw new Error(`${MALFORMED_ADDRESS_ERROR_MSG}: 0x${bytesToHex(publicKey)}, length ${publicKey.length}`);
    this.publicKey = publicKey;
  }
  /**
   * Check if the address is equal to another address.
   */
  equals(other) {
    return other instanceof _Address && arrayEqual(this.publicKey, other.publicKey);
  }
  /**
   * Compute the 4 byte checksum of the address.
   */
  checksum() {
    return checksumFromPublicKey(this.publicKey);
  }
  /**
   * Encode the address into a string form.
   */
  toString() {
    const addr = import_hi_base32.default.encode(concatArrays2(this.publicKey, this.checksum()));
    return addr.slice(0, ALGORAND_ADDRESS_LENGTH);
  }
  /**
   * Decode an address from a string.
   * @param address - The address to decode. Must be 58 bytes long.
   * @returns An Address object corresponding to the input string.
   */
  static fromString(address) {
    if (typeof address !== "string")
      throw new Error(`${MALFORMED_ADDRESS_ERROR_MSG}: expected string, got ${typeof address}, ${address}`);
    if (address.length !== ALGORAND_ADDRESS_LENGTH)
      throw new Error(`${MALFORMED_ADDRESS_ERROR_MSG}: expected length ${ALGORAND_ADDRESS_LENGTH}, got ${address.length}: ${address}`);
    const decoded = import_hi_base32.default.decode.asBytes(address);
    if (decoded.length !== ALGORAND_ADDRESS_BYTE_LENGTH)
      throw new Error(`${MALFORMED_ADDRESS_ERROR_MSG}: expected byte length ${ALGORAND_ADDRESS_BYTE_LENGTH}, got ${decoded.length}`);
    const pk = new Uint8Array(decoded.slice(0, ALGORAND_ADDRESS_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH));
    const cs = new Uint8Array(decoded.slice(PUBLIC_KEY_LENGTH, ALGORAND_ADDRESS_BYTE_LENGTH));
    const checksum = checksumFromPublicKey(pk);
    if (!arrayEqual(checksum, cs))
      throw new Error(CHECKSUM_ADDRESS_ERROR_MSG);
    return new _Address(pk);
  }
  /**
   * Get the zero address.
   */
  static zeroAddress() {
    return new _Address(new Uint8Array(ALGORAND_ADDRESS_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH));
  }
};
function decodeAddress(address) {
  return Address.fromString(address);
}
function isValidAddress2(address) {
  try {
    Address.fromString(address);
  } catch (e2) {
    return false;
  }
  return true;
}
function encodeAddress(address) {
  return new Address(address).toString();
}
var APP_ID_PREFIX = new TextEncoder().encode("appID");
function getApplicationAddress(appID) {
  const toBeSigned = concatArrays2(APP_ID_PREFIX, encodeUint64(appID));
  const hash = genericHash(toBeSigned);
  return new Address(Uint8Array.from(hash));
}

// node_modules/algosdk/dist/esm/convert.js
var MICROALGOS_TO_ALGOS_RATIO = 1e6;
var INVALID_MICROALGOS_ERROR_MSG = "Microalgos should be positive and less than 2^53 - 1.";
function microalgosToAlgos(microalgos) {
  if (microalgos < 0 || !Number.isSafeInteger(microalgos)) {
    throw new Error(INVALID_MICROALGOS_ERROR_MSG);
  }
  return microalgos / MICROALGOS_TO_ALGOS_RATIO;
}
function algosToMicroalgos(algos) {
  const microalgos = algos * MICROALGOS_TO_ALGOS_RATIO;
  return Math.round(microalgos);
}

// node_modules/algosdk/dist/esm/client/urlTokenBaseHTTPClient.js
var URLTokenBaseHTTPError = class extends Error {
  constructor(message, response) {
    super(message);
    this.response = response;
    this.name = "URLTokenBaseHTTPError";
    this.response = response;
  }
};
var URLTokenBaseHTTPClient = class _URLTokenBaseHTTPClient {
  constructor(tokenHeader, baseServer, port, defaultHeaders = {}) {
    this.defaultHeaders = defaultHeaders;
    const fixedBaseServer = baseServer.endsWith("/") ? baseServer : `${baseServer}/`;
    const baseServerURL = new URL(fixedBaseServer);
    if (typeof port !== "undefined") {
      baseServerURL.port = port.toString();
    }
    if (baseServerURL.protocol.length === 0) {
      throw new Error("Invalid base server URL, protocol must be defined.");
    }
    this.baseURL = baseServerURL;
    this.tokenHeader = tokenHeader;
  }
  /**
   * Compute the URL for a path relative to the instance's address
   * @param relativePath - A path string
   * @param query - An optional key-value object of query parameters to add to the URL. If the
   *   relativePath already has query parameters on it, the additional parameters defined here will
   *   be added to the URL without modifying those (unless a key collision occurs).
   * @returns A URL string
   */
  getURL(relativePath, query) {
    let fixedRelativePath;
    if (relativePath.startsWith("./")) {
      fixedRelativePath = relativePath;
    } else if (relativePath.startsWith("/")) {
      fixedRelativePath = `.${relativePath}`;
    } else {
      fixedRelativePath = `./${relativePath}`;
    }
    const address = new URL(fixedRelativePath, this.baseURL);
    if (query) {
      for (const [key, value] of Object.entries(query)) {
        address.searchParams.set(key, value.toString());
      }
    }
    return address.toString();
  }
  static formatFetchResponseHeaders(headers) {
    const headersObj = {};
    headers.forEach((key, value) => {
      headersObj[key] = value;
    });
    return headersObj;
  }
  static async checkHttpError(res) {
    if (res.ok) {
      return;
    }
    let body;
    let bodyErrorMessage;
    try {
      body = new Uint8Array(await res.arrayBuffer());
      const decoded = JSON.parse(new TextDecoder().decode(body));
      if (decoded.message) {
        bodyErrorMessage = decoded.message;
      }
    } catch (_2) {
    }
    let message = `Network request error. Received status ${res.status} (${res.statusText})`;
    if (bodyErrorMessage) {
      message += `: ${bodyErrorMessage}`;
    }
    throw new URLTokenBaseHTTPError(message, {
      body: body ?? new Uint8Array(),
      status: res.status,
      headers: _URLTokenBaseHTTPClient.formatFetchResponseHeaders(res.headers)
    });
  }
  static async formatFetchResponse(res) {
    await this.checkHttpError(res);
    return {
      body: new Uint8Array(await res.arrayBuffer()),
      status: res.status,
      headers: _URLTokenBaseHTTPClient.formatFetchResponseHeaders(res.headers)
    };
  }
  async get(relativePath, query, requestHeaders, customOptions) {
    const headers = {
      ...this.tokenHeader,
      ...this.defaultHeaders,
      ...requestHeaders ?? {}
    };
    const res = await fetch(this.getURL(relativePath, query), {
      headers,
      ...customOptions ?? {}
    });
    return _URLTokenBaseHTTPClient.formatFetchResponse(res);
  }
  async post(relativePath, data, query, requestHeaders, customOptions) {
    const headers = {
      ...this.tokenHeader,
      ...this.defaultHeaders,
      ...requestHeaders ?? {}
    };
    const res = await fetch(this.getURL(relativePath, query), {
      method: "POST",
      body: data,
      headers,
      ...customOptions ?? {}
    });
    return _URLTokenBaseHTTPClient.formatFetchResponse(res);
  }
  async delete(relativePath, data, query, requestHeaders, customOptions) {
    const headers = {
      ...this.tokenHeader,
      ...this.defaultHeaders,
      ...requestHeaders ?? {}
    };
    const res = await fetch(this.getURL(relativePath, query), {
      method: "DELETE",
      body: data,
      headers,
      ...customOptions ?? {}
    });
    return _URLTokenBaseHTTPClient.formatFetchResponse(res);
  }
};

// node_modules/algosdk/dist/esm/client/client.js
var HTTPClientResponse = class {
  constructor(options) {
    this.body = options.body;
    this.text = options.text;
    this.format = options.format;
    this.headers = options.headers;
    this.status = options.status;
    this.ok = options.ok;
  }
  /**
   * Returns the response body as a string, ready to be parsed as JSON.
   */
  getJSONText() {
    if (this.text === void 0) {
      throw new Error(`Response body does not contain JSON data. Format is ${this.format}`);
    }
    return this.text;
  }
  /**
   * Parses the response body as JSON with the given options.
   */
  parseBodyAsJSON(jsonOptions) {
    if (this.text === void 0) {
      throw new Error(`Response body does not contain JSON data. Format is ${this.format}`);
    }
    return HTTPClient.parseJSON(this.text, this.status, jsonOptions);
  }
};
function removeFalsyOrEmpty(obj) {
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      if (!obj[key] || obj[key].length === 0)
        delete obj[key];
    }
  }
  return obj;
}
function tolowerCaseKeys(o3) {
  return Object.keys(o3).reduce((c2, k2) => (c2[k2.toLowerCase()] = o3[k2], c2), {});
}
function getAcceptFormat(query) {
  if (query !== void 0 && Object.prototype.hasOwnProperty.call(query, "format")) {
    switch (query.format) {
      case "msgpack":
        return "application/msgpack";
      case "json":
      default:
        return "application/json";
    }
  } else
    return "application/json";
}
var HTTPClient = class _HTTPClient {
  constructor(bcOrTokenHeader, baseServer, port, defaultHeaders = {}) {
    if (baseServer !== void 0) {
      this.bc = new URLTokenBaseHTTPClient(bcOrTokenHeader, baseServer, port, defaultHeaders);
    } else {
      this.bc = bcOrTokenHeader;
    }
  }
  /**
   * Parse JSON using utils.parseJSON
   *
   * @param text - JSON data
   * @param status - Status of the response (used in case parseJSON fails)
   * @param jsonOptions - Options object to use to decode JSON responses. See
   *   utils.parseJSON for the options available.
   */
  static parseJSON(text, status, jsonOptions) {
    try {
      if (!text) {
        return null;
      }
      return parseJSON(text, jsonOptions);
    } catch (err_) {
      const err = err_;
      err.rawResponse = text || null;
      err.statusCode = status;
      throw err;
    }
  }
  /**
   * Serialize the data according to the requestHeaders
   * Assumes that requestHeaders contain a key "content-type"
   * If the content-type is "application/json", data is JSON serialized
   * Otherwise, data needs to be either an UTF-8 string that is converted to an Uint8Array
   * or an Uint8Array
   * @private
   */
  static serializeData(data, requestHeaders) {
    if (!data) {
      return new Uint8Array(0);
    }
    if (requestHeaders["content-type"] === "application/json") {
      return new TextEncoder().encode(stringifyJSON(data));
    }
    if (typeof data === "string") {
      return new TextEncoder().encode(data);
    }
    if (data instanceof Uint8Array) {
      return data;
    }
    throw new Error("provided data is neither a string nor a Uint8Array and content-type is not application/json");
  }
  /**
   * Convert a BaseHTTPClientResponse into a full HTTPClientResponse
   * Parse the body in
   * Modifies in place res and return the result
   */
  static prepareResponse(res, format) {
    const { body } = res;
    let text;
    if (format !== "application/msgpack") {
      text = body && new TextDecoder().decode(body) || "";
    }
    return new HTTPClientResponse({
      ...res,
      format,
      text,
      ok: Math.trunc(res.status / 100) === 2
    });
  }
  /**
   * Prepare an error with a response
   * (the type of errors BaseHTTPClient are supposed to throw)
   * by adding the status and preparing the internal response
   * @private
   */
  static prepareResponseError(err) {
    if (err.response) {
      err.response = _HTTPClient.prepareResponse(err.response, "application/json");
      err.status = err.response.status;
    }
    return err;
  }
  /**
   * Send a GET request.
   *
   * @param options - The options to use for the request.
   * @param options.relativePath - The path of the request.
   * @param options.query - An object containing the query parameters of the request.
   * @param options.requestHeaders - An object containing additional request headers to use.
   *   or not.
   * @param options.customOptions - An object containing additional options to pass to the
   *   underlying BaseHTTPClient instance.
   * @returns Response object.
   */
  async get({ relativePath, query, requestHeaders, customOptions }) {
    const format = getAcceptFormat(query);
    const fullHeaders = { ...requestHeaders ?? {}, accept: format };
    try {
      const res = await this.bc.get(relativePath, query ? removeFalsyOrEmpty(query) : void 0, fullHeaders, customOptions);
      return _HTTPClient.prepareResponse(res, format);
    } catch (err) {
      throw _HTTPClient.prepareResponseError(err);
    }
  }
  /**
   * Send a POST request.
   * If no content-type present, adds the header "content-type: application/json"
   * and data is serialized in JSON (if not empty)
   * @param options - The options to use for the request.
   */
  async post({ relativePath, data, query, requestHeaders, customOptions }) {
    const fullHeaders = {
      "content-type": "application/json",
      ...tolowerCaseKeys(requestHeaders ?? {})
    };
    try {
      const res = await this.bc.post(relativePath, _HTTPClient.serializeData(data, fullHeaders), query, fullHeaders, customOptions);
      return _HTTPClient.prepareResponse(res, "application/json");
    } catch (err) {
      throw _HTTPClient.prepareResponseError(err);
    }
  }
  /**
   * Send a DELETE request.
   * If no content-type present, adds the header "content-type: application/json"
   * and data is serialized in JSON (if not empty)
   * @param options - The options to use for the request.
   */
  async delete({ relativePath, data, requestHeaders, customOptions }) {
    const fullHeaders = {
      "content-type": "application/json",
      ...tolowerCaseKeys(requestHeaders ?? {})
    };
    try {
      const res = await this.bc.delete(relativePath, typeof data !== "undefined" ? _HTTPClient.serializeData(data, fullHeaders) : void 0, void 0, fullHeaders, customOptions);
      return _HTTPClient.prepareResponse(res, "application/json");
    } catch (err) {
      throw _HTTPClient.prepareResponseError(err);
    }
  }
};

// node_modules/algosdk/dist/esm/client/v2/serviceClient.js
function convertTokenStringToTokenHeader(headerIdentifier, token = "") {
  const tokenHeader = {};
  if (token === "") {
    return tokenHeader;
  }
  tokenHeader[headerIdentifier] = token;
  return tokenHeader;
}
function isBaseHTTPClient(tbc) {
  return typeof tbc.get === "function";
}
var ServiceClient = class {
  constructor(tokenHeaderIdentifier, tokenHeaderOrStrOrBaseClient, baseServer, port, defaultHeaders = {}) {
    if (isBaseHTTPClient(tokenHeaderOrStrOrBaseClient)) {
      this.c = new HTTPClient(tokenHeaderOrStrOrBaseClient);
    } else {
      let tokenHeader;
      if (typeof tokenHeaderOrStrOrBaseClient === "string") {
        tokenHeader = convertTokenStringToTokenHeader(tokenHeaderIdentifier, tokenHeaderOrStrOrBaseClient);
      } else {
        tokenHeader = tokenHeaderOrStrOrBaseClient;
      }
      this.c = new HTTPClient(tokenHeader, baseServer, port, defaultHeaders);
    }
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/models/types.js
var types_exports = {};
__export(types_exports, {
  Account: () => Account,
  AccountApplicationResponse: () => AccountApplicationResponse,
  AccountAssetHolding: () => AccountAssetHolding,
  AccountAssetResponse: () => AccountAssetResponse,
  AccountAssetsInformationResponse: () => AccountAssetsInformationResponse,
  AccountParticipation: () => AccountParticipation,
  AccountStateDelta: () => AccountStateDelta,
  AppCallLogs: () => AppCallLogs,
  Application: () => Application,
  ApplicationInitialStates: () => ApplicationInitialStates,
  ApplicationKVStorage: () => ApplicationKVStorage,
  ApplicationLocalReference: () => ApplicationLocalReference,
  ApplicationLocalState: () => ApplicationLocalState,
  ApplicationParams: () => ApplicationParams,
  ApplicationStateOperation: () => ApplicationStateOperation,
  ApplicationStateSchema: () => ApplicationStateSchema,
  Asset: () => Asset,
  AssetHolding: () => AssetHolding2,
  AssetHoldingReference: () => AssetHoldingReference,
  AssetParams: () => AssetParams2,
  AvmKeyValue: () => AvmKeyValue,
  AvmValue: () => AvmValue,
  BlockHashResponse: () => BlockHashResponse,
  BlockLogsResponse: () => BlockLogsResponse,
  BlockResponse: () => BlockResponse,
  BlockTxidsResponse: () => BlockTxidsResponse,
  Box: () => Box,
  BoxDescriptor: () => BoxDescriptor,
  BoxReference: () => BoxReference,
  BoxesResponse: () => BoxesResponse,
  BuildVersion: () => BuildVersion,
  CompileResponse: () => CompileResponse,
  DisassembleResponse: () => DisassembleResponse,
  DryrunRequest: () => DryrunRequest,
  DryrunResponse: () => DryrunResponse,
  DryrunSource: () => DryrunSource,
  DryrunState: () => DryrunState,
  DryrunTxnResult: () => DryrunTxnResult,
  ErrorResponse: () => ErrorResponse,
  EvalDelta: () => EvalDelta2,
  EvalDeltaKeyValue: () => EvalDeltaKeyValue,
  Genesis: () => Genesis,
  GenesisAllocation: () => GenesisAllocation,
  GetBlockTimeStampOffsetResponse: () => GetBlockTimeStampOffsetResponse,
  GetSyncRoundResponse: () => GetSyncRoundResponse,
  LedgerStateDeltaForTransactionGroup: () => LedgerStateDeltaForTransactionGroup,
  LightBlockHeaderProof: () => LightBlockHeaderProof,
  NodeStatusResponse: () => NodeStatusResponse,
  PendingTransactionResponse: () => PendingTransactionResponse,
  PendingTransactionsResponse: () => PendingTransactionsResponse,
  PostTransactionsResponse: () => PostTransactionsResponse,
  ScratchChange: () => ScratchChange,
  SimulateInitialStates: () => SimulateInitialStates,
  SimulateRequest: () => SimulateRequest,
  SimulateRequestTransactionGroup: () => SimulateRequestTransactionGroup,
  SimulateResponse: () => SimulateResponse,
  SimulateTraceConfig: () => SimulateTraceConfig,
  SimulateTransactionGroupResult: () => SimulateTransactionGroupResult,
  SimulateTransactionResult: () => SimulateTransactionResult,
  SimulateUnnamedResourcesAccessed: () => SimulateUnnamedResourcesAccessed,
  SimulationEvalOverrides: () => SimulationEvalOverrides,
  SimulationOpcodeTraceUnit: () => SimulationOpcodeTraceUnit,
  SimulationTransactionExecTrace: () => SimulationTransactionExecTrace,
  StateProof: () => StateProof2,
  StateProofMessage: () => StateProofMessage2,
  SupplyResponse: () => SupplyResponse,
  TealKeyValue: () => TealKeyValue,
  TealValue: () => TealValue2,
  TransactionGroupLedgerStateDeltasForRoundResponse: () => TransactionGroupLedgerStateDeltasForRoundResponse,
  TransactionParametersResponse: () => TransactionParametersResponse,
  TransactionProof: () => TransactionProof,
  Version: () => Version
});

// node_modules/algorand-msgpack/dist.es5+esm/utils/utf8.mjs
function utf8Count(str) {
  var strLength = str.length;
  var byteLength = 0;
  var pos = 0;
  while (pos < strLength) {
    var value = str.charCodeAt(pos++);
    if ((value & 4294967168) === 0) {
      byteLength++;
      continue;
    } else if ((value & 4294965248) === 0) {
      byteLength += 2;
    } else {
      if (value >= 55296 && value <= 56319) {
        if (pos < strLength) {
          var extra = str.charCodeAt(pos);
          if ((extra & 64512) === 56320) {
            ++pos;
            value = ((value & 1023) << 10) + (extra & 1023) + 65536;
          }
        }
      }
      if ((value & 4294901760) === 0) {
        byteLength += 3;
      } else {
        byteLength += 4;
      }
    }
  }
  return byteLength;
}
function utf8EncodeJs(str, output, outputOffset) {
  var strLength = str.length;
  var offset = outputOffset;
  var pos = 0;
  while (pos < strLength) {
    var value = str.charCodeAt(pos++);
    if ((value & 4294967168) === 0) {
      output[offset++] = value;
      continue;
    } else if ((value & 4294965248) === 0) {
      output[offset++] = value >> 6 & 31 | 192;
    } else {
      if (value >= 55296 && value <= 56319) {
        if (pos < strLength) {
          var extra = str.charCodeAt(pos);
          if ((extra & 64512) === 56320) {
            ++pos;
            value = ((value & 1023) << 10) + (extra & 1023) + 65536;
          }
        }
      }
      if ((value & 4294901760) === 0) {
        output[offset++] = value >> 12 & 15 | 224;
        output[offset++] = value >> 6 & 63 | 128;
      } else {
        output[offset++] = value >> 18 & 7 | 240;
        output[offset++] = value >> 12 & 63 | 128;
        output[offset++] = value >> 6 & 63 | 128;
      }
    }
    output[offset++] = value & 63 | 128;
  }
}
var sharedTextEncoder = new TextEncoder();
var TEXT_ENCODER_THRESHOLD = 50;
function utf8EncodeTE(str, output, outputOffset) {
  sharedTextEncoder.encodeInto(str, output.subarray(outputOffset));
}
function utf8Encode(str, output, outputOffset) {
  if (str.length > TEXT_ENCODER_THRESHOLD) {
    utf8EncodeTE(str, output, outputOffset);
  } else {
    utf8EncodeJs(str, output, outputOffset);
  }
}
var CHUNK_SIZE = 4096;
function utf8DecodeJs(bytes, inputOffset, byteLength) {
  var offset = inputOffset;
  var end = offset + byteLength;
  var units = [];
  var result = "";
  while (offset < end) {
    var byte1 = bytes[offset++];
    if ((byte1 & 128) === 0) {
      units.push(byte1);
    } else if ((byte1 & 224) === 192) {
      var byte2 = bytes[offset++] & 63;
      units.push((byte1 & 31) << 6 | byte2);
    } else if ((byte1 & 240) === 224) {
      var byte2 = bytes[offset++] & 63;
      var byte3 = bytes[offset++] & 63;
      units.push((byte1 & 31) << 12 | byte2 << 6 | byte3);
    } else if ((byte1 & 248) === 240) {
      var byte2 = bytes[offset++] & 63;
      var byte3 = bytes[offset++] & 63;
      var byte4 = bytes[offset++] & 63;
      var unit = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;
      if (unit > 65535) {
        unit -= 65536;
        units.push(unit >>> 10 & 1023 | 55296);
        unit = 56320 | unit & 1023;
      }
      units.push(unit);
    } else {
      units.push(byte1);
    }
    if (units.length >= CHUNK_SIZE) {
      result += String.fromCharCode.apply(String, units);
      units.length = 0;
    }
  }
  if (units.length > 0) {
    result += String.fromCharCode.apply(String, units);
  }
  return result;
}
var sharedTextDecoder = new TextDecoder();
var TEXT_DECODER_THRESHOLD = 200;
function utf8DecodeTD(bytes, inputOffset, byteLength) {
  var stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);
  return sharedTextDecoder.decode(stringBytes);
}
function utf8Decode(bytes, inputOffset, byteLength) {
  if (byteLength > TEXT_DECODER_THRESHOLD) {
    return utf8DecodeTD(bytes, inputOffset, byteLength);
  } else {
    return utf8DecodeJs(bytes, inputOffset, byteLength);
  }
}

// node_modules/algorand-msgpack/dist.es5+esm/ExtData.mjs
var ExtData = (
  /** @class */
  /* @__PURE__ */ (function() {
    function ExtData2(type, data) {
      this.type = type;
      this.data = data;
    }
    return ExtData2;
  })()
);

// node_modules/algorand-msgpack/dist.es5+esm/DecodeError.mjs
var __extends2 = /* @__PURE__ */ (function() {
  var extendStatics2 = function(d2, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3) if (Object.prototype.hasOwnProperty.call(b3, p2)) d3[p2] = b3[p2];
    };
    return extendStatics2(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics2(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
})();
var DecodeError = (
  /** @class */
  (function(_super) {
    __extends2(DecodeError2, _super);
    function DecodeError2(message) {
      var _this = _super.call(this, message) || this;
      var proto = Object.create(DecodeError2.prototype);
      Object.setPrototypeOf(_this, proto);
      Object.defineProperty(_this, "name", {
        configurable: true,
        enumerable: false,
        value: DecodeError2.name
      });
      return _this;
    }
    return DecodeError2;
  })(Error)
);

// node_modules/algorand-msgpack/dist.es5+esm/utils/int.mjs
var IntMode;
(function(IntMode2) {
  IntMode2[IntMode2["UNSAFE_NUMBER"] = 0] = "UNSAFE_NUMBER";
  IntMode2[IntMode2["SAFE_NUMBER"] = 1] = "SAFE_NUMBER";
  IntMode2[IntMode2["AS_ENCODED"] = 2] = "AS_ENCODED";
  IntMode2[IntMode2["MIXED"] = 3] = "MIXED";
  IntMode2[IntMode2["BIGINT"] = 4] = "BIGINT";
})(IntMode || (IntMode = {}));
var UINT32_MAX = 4294967295;
function setUint64(view, offset, value) {
  var high = value / 4294967296;
  var low = value;
  view.setUint32(offset, high);
  view.setUint32(offset + 4, low);
}
function setInt64(view, offset, value) {
  var high = Math.floor(value / 4294967296);
  var low = value;
  view.setUint32(offset, high);
  view.setUint32(offset + 4, low);
}
function getInt64(view, offset, mode) {
  if (mode === IntMode.UNSAFE_NUMBER || mode === IntMode.SAFE_NUMBER) {
    var high = view.getInt32(offset);
    var low = view.getUint32(offset + 4);
    if (mode === IntMode.SAFE_NUMBER && (high < Math.floor(Number.MIN_SAFE_INTEGER / 4294967296) || high === Math.floor(Number.MIN_SAFE_INTEGER / 4294967296) && low === 0 || high > (Number.MAX_SAFE_INTEGER - low) / 4294967296)) {
      var hexValue = "".concat(high < 0 ? "-" : "", "0x").concat(Math.abs(high).toString(16)).concat(low.toString(16).padStart(8, "0"));
      throw new Error("Mode is IntMode.SAFE_NUMBER and value is not a safe integer: ".concat(hexValue));
    }
    return high * 4294967296 + low;
  }
  var value = view.getBigInt64(offset);
  if (mode === IntMode.MIXED && value >= Number.MIN_SAFE_INTEGER && value <= Number.MAX_SAFE_INTEGER) {
    return Number(value);
  }
  return value;
}
function getUint64(view, offset, mode) {
  if (mode === IntMode.UNSAFE_NUMBER || mode === IntMode.SAFE_NUMBER) {
    var high = view.getUint32(offset);
    var low = view.getUint32(offset + 4);
    if (mode === IntMode.SAFE_NUMBER && high > (Number.MAX_SAFE_INTEGER - low) / 4294967296) {
      var hexValue = "0x".concat(high.toString(16)).concat(low.toString(16).padStart(8, "0"));
      throw new Error("Mode is IntMode.SAFE_NUMBER and value is not a safe integer: ".concat(hexValue));
    }
    return high * 4294967296 + low;
  }
  var value = view.getBigUint64(offset);
  if (mode === IntMode.MIXED && value <= Number.MAX_SAFE_INTEGER) {
    return Number(value);
  }
  return value;
}
function convertSafeIntegerToMode(value, mode) {
  if (mode === IntMode.BIGINT) {
    return BigInt(value);
  }
  return Number(value);
}

// node_modules/algorand-msgpack/dist.es5+esm/timestamp.mjs
var EXT_TIMESTAMP = -1;
var TIMESTAMP32_MAX_SEC = 4294967296 - 1;
var TIMESTAMP64_MAX_SEC = 17179869184 - 1;
function encodeTimeSpecToTimestamp(_a) {
  var sec = _a.sec, nsec = _a.nsec;
  if (sec >= 0 && nsec >= 0 && sec <= TIMESTAMP64_MAX_SEC) {
    if (nsec === 0 && sec <= TIMESTAMP32_MAX_SEC) {
      var rv = new Uint8Array(4);
      var view = new DataView(rv.buffer);
      view.setUint32(0, sec);
      return rv;
    } else {
      var secHigh = sec / 4294967296;
      var secLow = sec & 4294967295;
      var rv = new Uint8Array(8);
      var view = new DataView(rv.buffer);
      view.setUint32(0, nsec << 2 | secHigh & 3);
      view.setUint32(4, secLow);
      return rv;
    }
  } else {
    var rv = new Uint8Array(12);
    var view = new DataView(rv.buffer);
    view.setUint32(0, nsec);
    setInt64(view, 4, sec);
    return rv;
  }
}
function encodeDateToTimeSpec(date) {
  var msec = date.getTime();
  var sec = Math.floor(msec / 1e3);
  var nsec = (msec - sec * 1e3) * 1e6;
  var nsecInSec = Math.floor(nsec / 1e9);
  return {
    sec: sec + nsecInSec,
    nsec: nsec - nsecInSec * 1e9
  };
}
function encodeTimestampExtension(object) {
  if (object instanceof Date) {
    var timeSpec = encodeDateToTimeSpec(object);
    return encodeTimeSpecToTimestamp(timeSpec);
  } else {
    return null;
  }
}
function decodeTimestampToTimeSpec(data) {
  var view = new DataView(data.buffer, data.byteOffset, data.byteLength);
  switch (data.byteLength) {
    case 4: {
      var sec = view.getUint32(0);
      var nsec = 0;
      return { sec, nsec };
    }
    case 8: {
      var nsec30AndSecHigh2 = view.getUint32(0);
      var secLow32 = view.getUint32(4);
      var sec = (nsec30AndSecHigh2 & 3) * 4294967296 + secLow32;
      var nsec = nsec30AndSecHigh2 >>> 2;
      return { sec, nsec };
    }
    case 12: {
      var sec = getInt64(view, 4, IntMode.UNSAFE_NUMBER);
      var nsec = view.getUint32(0);
      return { sec, nsec };
    }
    default:
      throw new DecodeError("Unrecognized data size for timestamp (expected 4, 8, or 12): ".concat(data.length));
  }
}
function decodeTimestampExtension(data) {
  var timeSpec = decodeTimestampToTimeSpec(data);
  return new Date(timeSpec.sec * 1e3 + timeSpec.nsec / 1e6);
}
var timestampExtension = {
  type: EXT_TIMESTAMP,
  encode: encodeTimestampExtension,
  decode: decodeTimestampExtension
};

// node_modules/algorand-msgpack/dist.es5+esm/ExtensionCodec.mjs
var ExtensionCodec = (
  /** @class */
  (function() {
    function ExtensionCodec2() {
      this.builtInEncoders = [];
      this.builtInDecoders = [];
      this.encoders = [];
      this.decoders = [];
      this.register(timestampExtension);
    }
    ExtensionCodec2.prototype.register = function(_a) {
      var type = _a.type, encode2 = _a.encode, decode3 = _a.decode;
      if (type >= 0) {
        this.encoders[type] = encode2;
        this.decoders[type] = decode3;
      } else {
        var index = 1 + type;
        this.builtInEncoders[index] = encode2;
        this.builtInDecoders[index] = decode3;
      }
    };
    ExtensionCodec2.prototype.tryToEncode = function(object, context) {
      for (var i2 = 0; i2 < this.builtInEncoders.length; i2++) {
        var encodeExt = this.builtInEncoders[i2];
        if (encodeExt != null) {
          var data = encodeExt(object, context);
          if (data != null) {
            var type = -1 - i2;
            return new ExtData(type, data);
          }
        }
      }
      for (var i2 = 0; i2 < this.encoders.length; i2++) {
        var encodeExt = this.encoders[i2];
        if (encodeExt != null) {
          var data = encodeExt(object, context);
          if (data != null) {
            var type = i2;
            return new ExtData(type, data);
          }
        }
      }
      if (object instanceof ExtData) {
        return object;
      }
      return null;
    };
    ExtensionCodec2.prototype.decode = function(data, type, context) {
      var decodeExt = type < 0 ? this.builtInDecoders[-1 - type] : this.decoders[type];
      if (decodeExt) {
        return decodeExt(data, type, context);
      } else {
        return new ExtData(type, data);
      }
    };
    ExtensionCodec2.defaultCodec = new ExtensionCodec2();
    return ExtensionCodec2;
  })()
);

// node_modules/algorand-msgpack/dist.es5+esm/utils/typedArrays.mjs
function ensureUint8Array(buffer) {
  if (buffer instanceof Uint8Array) {
    return buffer;
  } else if (ArrayBuffer.isView(buffer)) {
    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
  } else if (buffer instanceof ArrayBuffer) {
    return new Uint8Array(buffer);
  } else {
    return Uint8Array.from(buffer);
  }
}
function createDataView(buffer) {
  if (buffer instanceof ArrayBuffer) {
    return new DataView(buffer);
  }
  var bufferView = ensureUint8Array(buffer);
  return new DataView(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);
}
function compareUint8Arrays(a2, b2) {
  var length = Math.min(a2.length, b2.length);
  for (var i2 = 0; i2 < length; i2++) {
    var diff = a2[i2] - b2[i2];
    if (diff !== 0) {
      return diff;
    }
  }
  return a2.length - b2.length;
}
var RawBinaryString = (
  /** @class */
  /* @__PURE__ */ (function() {
    function RawBinaryString2(rawBinaryValue) {
      this.rawBinaryValue = rawBinaryValue;
      if (!ArrayBuffer.isView(rawBinaryValue)) {
        throw new TypeError("RawBinaryString: rawBinaryValue must be an ArrayBufferView");
      }
    }
    return RawBinaryString2;
  })()
);

// node_modules/algorand-msgpack/dist.es5+esm/Encoder.mjs
var DEFAULT_MAX_DEPTH = 100;
var DEFAULT_INITIAL_BUFFER_SIZE = 2048;
var Encoder = (
  /** @class */
  (function() {
    function Encoder2(options) {
      var _a, _b, _c, _d, _e, _f, _g, _h;
      this.extensionCodec = (_a = options === null || options === void 0 ? void 0 : options.extensionCodec) !== null && _a !== void 0 ? _a : ExtensionCodec.defaultCodec;
      this.context = options === null || options === void 0 ? void 0 : options.context;
      this.forceBigIntToInt64 = (_b = options === null || options === void 0 ? void 0 : options.forceBigIntToInt64) !== null && _b !== void 0 ? _b : false;
      this.maxDepth = (_c = options === null || options === void 0 ? void 0 : options.maxDepth) !== null && _c !== void 0 ? _c : DEFAULT_MAX_DEPTH;
      this.initialBufferSize = (_d = options === null || options === void 0 ? void 0 : options.initialBufferSize) !== null && _d !== void 0 ? _d : DEFAULT_INITIAL_BUFFER_SIZE;
      this.sortKeys = (_e = options === null || options === void 0 ? void 0 : options.sortKeys) !== null && _e !== void 0 ? _e : false;
      this.forceFloat32 = (_f = options === null || options === void 0 ? void 0 : options.forceFloat32) !== null && _f !== void 0 ? _f : false;
      this.ignoreUndefined = (_g = options === null || options === void 0 ? void 0 : options.ignoreUndefined) !== null && _g !== void 0 ? _g : false;
      this.forceIntegerToFloat = (_h = options === null || options === void 0 ? void 0 : options.forceIntegerToFloat) !== null && _h !== void 0 ? _h : false;
      this.pos = 0;
      this.view = new DataView(new ArrayBuffer(this.initialBufferSize));
      this.bytes = new Uint8Array(this.view.buffer);
    }
    Encoder2.prototype.reinitializeState = function() {
      this.pos = 0;
    };
    Encoder2.prototype.encodeSharedRef = function(object) {
      this.reinitializeState();
      this.doEncode(object, 1);
      return this.bytes.subarray(0, this.pos);
    };
    Encoder2.prototype.encode = function(object) {
      this.reinitializeState();
      this.doEncode(object, 1);
      return this.bytes.slice(0, this.pos);
    };
    Encoder2.prototype.doEncode = function(object, depth) {
      if (depth > this.maxDepth) {
        throw new Error("Too deep objects in depth ".concat(depth));
      }
      if (object == null) {
        this.encodeNil();
      } else if (typeof object === "boolean") {
        this.encodeBoolean(object);
      } else if (typeof object === "number") {
        this.encodeNumber(object);
      } else if (typeof object === "string") {
        this.encodeString(object);
      } else {
        this.encodeObject(object, depth);
      }
    };
    Encoder2.prototype.ensureBufferSizeToWrite = function(sizeToWrite) {
      var requiredSize = this.pos + sizeToWrite;
      if (this.view.byteLength < requiredSize) {
        this.resizeBuffer(requiredSize * 2);
      }
    };
    Encoder2.prototype.resizeBuffer = function(newSize) {
      var newBuffer = new ArrayBuffer(newSize);
      var newBytes = new Uint8Array(newBuffer);
      var newView = new DataView(newBuffer);
      newBytes.set(this.bytes);
      this.view = newView;
      this.bytes = newBytes;
    };
    Encoder2.prototype.encodeNil = function() {
      this.writeU8(192);
    };
    Encoder2.prototype.encodeBoolean = function(object) {
      if (object === false) {
        this.writeU8(194);
      } else {
        this.writeU8(195);
      }
    };
    Encoder2.prototype.encodeNumber = function(object) {
      if (!this.forceIntegerToFloat && Number.isSafeInteger(object)) {
        if (object >= 0) {
          if (object < 128) {
            this.writeU8(object);
          } else if (object < 256) {
            this.writeU8(204);
            this.writeU8(object);
          } else if (object < 65536) {
            this.writeU8(205);
            this.writeU16(object);
          } else if (object < 4294967296) {
            this.writeU8(206);
            this.writeU32(object);
          } else {
            this.writeU8(207);
            this.writeU64(object);
          }
        } else {
          if (object >= -32) {
            this.writeU8(224 | object + 32);
          } else if (object >= -128) {
            this.writeU8(208);
            this.writeI8(object);
          } else if (object >= -32768) {
            this.writeU8(209);
            this.writeI16(object);
          } else if (object >= -2147483648) {
            this.writeU8(210);
            this.writeI32(object);
          } else {
            this.writeU8(211);
            this.writeI64(object);
          }
        }
      } else {
        this.encodeNumberAsFloat(object);
      }
    };
    Encoder2.prototype.encodeNumberAsFloat = function(object) {
      if (this.forceFloat32) {
        this.writeU8(202);
        this.writeF32(object);
      } else {
        this.writeU8(203);
        this.writeF64(object);
      }
    };
    Encoder2.prototype.encodeBigInt = function(object) {
      if (this.forceBigIntToInt64) {
        this.encodeBigIntAsInt64(object);
      } else if (object >= 0) {
        if (object < 4294967296 || this.forceIntegerToFloat) {
          this.encodeNumber(Number(object));
        } else if (object < BigInt("0x10000000000000000")) {
          this.encodeBigIntAsInt64(object);
        } else {
          throw new Error("Bigint is too large for uint64: ".concat(object));
        }
      } else {
        if (object >= -2147483648 || this.forceIntegerToFloat) {
          this.encodeNumber(Number(object));
        } else if (object >= BigInt(-1) * BigInt("0x8000000000000000")) {
          this.encodeBigIntAsInt64(object);
        } else {
          throw new Error("Bigint is too small for int64: ".concat(object));
        }
      }
    };
    Encoder2.prototype.encodeBigIntAsInt64 = function(object) {
      if (object >= BigInt(0)) {
        this.writeU8(207);
        this.writeBigUint64(object);
      } else {
        this.writeU8(211);
        this.writeBigInt64(object);
      }
    };
    Encoder2.prototype.writeStringHeader = function(byteLength) {
      if (byteLength < 32) {
        this.writeU8(160 + byteLength);
      } else if (byteLength < 256) {
        this.writeU8(217);
        this.writeU8(byteLength);
      } else if (byteLength < 65536) {
        this.writeU8(218);
        this.writeU16(byteLength);
      } else if (byteLength < 4294967296) {
        this.writeU8(219);
        this.writeU32(byteLength);
      } else {
        throw new Error("Too long string: ".concat(byteLength, " bytes in UTF-8"));
      }
    };
    Encoder2.prototype.encodeString = function(object) {
      var maxHeaderSize = 1 + 4;
      var byteLength = utf8Count(object);
      this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);
      this.writeStringHeader(byteLength);
      utf8Encode(object, this.bytes, this.pos);
      this.pos += byteLength;
    };
    Encoder2.prototype.encodeObject = function(object, depth) {
      var ext = this.extensionCodec.tryToEncode(object, this.context);
      if (ext != null) {
        this.encodeExtension(ext);
      } else if (Array.isArray(object)) {
        this.encodeArray(object, depth);
      } else if (ArrayBuffer.isView(object)) {
        this.encodeBinary(object);
      } else if (object instanceof RawBinaryString) {
        this.encodeBinaryAsString(object);
      } else if (typeof object === "bigint") {
        this.encodeBigInt(object);
      } else if (object instanceof Map) {
        this.encodeMap(object, depth);
      } else if (typeof object === "object") {
        this.encodeMapObject(object, depth);
      } else {
        throw new Error("Unrecognized object: ".concat(Object.prototype.toString.apply(object)));
      }
    };
    Encoder2.prototype.encodeBinary = function(object) {
      var size = object.byteLength;
      if (size < 256) {
        this.writeU8(196);
        this.writeU8(size);
      } else if (size < 65536) {
        this.writeU8(197);
        this.writeU16(size);
      } else if (size < 4294967296) {
        this.writeU8(198);
        this.writeU32(size);
      } else {
        throw new Error("Too large binary: ".concat(size));
      }
      var bytes = ensureUint8Array(object);
      this.writeU8a(bytes);
    };
    Encoder2.prototype.encodeBinaryAsString = function(binaryString) {
      var object = binaryString.rawBinaryValue;
      this.writeStringHeader(object.byteLength);
      var bytes = ensureUint8Array(object);
      this.writeU8a(bytes);
    };
    Encoder2.prototype.encodeArray = function(object, depth) {
      var size = object.length;
      if (size < 16) {
        this.writeU8(144 + size);
      } else if (size < 65536) {
        this.writeU8(220);
        this.writeU16(size);
      } else if (size < 4294967296) {
        this.writeU8(221);
        this.writeU32(size);
      } else {
        throw new Error("Too large array: ".concat(size));
      }
      for (var _i = 0, object_1 = object; _i < object_1.length; _i++) {
        var item = object_1[_i];
        this.doEncode(item, depth + 1);
      }
    };
    Encoder2.prototype.countWithoutUndefined = function(map, keys) {
      var count = 0;
      for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
        var key = keys_1[_i];
        if (map.get(key) !== void 0) {
          count++;
        }
      }
      return count;
    };
    Encoder2.prototype.sortMapKeys = function(keys) {
      var numericKeys = [];
      var stringKeys = [];
      var rawStringKeys = [];
      var binaryKeys = [];
      for (var _i = 0, keys_2 = keys; _i < keys_2.length; _i++) {
        var key = keys_2[_i];
        if (typeof key === "number") {
          if (isNaN(key)) {
            throw new Error("Cannot sort map keys with NaN value");
          }
          numericKeys.push(key);
        } else if (typeof key === "bigint") {
          numericKeys.push(key);
        } else if (typeof key === "string") {
          stringKeys.push(key);
        } else if (ArrayBuffer.isView(key)) {
          binaryKeys.push(ensureUint8Array(key));
        } else if (key instanceof RawBinaryString) {
          rawStringKeys.push(key);
        } else {
          throw new Error("Unsupported map key type: ".concat(Object.prototype.toString.apply(key)));
        }
      }
      numericKeys.sort(function(a2, b2) {
        return a2 < b2 ? -1 : a2 > b2 ? 1 : 0;
      });
      stringKeys.sort();
      rawStringKeys.sort(function(a2, b2) {
        return compareUint8Arrays(ensureUint8Array(a2.rawBinaryValue), ensureUint8Array(b2.rawBinaryValue));
      });
      binaryKeys.sort(compareUint8Arrays);
      return [].concat(numericKeys, stringKeys, rawStringKeys, binaryKeys);
    };
    Encoder2.prototype.encodeMapObject = function(object, depth) {
      this.encodeMap(new Map(Object.entries(object)), depth);
    };
    Encoder2.prototype.encodeMap = function(map, depth) {
      var keys = Array.from(map.keys());
      if (this.sortKeys) {
        keys = this.sortMapKeys(keys);
      }
      var size = this.ignoreUndefined ? this.countWithoutUndefined(map, keys) : keys.length;
      if (size < 16) {
        this.writeU8(128 + size);
      } else if (size < 65536) {
        this.writeU8(222);
        this.writeU16(size);
      } else if (size < 4294967296) {
        this.writeU8(223);
        this.writeU32(size);
      } else {
        throw new Error("Too large map object: ".concat(size));
      }
      for (var _i = 0, keys_3 = keys; _i < keys_3.length; _i++) {
        var key = keys_3[_i];
        var value = map.get(key);
        if (!(this.ignoreUndefined && value === void 0)) {
          if (typeof key === "string") {
            this.encodeString(key);
          } else if (typeof key === "number") {
            this.encodeNumber(key);
          } else if (typeof key === "bigint") {
            this.encodeBigInt(key);
          } else if (ArrayBuffer.isView(key)) {
            this.encodeBinary(key);
          } else if (key instanceof RawBinaryString) {
            this.encodeBinaryAsString(key);
          } else {
            throw new Error("Unsupported map key type: ".concat(Object.prototype.toString.apply(key)));
          }
          this.doEncode(value, depth + 1);
        }
      }
    };
    Encoder2.prototype.encodeExtension = function(ext) {
      var size = ext.data.length;
      if (size === 1) {
        this.writeU8(212);
      } else if (size === 2) {
        this.writeU8(213);
      } else if (size === 4) {
        this.writeU8(214);
      } else if (size === 8) {
        this.writeU8(215);
      } else if (size === 16) {
        this.writeU8(216);
      } else if (size < 256) {
        this.writeU8(199);
        this.writeU8(size);
      } else if (size < 65536) {
        this.writeU8(200);
        this.writeU16(size);
      } else if (size < 4294967296) {
        this.writeU8(201);
        this.writeU32(size);
      } else {
        throw new Error("Too large extension object: ".concat(size));
      }
      this.writeI8(ext.type);
      this.writeU8a(ext.data);
    };
    Encoder2.prototype.writeU8 = function(value) {
      this.ensureBufferSizeToWrite(1);
      this.view.setUint8(this.pos, value);
      this.pos++;
    };
    Encoder2.prototype.writeU8a = function(values) {
      var size = values.length;
      this.ensureBufferSizeToWrite(size);
      this.bytes.set(values, this.pos);
      this.pos += size;
    };
    Encoder2.prototype.writeI8 = function(value) {
      this.ensureBufferSizeToWrite(1);
      this.view.setInt8(this.pos, value);
      this.pos++;
    };
    Encoder2.prototype.writeU16 = function(value) {
      this.ensureBufferSizeToWrite(2);
      this.view.setUint16(this.pos, value);
      this.pos += 2;
    };
    Encoder2.prototype.writeI16 = function(value) {
      this.ensureBufferSizeToWrite(2);
      this.view.setInt16(this.pos, value);
      this.pos += 2;
    };
    Encoder2.prototype.writeU32 = function(value) {
      this.ensureBufferSizeToWrite(4);
      this.view.setUint32(this.pos, value);
      this.pos += 4;
    };
    Encoder2.prototype.writeI32 = function(value) {
      this.ensureBufferSizeToWrite(4);
      this.view.setInt32(this.pos, value);
      this.pos += 4;
    };
    Encoder2.prototype.writeF32 = function(value) {
      this.ensureBufferSizeToWrite(4);
      this.view.setFloat32(this.pos, value);
      this.pos += 4;
    };
    Encoder2.prototype.writeF64 = function(value) {
      this.ensureBufferSizeToWrite(8);
      this.view.setFloat64(this.pos, value);
      this.pos += 8;
    };
    Encoder2.prototype.writeU64 = function(value) {
      this.ensureBufferSizeToWrite(8);
      setUint64(this.view, this.pos, value);
      this.pos += 8;
    };
    Encoder2.prototype.writeI64 = function(value) {
      this.ensureBufferSizeToWrite(8);
      setInt64(this.view, this.pos, value);
      this.pos += 8;
    };
    Encoder2.prototype.writeBigUint64 = function(value) {
      this.ensureBufferSizeToWrite(8);
      this.view.setBigUint64(this.pos, value);
      this.pos += 8;
    };
    Encoder2.prototype.writeBigInt64 = function(value) {
      this.ensureBufferSizeToWrite(8);
      this.view.setBigInt64(this.pos, value);
      this.pos += 8;
    };
    return Encoder2;
  })()
);

// node_modules/algorand-msgpack/dist.es5+esm/encode.mjs
function encode(value, options) {
  var encoder = new Encoder(options);
  return encoder.encodeSharedRef(value);
}

// node_modules/algorand-msgpack/dist.es5+esm/utils/prettyByte.mjs
function prettyByte(byte) {
  return "".concat(byte < 0 ? "-" : "", "0x").concat(Math.abs(byte).toString(16).padStart(2, "0"));
}

// node_modules/algorand-msgpack/dist.es5+esm/CachedKeyDecoder.mjs
var DEFAULT_MAX_KEY_LENGTH = 16;
var DEFAULT_MAX_LENGTH_PER_KEY = 16;
var CachedKeyDecoder = (
  /** @class */
  (function() {
    function CachedKeyDecoder2(maxKeyLength, maxLengthPerKey) {
      if (maxKeyLength === void 0) {
        maxKeyLength = DEFAULT_MAX_KEY_LENGTH;
      }
      if (maxLengthPerKey === void 0) {
        maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY;
      }
      this.maxKeyLength = maxKeyLength;
      this.maxLengthPerKey = maxLengthPerKey;
      this.hit = 0;
      this.miss = 0;
      this.caches = [];
      for (var i2 = 0; i2 < this.maxKeyLength; i2++) {
        this.caches.push([]);
      }
    }
    CachedKeyDecoder2.prototype.canBeCached = function(byteLength) {
      return byteLength > 0 && byteLength <= this.maxKeyLength;
    };
    CachedKeyDecoder2.prototype.find = function(bytes, inputOffset, byteLength) {
      var records = this.caches[byteLength - 1];
      FIND_CHUNK: for (var _i = 0, records_1 = records; _i < records_1.length; _i++) {
        var record = records_1[_i];
        var recordBytes = record.bytes;
        for (var j2 = 0; j2 < byteLength; j2++) {
          if (recordBytes[j2] !== bytes[inputOffset + j2]) {
            continue FIND_CHUNK;
          }
        }
        return record.str;
      }
      return null;
    };
    CachedKeyDecoder2.prototype.store = function(bytes, value) {
      var records = this.caches[bytes.length - 1];
      var record = { bytes, str: value };
      if (records.length >= this.maxLengthPerKey) {
        records[Math.random() * records.length | 0] = record;
      } else {
        records.push(record);
      }
    };
    CachedKeyDecoder2.prototype.decode = function(bytes, inputOffset, byteLength) {
      var cachedValue = this.find(bytes, inputOffset, byteLength);
      if (cachedValue != null) {
        this.hit++;
        return cachedValue;
      }
      this.miss++;
      var str = utf8DecodeJs(bytes, inputOffset, byteLength);
      var slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);
      this.store(slicedCopyOfBytes, str);
      return str;
    };
    return CachedKeyDecoder2;
  })()
);

// node_modules/algorand-msgpack/dist.es5+esm/Decoder.mjs
var __awaiter2 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator2 = function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f2, y2, t, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2) throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2) try {
      if (f2 = 1, y2 && (t = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t = y2["return"]) && t.call(y2), 0) : y2.next) && !(t = t.call(y2, op[1])).done) return t;
      if (y2 = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _2.label++;
          return { value: op[1], done: false };
        case 5:
          _2.label++;
          y2 = op[1];
          op = [0];
          continue;
        case 7:
          op = _2.ops.pop();
          _2.trys.pop();
          continue;
        default:
          if (!(t = _2.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _2 = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _2.label = op[1];
            break;
          }
          if (op[0] === 6 && _2.label < t[1]) {
            _2.label = t[1];
            t = op;
            break;
          }
          if (t && _2.label < t[2]) {
            _2.label = t[2];
            _2.ops.push(op);
            break;
          }
          if (t[2]) _2.ops.pop();
          _2.trys.pop();
          continue;
      }
      op = body.call(thisArg, _2);
    } catch (e2) {
      op = [6, e2];
      y2 = 0;
    } finally {
      f2 = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __asyncValues2 = function(o3) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m2 = o3[Symbol.asyncIterator], i2;
  return m2 ? m2.call(o3) : (o3 = typeof __values === "function" ? __values(o3) : o3[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2);
  function verb(n2) {
    i2[n2] = o3[n2] && function(v2) {
      return new Promise(function(resolve, reject) {
        v2 = o3[n2](v2), settle(resolve, reject, v2.done, v2.value);
      });
    };
  }
  function settle(resolve, reject, d2, v2) {
    Promise.resolve(v2).then(function(v3) {
      resolve({ value: v3, done: d2 });
    }, reject);
  }
};
var __await2 = function(v2) {
  return this instanceof __await2 ? (this.v = v2, this) : new __await2(v2);
};
var __asyncGenerator2 = function(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g2 = generator.apply(thisArg, _arguments || []), i2, q2 = [];
  return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2;
  function verb(n2) {
    if (g2[n2]) i2[n2] = function(v2) {
      return new Promise(function(a2, b2) {
        q2.push([n2, v2, a2, b2]) > 1 || resume(n2, v2);
      });
    };
  }
  function resume(n2, v2) {
    try {
      step(g2[n2](v2));
    } catch (e2) {
      settle(q2[0][3], e2);
    }
  }
  function step(r3) {
    r3.value instanceof __await2 ? Promise.resolve(r3.value.v).then(fulfill, reject) : settle(q2[0][2], r3);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f2, v2) {
    if (f2(v2), q2.shift(), q2.length) resume(q2[0][0], q2[0][1]);
  }
};
var STATE_ARRAY = "array";
var STATE_MAP_KEY = "map_key";
var STATE_MAP_VALUE = "map_value";
function isValidMapKeyType(key, useMap, supportObjectNumberKeys) {
  if (useMap) {
    return typeof key === "string" || typeof key === "number" || typeof key === "bigint" || key instanceof Uint8Array || key instanceof RawBinaryString;
  }
  return typeof key === "string" || supportObjectNumberKeys && typeof key === "number";
}
var StackPool = (
  /** @class */
  (function() {
    function StackPool2(useMap) {
      this.useMap = useMap;
      this.stack = [];
      this.stackHeadPosition = -1;
    }
    Object.defineProperty(StackPool2.prototype, "length", {
      get: function() {
        return this.stackHeadPosition + 1;
      },
      enumerable: false,
      configurable: true
    });
    StackPool2.prototype.top = function() {
      return this.stack[this.stackHeadPosition];
    };
    StackPool2.prototype.pushArrayState = function(size) {
      var state = this.getUninitializedStateFromPool();
      state.type = STATE_ARRAY;
      state.position = 0;
      state.size = size;
      state.array = new Array(size);
    };
    StackPool2.prototype.pushMapState = function(size) {
      var state = this.getUninitializedStateFromPool();
      state.type = STATE_MAP_KEY;
      state.readCount = 0;
      state.size = size;
      state.map = this.useMap ? /* @__PURE__ */ new Map() : {};
    };
    StackPool2.prototype.getUninitializedStateFromPool = function() {
      this.stackHeadPosition++;
      if (this.stackHeadPosition === this.stack.length) {
        var partialState = {
          type: void 0,
          size: 0,
          array: void 0,
          position: 0,
          readCount: 0,
          map: void 0,
          key: null
        };
        this.stack.push(partialState);
      }
      return this.stack[this.stackHeadPosition];
    };
    StackPool2.prototype.release = function(state) {
      var topStackState = this.stack[this.stackHeadPosition];
      if (topStackState !== state) {
        throw new Error("Invalid stack state. Released state is not on top of the stack.");
      }
      if (state.type === STATE_ARRAY) {
        var partialState = state;
        partialState.size = 0;
        partialState.array = void 0;
        partialState.position = 0;
        partialState.type = void 0;
      }
      if (state.type === STATE_MAP_KEY || state.type === STATE_MAP_VALUE) {
        var partialState = state;
        partialState.size = 0;
        partialState.map = void 0;
        partialState.readCount = 0;
        partialState.type = void 0;
      }
      this.stackHeadPosition--;
    };
    StackPool2.prototype.reset = function() {
      this.stack.length = 0;
      this.stackHeadPosition = -1;
    };
    return StackPool2;
  })()
);
var HEAD_BYTE_REQUIRED = -1;
var EMPTY_VIEW = new DataView(new ArrayBuffer(0));
var EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer);
try {
  EMPTY_VIEW.getInt8(0);
} catch (e2) {
  if (!(e2 instanceof RangeError)) {
    throw new Error("This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access");
  }
}
var DataViewIndexOutOfBoundsError = RangeError;
var MORE_DATA = new DataViewIndexOutOfBoundsError("Insufficient data");
var sharedCachedKeyDecoder = new CachedKeyDecoder();
var Decoder = (
  /** @class */
  (function() {
    function Decoder2(options) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
      this.totalPos = 0;
      this.pos = 0;
      this.view = EMPTY_VIEW;
      this.bytes = EMPTY_BYTES;
      this.headByte = HEAD_BYTE_REQUIRED;
      this.extensionCodec = (_a = options === null || options === void 0 ? void 0 : options.extensionCodec) !== null && _a !== void 0 ? _a : ExtensionCodec.defaultCodec;
      this.context = options === null || options === void 0 ? void 0 : options.context;
      this.intMode = (_b = options === null || options === void 0 ? void 0 : options.intMode) !== null && _b !== void 0 ? _b : (options === null || options === void 0 ? void 0 : options.useBigInt64) ? IntMode.AS_ENCODED : IntMode.UNSAFE_NUMBER;
      this.rawBinaryStringValues = (_c = options === null || options === void 0 ? void 0 : options.rawBinaryStringValues) !== null && _c !== void 0 ? _c : false;
      this.rawBinaryStringKeys = (_d = options === null || options === void 0 ? void 0 : options.rawBinaryStringKeys) !== null && _d !== void 0 ? _d : false;
      this.useRawBinaryStringClass = (_e = options === null || options === void 0 ? void 0 : options.useRawBinaryStringClass) !== null && _e !== void 0 ? _e : false;
      this.useMap = (_f = options === null || options === void 0 ? void 0 : options.useMap) !== null && _f !== void 0 ? _f : false;
      this.supportObjectNumberKeys = (_g = options === null || options === void 0 ? void 0 : options.supportObjectNumberKeys) !== null && _g !== void 0 ? _g : false;
      this.maxStrLength = (_h = options === null || options === void 0 ? void 0 : options.maxStrLength) !== null && _h !== void 0 ? _h : UINT32_MAX;
      this.maxBinLength = (_j = options === null || options === void 0 ? void 0 : options.maxBinLength) !== null && _j !== void 0 ? _j : UINT32_MAX;
      this.maxArrayLength = (_k = options === null || options === void 0 ? void 0 : options.maxArrayLength) !== null && _k !== void 0 ? _k : UINT32_MAX;
      this.maxMapLength = (_l = options === null || options === void 0 ? void 0 : options.maxMapLength) !== null && _l !== void 0 ? _l : UINT32_MAX;
      this.maxExtLength = (_m = options === null || options === void 0 ? void 0 : options.maxExtLength) !== null && _m !== void 0 ? _m : UINT32_MAX;
      this.keyDecoder = (options === null || options === void 0 ? void 0 : options.keyDecoder) !== void 0 ? options.keyDecoder : sharedCachedKeyDecoder;
      if (this.rawBinaryStringKeys && !this.useMap) {
        throw new Error("rawBinaryStringKeys is only supported when useMap is true");
      }
      this.stack = new StackPool(this.useMap);
    }
    Decoder2.prototype.reinitializeState = function() {
      this.totalPos = 0;
      this.headByte = HEAD_BYTE_REQUIRED;
      this.stack.reset();
    };
    Decoder2.prototype.setBuffer = function(buffer) {
      this.bytes = ensureUint8Array(buffer);
      this.view = createDataView(this.bytes);
      this.pos = 0;
    };
    Decoder2.prototype.appendBuffer = function(buffer) {
      if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) {
        this.setBuffer(buffer);
      } else {
        var remainingData = this.bytes.subarray(this.pos);
        var newData = ensureUint8Array(buffer);
        var newBuffer = new Uint8Array(remainingData.length + newData.length);
        newBuffer.set(remainingData);
        newBuffer.set(newData, remainingData.length);
        this.setBuffer(newBuffer);
      }
    };
    Decoder2.prototype.hasRemaining = function(size) {
      return this.view.byteLength - this.pos >= size;
    };
    Decoder2.prototype.createExtraByteError = function(posToShow) {
      var _a = this, view = _a.view, pos = _a.pos;
      return new RangeError("Extra ".concat(view.byteLength - pos, " of ").concat(view.byteLength, " byte(s) found at buffer[").concat(posToShow, "]"));
    };
    Decoder2.prototype.decode = function(buffer) {
      this.reinitializeState();
      this.setBuffer(buffer);
      var object = this.doDecodeSync();
      if (this.hasRemaining(1)) {
        throw this.createExtraByteError(this.pos);
      }
      return object;
    };
    Decoder2.prototype.decodeMulti = function(buffer) {
      return __generator2(this, function(_a) {
        switch (_a.label) {
          case 0:
            this.reinitializeState();
            this.setBuffer(buffer);
            _a.label = 1;
          case 1:
            if (!this.hasRemaining(1)) return [3, 3];
            return [4, this.doDecodeSync()];
          case 2:
            _a.sent();
            return [3, 1];
          case 3:
            return [
              2
              /*return*/
            ];
        }
      });
    };
    Decoder2.prototype.decodeAsync = function(stream) {
      var _a, stream_1, stream_1_1;
      var _b, e_1, _c, _d;
      return __awaiter2(this, void 0, void 0, function() {
        var decoded, object, buffer, e_1_1, _e, headByte, pos, totalPos;
        return __generator2(this, function(_f) {
          switch (_f.label) {
            case 0:
              decoded = false;
              _f.label = 1;
            case 1:
              _f.trys.push([1, 6, 7, 12]);
              _a = true, stream_1 = __asyncValues2(stream);
              _f.label = 2;
            case 2:
              return [4, stream_1.next()];
            case 3:
              if (!(stream_1_1 = _f.sent(), _b = stream_1_1.done, !_b)) return [3, 5];
              _d = stream_1_1.value;
              _a = false;
              buffer = _d;
              if (decoded) {
                throw this.createExtraByteError(this.totalPos);
              }
              this.appendBuffer(buffer);
              try {
                object = this.doDecodeSync();
                decoded = true;
              } catch (e2) {
                if (!(e2 instanceof DataViewIndexOutOfBoundsError)) {
                  throw e2;
                }
              }
              this.totalPos += this.pos;
              _f.label = 4;
            case 4:
              _a = true;
              return [3, 2];
            case 5:
              return [3, 12];
            case 6:
              e_1_1 = _f.sent();
              e_1 = { error: e_1_1 };
              return [3, 12];
            case 7:
              _f.trys.push([7, , 10, 11]);
              if (!(!_a && !_b && (_c = stream_1.return))) return [3, 9];
              return [4, _c.call(stream_1)];
            case 8:
              _f.sent();
              _f.label = 9;
            case 9:
              return [3, 11];
            case 10:
              if (e_1) throw e_1.error;
              return [
                7
                /*endfinally*/
              ];
            case 11:
              return [
                7
                /*endfinally*/
              ];
            case 12:
              if (decoded) {
                if (this.hasRemaining(1)) {
                  throw this.createExtraByteError(this.totalPos);
                }
                return [2, object];
              }
              _e = this, headByte = _e.headByte, pos = _e.pos, totalPos = _e.totalPos;
              throw new RangeError("Insufficient data in parsing ".concat(prettyByte(headByte), " at ").concat(totalPos, " (").concat(pos, " in the current buffer)"));
          }
        });
      });
    };
    Decoder2.prototype.decodeArrayStream = function(stream) {
      return this.decodeMultiAsync(stream, true);
    };
    Decoder2.prototype.decodeStream = function(stream) {
      return this.decodeMultiAsync(stream, false);
    };
    Decoder2.prototype.decodeMultiAsync = function(stream, isArray) {
      return __asyncGenerator2(this, arguments, function decodeMultiAsync_1() {
        var isArrayHeaderRequired, arrayItemsLeft, _a, stream_2, stream_2_1, buffer, e_2, e_3_1;
        var _b, e_3, _c, _d;
        return __generator2(this, function(_e) {
          switch (_e.label) {
            case 0:
              isArrayHeaderRequired = isArray;
              arrayItemsLeft = -1;
              _e.label = 1;
            case 1:
              _e.trys.push([1, 13, 14, 19]);
              _a = true, stream_2 = __asyncValues2(stream);
              _e.label = 2;
            case 2:
              return [4, __await2(stream_2.next())];
            case 3:
              if (!(stream_2_1 = _e.sent(), _b = stream_2_1.done, !_b)) return [3, 12];
              _d = stream_2_1.value;
              _a = false;
              buffer = _d;
              if (isArray && arrayItemsLeft === 0) {
                throw this.createExtraByteError(this.totalPos);
              }
              this.appendBuffer(buffer);
              if (isArrayHeaderRequired) {
                arrayItemsLeft = this.readArraySize();
                isArrayHeaderRequired = false;
                this.complete();
              }
              _e.label = 4;
            case 4:
              _e.trys.push([4, 9, , 10]);
              _e.label = 5;
            case 5:
              if (false) return [3, 8];
              return [4, __await2(this.doDecodeSync())];
            case 6:
              return [4, _e.sent()];
            case 7:
              _e.sent();
              if (--arrayItemsLeft === 0) {
                return [3, 8];
              }
              return [3, 5];
            case 8:
              return [3, 10];
            case 9:
              e_2 = _e.sent();
              if (!(e_2 instanceof DataViewIndexOutOfBoundsError)) {
                throw e_2;
              }
              return [3, 10];
            case 10:
              this.totalPos += this.pos;
              _e.label = 11;
            case 11:
              _a = true;
              return [3, 2];
            case 12:
              return [3, 19];
            case 13:
              e_3_1 = _e.sent();
              e_3 = { error: e_3_1 };
              return [3, 19];
            case 14:
              _e.trys.push([14, , 17, 18]);
              if (!(!_a && !_b && (_c = stream_2.return))) return [3, 16];
              return [4, __await2(_c.call(stream_2))];
            case 15:
              _e.sent();
              _e.label = 16;
            case 16:
              return [3, 18];
            case 17:
              if (e_3) throw e_3.error;
              return [
                7
                /*endfinally*/
              ];
            case 18:
              return [
                7
                /*endfinally*/
              ];
            case 19:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    Decoder2.prototype.doDecodeSync = function() {
      DECODE: while (true) {
        var headByte = this.readHeadByte();
        var object = void 0;
        if (headByte >= 224) {
          object = this.convertNumber(headByte - 256);
        } else if (headByte < 192) {
          if (headByte < 128) {
            object = this.convertNumber(headByte);
          } else if (headByte < 144) {
            var size = headByte - 128;
            if (size !== 0) {
              this.pushMapState(size);
              this.complete();
              continue DECODE;
            } else {
              object = this.useMap ? /* @__PURE__ */ new Map() : {};
            }
          } else if (headByte < 160) {
            var size = headByte - 144;
            if (size !== 0) {
              this.pushArrayState(size);
              this.complete();
              continue DECODE;
            } else {
              object = [];
            }
          } else {
            var byteLength = headByte - 160;
            object = this.decodeString(byteLength, 0);
          }
        } else if (headByte === 192) {
          object = null;
        } else if (headByte === 194) {
          object = false;
        } else if (headByte === 195) {
          object = true;
        } else if (headByte === 202) {
          object = this.readF32();
        } else if (headByte === 203) {
          object = this.readF64();
        } else if (headByte === 204) {
          object = this.convertNumber(this.readU8());
        } else if (headByte === 205) {
          object = this.convertNumber(this.readU16());
        } else if (headByte === 206) {
          object = this.convertNumber(this.readU32());
        } else if (headByte === 207) {
          object = this.readU64();
        } else if (headByte === 208) {
          object = this.convertNumber(this.readI8());
        } else if (headByte === 209) {
          object = this.convertNumber(this.readI16());
        } else if (headByte === 210) {
          object = this.convertNumber(this.readI32());
        } else if (headByte === 211) {
          object = this.readI64();
        } else if (headByte === 217) {
          var byteLength = this.lookU8();
          object = this.decodeString(byteLength, 1);
        } else if (headByte === 218) {
          var byteLength = this.lookU16();
          object = this.decodeString(byteLength, 2);
        } else if (headByte === 219) {
          var byteLength = this.lookU32();
          object = this.decodeString(byteLength, 4);
        } else if (headByte === 220) {
          var size = this.readU16();
          if (size !== 0) {
            this.pushArrayState(size);
            this.complete();
            continue DECODE;
          } else {
            object = [];
          }
        } else if (headByte === 221) {
          var size = this.readU32();
          if (size !== 0) {
            this.pushArrayState(size);
            this.complete();
            continue DECODE;
          } else {
            object = [];
          }
        } else if (headByte === 222) {
          var size = this.readU16();
          if (size !== 0) {
            this.pushMapState(size);
            this.complete();
            continue DECODE;
          } else {
            object = {};
          }
        } else if (headByte === 223) {
          var size = this.readU32();
          if (size !== 0) {
            this.pushMapState(size);
            this.complete();
            continue DECODE;
          } else {
            object = {};
          }
        } else if (headByte === 196) {
          var size = this.lookU8();
          object = this.decodeBinary(size, 1);
        } else if (headByte === 197) {
          var size = this.lookU16();
          object = this.decodeBinary(size, 2);
        } else if (headByte === 198) {
          var size = this.lookU32();
          object = this.decodeBinary(size, 4);
        } else if (headByte === 212) {
          object = this.decodeExtension(1, 0);
        } else if (headByte === 213) {
          object = this.decodeExtension(2, 0);
        } else if (headByte === 214) {
          object = this.decodeExtension(4, 0);
        } else if (headByte === 215) {
          object = this.decodeExtension(8, 0);
        } else if (headByte === 216) {
          object = this.decodeExtension(16, 0);
        } else if (headByte === 199) {
          var size = this.lookU8();
          object = this.decodeExtension(size, 1);
        } else if (headByte === 200) {
          var size = this.lookU16();
          object = this.decodeExtension(size, 2);
        } else if (headByte === 201) {
          var size = this.lookU32();
          object = this.decodeExtension(size, 4);
        } else {
          throw new DecodeError("Unrecognized type byte: ".concat(prettyByte(headByte)));
        }
        this.complete();
        var stack = this.stack;
        while (stack.length > 0) {
          var state = stack.top();
          if (state.type === STATE_ARRAY) {
            state.array[state.position] = object;
            state.position++;
            if (state.position === state.size) {
              object = state.array;
              stack.release(state);
            } else {
              continue DECODE;
            }
          } else if (state.type === STATE_MAP_KEY) {
            if (!isValidMapKeyType(object, this.useMap, this.supportObjectNumberKeys)) {
              var acceptableTypes = this.useMap ? "string, number, bigint, or Uint8Array" : this.supportObjectNumberKeys ? "string or number" : "string";
              throw new DecodeError("The type of key must be ".concat(acceptableTypes, " but got ").concat(typeof object));
            }
            if (!this.useMap && object === "__proto__") {
              throw new DecodeError("The key __proto__ is not allowed");
            }
            state.key = object;
            state.type = STATE_MAP_VALUE;
            continue DECODE;
          } else {
            if (this.useMap) {
              state.map.set(state.key, object);
            } else {
              state.map[state.key] = object;
            }
            state.readCount++;
            if (state.readCount === state.size) {
              object = state.map;
              stack.release(state);
            } else {
              state.key = null;
              state.type = STATE_MAP_KEY;
              continue DECODE;
            }
          }
        }
        return object;
      }
    };
    Decoder2.prototype.readHeadByte = function() {
      if (this.headByte === HEAD_BYTE_REQUIRED) {
        this.headByte = this.readU8();
      }
      return this.headByte;
    };
    Decoder2.prototype.complete = function() {
      this.headByte = HEAD_BYTE_REQUIRED;
    };
    Decoder2.prototype.readArraySize = function() {
      var headByte = this.readHeadByte();
      switch (headByte) {
        case 220:
          return this.readU16();
        case 221:
          return this.readU32();
        default: {
          if (headByte < 160) {
            return headByte - 144;
          } else {
            throw new DecodeError("Unrecognized array type byte: ".concat(prettyByte(headByte)));
          }
        }
      }
    };
    Decoder2.prototype.pushMapState = function(size) {
      if (size > this.maxMapLength) {
        throw new DecodeError("Max length exceeded: map length (".concat(size, ") > maxMapLengthLength (").concat(this.maxMapLength, ")"));
      }
      this.stack.pushMapState(size);
    };
    Decoder2.prototype.pushArrayState = function(size) {
      if (size > this.maxArrayLength) {
        throw new DecodeError("Max length exceeded: array length (".concat(size, ") > maxArrayLength (").concat(this.maxArrayLength, ")"));
      }
      this.stack.pushArrayState(size);
    };
    Decoder2.prototype.decodeString = function(byteLength, headerOffset) {
      if (this.stateIsMapKey() ? this.rawBinaryStringKeys : this.rawBinaryStringValues) {
        var decoded = this.decodeBinary(byteLength, headerOffset);
        if (this.useRawBinaryStringClass) {
          return new RawBinaryString(decoded);
        }
        return decoded;
      }
      return this.decodeUtf8String(byteLength, headerOffset);
    };
    Decoder2.prototype.decodeUtf8String = function(byteLength, headerOffset) {
      var _a;
      if (byteLength > this.maxStrLength) {
        throw new DecodeError("Max length exceeded: UTF-8 byte length (".concat(byteLength, ") > maxStrLength (").concat(this.maxStrLength, ")"));
      }
      if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {
        throw MORE_DATA;
      }
      var offset = this.pos + headerOffset;
      var object;
      if (this.stateIsMapKey() && ((_a = this.keyDecoder) === null || _a === void 0 ? void 0 : _a.canBeCached(byteLength))) {
        object = this.keyDecoder.decode(this.bytes, offset, byteLength);
      } else {
        object = utf8Decode(this.bytes, offset, byteLength);
      }
      this.pos += headerOffset + byteLength;
      return object;
    };
    Decoder2.prototype.stateIsMapKey = function() {
      if (this.stack.length > 0) {
        var state = this.stack.top();
        return state.type === STATE_MAP_KEY;
      }
      return false;
    };
    Decoder2.prototype.decodeBinary = function(byteLength, headOffset) {
      if (byteLength > this.maxBinLength) {
        throw new DecodeError("Max length exceeded: bin length (".concat(byteLength, ") > maxBinLength (").concat(this.maxBinLength, ")"));
      }
      if (!this.hasRemaining(byteLength + headOffset)) {
        throw MORE_DATA;
      }
      var offset = this.pos + headOffset;
      var object = this.bytes.subarray(offset, offset + byteLength);
      this.pos += headOffset + byteLength;
      return object;
    };
    Decoder2.prototype.decodeExtension = function(size, headOffset) {
      if (size > this.maxExtLength) {
        throw new DecodeError("Max length exceeded: ext length (".concat(size, ") > maxExtLength (").concat(this.maxExtLength, ")"));
      }
      var extType = this.view.getInt8(this.pos + headOffset);
      var data = this.decodeBinary(
        size,
        headOffset + 1
        /* extType */
      );
      return this.extensionCodec.decode(data, extType, this.context);
    };
    Decoder2.prototype.convertNumber = function(value) {
      return convertSafeIntegerToMode(value, this.intMode);
    };
    Decoder2.prototype.lookU8 = function() {
      return this.view.getUint8(this.pos);
    };
    Decoder2.prototype.lookU16 = function() {
      return this.view.getUint16(this.pos);
    };
    Decoder2.prototype.lookU32 = function() {
      return this.view.getUint32(this.pos);
    };
    Decoder2.prototype.readU8 = function() {
      var value = this.view.getUint8(this.pos);
      this.pos++;
      return value;
    };
    Decoder2.prototype.readI8 = function() {
      var value = this.view.getInt8(this.pos);
      this.pos++;
      return value;
    };
    Decoder2.prototype.readU16 = function() {
      var value = this.view.getUint16(this.pos);
      this.pos += 2;
      return value;
    };
    Decoder2.prototype.readI16 = function() {
      var value = this.view.getInt16(this.pos);
      this.pos += 2;
      return value;
    };
    Decoder2.prototype.readU32 = function() {
      var value = this.view.getUint32(this.pos);
      this.pos += 4;
      return value;
    };
    Decoder2.prototype.readI32 = function() {
      var value = this.view.getInt32(this.pos);
      this.pos += 4;
      return value;
    };
    Decoder2.prototype.readU64 = function() {
      var value = getUint64(this.view, this.pos, this.intMode);
      this.pos += 8;
      return value;
    };
    Decoder2.prototype.readI64 = function() {
      var value = getInt64(this.view, this.pos, this.intMode);
      this.pos += 8;
      return value;
    };
    Decoder2.prototype.readF32 = function() {
      var value = this.view.getFloat32(this.pos);
      this.pos += 4;
      return value;
    };
    Decoder2.prototype.readF64 = function() {
      var value = this.view.getFloat64(this.pos);
      this.pos += 8;
      return value;
    };
    return Decoder2;
  })()
);

// node_modules/algorand-msgpack/dist.es5+esm/decode.mjs
function decode(buffer, options) {
  var decoder = new Decoder(options);
  return decoder.decode(buffer);
}

// node_modules/algosdk/dist/esm/encoding/encoding.js
var ERROR_CONTAINS_EMPTY_STRING = "The object contains empty or 0 values. First empty or 0 value encountered during encoding: ";
function containsEmpty(obj) {
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      if (!obj[key] || obj[key].length === 0) {
        return { containsEmpty: true, firstEmptyKey: key };
      }
    }
  }
  return { containsEmpty: false, firstEmptyKey: void 0 };
}
function msgpackRawEncode(obj) {
  const options = { sortKeys: true };
  return encode(obj, options);
}
function encodeObj(obj) {
  const emptyCheck = containsEmpty(obj);
  if (emptyCheck.containsEmpty) {
    throw new Error(ERROR_CONTAINS_EMPTY_STRING + emptyCheck.firstEmptyKey);
  }
  return msgpackRawEncode(obj);
}
function intDecodingToIntMode(intDecoding) {
  switch (intDecoding) {
    case intDecoding_default.UNSAFE:
      return IntMode.UNSAFE_NUMBER;
    case intDecoding_default.SAFE:
      return IntMode.SAFE_NUMBER;
    case intDecoding_default.MIXED:
      return IntMode.MIXED;
    case intDecoding_default.BIGINT:
      return IntMode.BIGINT;
    default:
      throw new Error(`Invalid intDecoding: ${intDecoding}`);
  }
}
function msgpackRawDecode(buffer, options) {
  const decoderOptions = {
    intMode: (options == null ? void 0 : options.intDecoding) ? intDecodingToIntMode(options == null ? void 0 : options.intDecoding) : IntMode.BIGINT
  };
  return decode(buffer, decoderOptions);
}
function decodeObj(o3) {
  return msgpackRawDecode(o3, { intDecoding: intDecoding_default.MIXED });
}
function msgpackRawDecodeAsMap(encoded, options) {
  const decoderOptions = {
    intMode: (options == null ? void 0 : options.intDecoding) ? intDecodingToIntMode(options == null ? void 0 : options.intDecoding) : IntMode.BIGINT,
    useMap: true
  };
  return decode(encoded, decoderOptions);
}
function msgpackRawDecodeAsMapWithRawStrings(encoded, options) {
  const decoderOptions = {
    intMode: (options == null ? void 0 : options.intDecoding) ? intDecodingToIntMode(options == null ? void 0 : options.intDecoding) : IntMode.BIGINT,
    useMap: true,
    rawBinaryStringKeys: true,
    rawBinaryStringValues: true,
    useRawBinaryStringClass: true
  };
  return decode(encoded, decoderOptions);
}
function msgpackEncodingDataToJSONEncodingData(e2) {
  if (e2 === null || e2 === void 0) {
    return e2;
  }
  if (e2 instanceof Uint8Array) {
    return bytesToBase64(e2);
  }
  if (Array.isArray(e2)) {
    return e2.map(msgpackEncodingDataToJSONEncodingData);
  }
  if (e2 instanceof Map) {
    const obj = {};
    for (const [k2, v2] of e2) {
      if (typeof k2 !== "string") {
        throw new Error(`JSON map key must be a string: ${k2}`);
      }
      obj[k2] = msgpackEncodingDataToJSONEncodingData(v2);
    }
    return obj;
  }
  return e2;
}
function jsonEncodingDataToMsgpackEncodingData(e2) {
  if (e2 === null || e2 === void 0) {
    return e2;
  }
  if (typeof e2 === "string" || // Note, this will not convert base64 to Uint8Array
  typeof e2 === "number" || typeof e2 === "bigint" || typeof e2 === "boolean") {
    return e2;
  }
  if (Array.isArray(e2)) {
    return e2.map(jsonEncodingDataToMsgpackEncodingData);
  }
  if (typeof e2 === "object") {
    const obj = /* @__PURE__ */ new Map();
    for (const [key, value] of Object.entries(e2)) {
      obj.set(key, jsonEncodingDataToMsgpackEncodingData(value));
    }
    return obj;
  }
  throw new Error(`Invalid JSON encoding data: ${e2}`);
}
var MsgpackObjectPathSegmentKind;
(function(MsgpackObjectPathSegmentKind2) {
  MsgpackObjectPathSegmentKind2[MsgpackObjectPathSegmentKind2["MAP_VALUE"] = 0] = "MAP_VALUE";
  MsgpackObjectPathSegmentKind2[MsgpackObjectPathSegmentKind2["ARRAY_ELEMENT"] = 1] = "ARRAY_ELEMENT";
})(MsgpackObjectPathSegmentKind || (MsgpackObjectPathSegmentKind = {}));
var MsgpackRawStringProvider = class _MsgpackRawStringProvider {
  constructor({ parent, segment, baseObjectBytes }) {
    this.resolvedCache = null;
    this.resolvedCachePresent = false;
    this.parent = parent;
    this.segment = segment;
    this.baseObjectBytes = baseObjectBytes;
  }
  /**
   * Create a new provider that resolves to the current provider's map value at the given key.
   */
  withMapValue(key) {
    return new _MsgpackRawStringProvider({
      parent: this,
      segment: {
        kind: MsgpackObjectPathSegmentKind.MAP_VALUE,
        key
      }
    });
  }
  /**
   * Create a new provider that resolves to the current provider's array element at the given index.
   */
  withArrayElement(index) {
    return new _MsgpackRawStringProvider({
      parent: this,
      segment: {
        kind: MsgpackObjectPathSegmentKind.ARRAY_ELEMENT,
        key: index
      }
    });
  }
  /**
   * Get the raw string at the current location. If the current location is not a raw string, an error is thrown.
   */
  getRawStringAtCurrentLocation() {
    const resolved = this.resolve();
    if (resolved instanceof RawBinaryString) {
      return resolved.rawBinaryValue;
    }
    throw new Error(`Invalid type. Expected RawBinaryString, got ${resolved} (${typeof resolved})`);
  }
  /**
   * Get the raw string map keys and values at the current location. If the current location is not a map, an error is thrown.
   */
  getRawStringKeysAndValuesAtCurrentLocation() {
    const resolved = this.resolve();
    if (!(resolved instanceof Map)) {
      throw new Error(`Invalid type. Expected Map, got ${resolved} (${typeof resolved})`);
    }
    const keysAndValues = /* @__PURE__ */ new Map();
    for (const [key, value] of resolved) {
      if (key instanceof RawBinaryString) {
        keysAndValues.set(key.rawBinaryValue, value);
      } else {
        throw new Error(`Invalid type for map key. Expected RawBinaryString, got ${key} (${typeof key})`);
      }
    }
    return keysAndValues;
  }
  /**
   * Resolve the provider by extracting the value it indicates from the base msgpack object.
   */
  resolve() {
    if (this.resolvedCachePresent) {
      return this.resolvedCache;
    }
    let parentResolved;
    if (this.parent) {
      parentResolved = this.parent.resolve();
    } else {
      parentResolved = msgpackRawDecodeAsMapWithRawStrings(this.baseObjectBytes);
    }
    if (!this.segment) {
      this.resolvedCache = parentResolved;
      this.resolvedCachePresent = true;
      return parentResolved;
    }
    if (this.segment.kind === MsgpackObjectPathSegmentKind.MAP_VALUE) {
      if (!(parentResolved instanceof Map)) {
        throw new Error(`Invalid type. Expected Map, got ${parentResolved} (${typeof parentResolved})`);
      }
      if (typeof this.segment.key === "string" || this.segment.key instanceof Uint8Array || this.segment.key instanceof RawBinaryString) {
        const targetBytes = this.segment.key instanceof RawBinaryString ? (
          // Decoded rawBinaryValue will always be a Uint8Array
          this.segment.key.rawBinaryValue
        ) : coerceToBytes(this.segment.key);
        const targetIsRawString = typeof this.segment.key === "string" || this.segment.key instanceof RawBinaryString;
        for (const [key, value] of parentResolved) {
          let potentialKeyBytes;
          if (targetIsRawString) {
            if (key instanceof RawBinaryString) {
              potentialKeyBytes = key.rawBinaryValue;
            }
          } else if (key instanceof Uint8Array) {
            potentialKeyBytes = key;
          }
          if (potentialKeyBytes && arrayEqual(targetBytes, potentialKeyBytes)) {
            this.resolvedCache = value;
            break;
          }
        }
      } else {
        this.resolvedCache = parentResolved.get(this.segment.key);
      }
      this.resolvedCachePresent = true;
      return this.resolvedCache;
    }
    if (this.segment.kind === MsgpackObjectPathSegmentKind.ARRAY_ELEMENT) {
      if (!Array.isArray(parentResolved)) {
        throw new Error(`Invalid type. Expected Array, got ${parentResolved} (${typeof parentResolved})`);
      }
      this.resolvedCache = parentResolved[this.segment.key];
      this.resolvedCachePresent = true;
      return this.resolvedCache;
    }
    throw new Error(`Invalid segment kind: ${this.segment.kind}`);
  }
  /**
   * Get the path string of the current location indicated by the provider. Useful for debugging.
   */
  getPathString() {
    const parentPathString = this.parent ? this.parent.getPathString() : "root";
    if (!this.segment) {
      return parentPathString;
    }
    if (this.segment.kind === MsgpackObjectPathSegmentKind.MAP_VALUE) {
      return `${parentPathString} -> map key "${this.segment.key}" (${typeof this.segment.key})`;
    }
    if (this.segment.kind === MsgpackObjectPathSegmentKind.ARRAY_ELEMENT) {
      return `${parentPathString} -> array index ${this.segment.key} (${typeof this.segment.key})`;
    }
    return `${parentPathString} -> unknown segment kind ${this.segment.kind}`;
  }
};
var Schema = class {
};
function decodeMsgpack(encoded, c2) {
  const decoded = msgpackRawDecodeAsMap(encoded);
  const rawStringProvider = new MsgpackRawStringProvider({
    baseObjectBytes: encoded
  });
  return c2.fromEncodingData(c2.encodingSchema.fromPreparedMsgpack(decoded, rawStringProvider));
}
function encodeMsgpack(e2) {
  return msgpackRawEncode(e2.getEncodingSchema().prepareMsgpack(e2.toEncodingData()));
}
function decodeJSON(encoded, c2) {
  const decoded = parseJSON(encoded, {
    intDecoding: intDecoding_default.BIGINT
  });
  return c2.fromEncodingData(c2.encodingSchema.fromPreparedJSON(decoded));
}
function encodeJSON(e2, options) {
  const { space, ...prepareJSONOptions } = options ?? {};
  const prepared = e2.getEncodingSchema().prepareJSON(e2.toEncodingData(), prepareJSONOptions);
  return stringifyJSON(prepared, void 0, space);
}

// node_modules/algosdk/dist/esm/encoding/schema/boolean.js
var BooleanSchema = class extends Schema {
  defaultValue() {
    return false;
  }
  isDefaultValue(data) {
    return data === false;
  }
  prepareMsgpack(data) {
    if (typeof data === "boolean") {
      return data;
    }
    throw new Error("Invalid boolean");
  }
  fromPreparedMsgpack(encoded, _rawStringProvider) {
    if (typeof encoded === "boolean") {
      return encoded;
    }
    throw new Error("Invalid boolean");
  }
  prepareJSON(data, _options) {
    if (typeof data === "boolean") {
      return data;
    }
    throw new Error("Invalid boolean");
  }
  fromPreparedJSON(encoded) {
    if (typeof encoded === "boolean") {
      return encoded;
    }
    throw new Error("Invalid boolean");
  }
};

// node_modules/algosdk/dist/esm/encoding/schema/string.js
var StringSchema = class extends Schema {
  defaultValue() {
    return "";
  }
  isDefaultValue(data) {
    return data === "";
  }
  prepareMsgpack(data) {
    if (typeof data === "string") {
      return data;
    }
    throw new Error(`Invalid string: (${typeof data}) ${data}`);
  }
  fromPreparedMsgpack(encoded, _rawStringProvider) {
    if (typeof encoded === "string") {
      return encoded;
    }
    throw new Error(`Invalid string: (${typeof encoded}) ${encoded}`);
  }
  prepareJSON(data, _options) {
    if (typeof data === "string") {
      return data;
    }
    throw new Error(`Invalid string: (${typeof data}) ${data}`);
  }
  fromPreparedJSON(encoded) {
    if (typeof encoded === "string") {
      return encoded;
    }
    throw new Error(`Invalid string: (${typeof encoded}) ${encoded}`);
  }
};

// node_modules/algosdk/dist/esm/encoding/schema/uint64.js
var Uint64Schema = class extends Schema {
  defaultValue() {
    return BigInt(0);
  }
  isDefaultValue(data) {
    if (typeof data === "bigint")
      return data === BigInt(0);
    if (typeof data === "number")
      return data === 0;
    return false;
  }
  prepareMsgpack(data) {
    return ensureUint64(data);
  }
  fromPreparedMsgpack(encoded, _rawStringProvider) {
    return ensureUint64(encoded);
  }
  prepareJSON(data, _options) {
    return ensureUint64(data);
  }
  fromPreparedJSON(encoded) {
    return ensureUint64(encoded);
  }
};

// node_modules/algosdk/dist/esm/encoding/schema/address.js
var AddressSchema = class extends Schema {
  defaultValue() {
    return Address.zeroAddress();
  }
  isDefaultValue(data) {
    return Address.zeroAddress().equals(data);
  }
  prepareMsgpack(data) {
    if (data instanceof Address) {
      return data.publicKey;
    }
    throw new Error(`Invalid address: (${typeof data}) ${data}`);
  }
  fromPreparedMsgpack(encoded, _rawStringProvider) {
    return new Address(encoded);
  }
  prepareJSON(data, _options) {
    if (data instanceof Address) {
      return data.toString();
    }
    throw new Error(`Invalid address: (${typeof data}) ${data}`);
  }
  fromPreparedJSON(encoded) {
    return Address.fromString(encoded);
  }
};

// node_modules/algosdk/dist/esm/encoding/schema/bytearray.js
var ByteArraySchema = class extends Schema {
  defaultValue() {
    return new Uint8Array();
  }
  isDefaultValue(data) {
    return data instanceof Uint8Array && data.byteLength === 0;
  }
  prepareMsgpack(data) {
    if (data instanceof Uint8Array) {
      return data;
    }
    throw new Error(`Invalid byte array: (${typeof data}) ${data}`);
  }
  fromPreparedMsgpack(encoded, _rawStringProvider) {
    if (encoded instanceof Uint8Array) {
      return encoded;
    }
    throw new Error(`Invalid byte array: (${typeof encoded}) ${encoded}`);
  }
  prepareJSON(data, _options) {
    if (data instanceof Uint8Array) {
      return bytesToBase64(data);
    }
    throw new Error(`Invalid byte array: (${typeof data}) ${data}`);
  }
  fromPreparedJSON(encoded) {
    if (encoded === null || encoded === void 0) {
      return this.defaultValue();
    }
    if (typeof encoded === "string") {
      return base64ToBytes(encoded);
    }
    throw new Error(`Invalid byte array: (${typeof encoded}) ${encoded}`);
  }
};
var FixedLengthByteArraySchema = class extends Schema {
  constructor(length) {
    super();
    this.length = length;
  }
  defaultValue() {
    return new Uint8Array(this.length);
  }
  isDefaultValue(data) {
    return data instanceof Uint8Array && data.byteLength === this.length && data.every((byte) => byte === 0);
  }
  prepareMsgpack(data) {
    if (data instanceof Uint8Array) {
      if (data.byteLength === this.length) {
        return data;
      }
      throw new Error(`Invalid byte array length: wanted ${this.length}, got ${data.byteLength}`);
    }
    throw new Error("Invalid byte array");
  }
  fromPreparedMsgpack(encoded, _rawStringProvider) {
    if (encoded instanceof Uint8Array) {
      if (encoded.byteLength === this.length) {
        return encoded;
      }
      throw new Error(`Invalid byte array length: wanted ${this.length}, got ${encoded.byteLength}`);
    }
    throw new Error("Invalid byte array");
  }
  prepareJSON(data) {
    if (data instanceof Uint8Array) {
      if (data.byteLength === this.length) {
        return bytesToBase64(data);
      }
      throw new Error(`Invalid byte array length: wanted ${this.length}, got ${data.byteLength}`);
    }
    throw new Error("Invalid byte array");
  }
  fromPreparedJSON(encoded) {
    if (typeof encoded === "string") {
      const bytes = base64ToBytes(encoded);
      if (bytes.byteLength === this.length) {
        return bytes;
      }
      throw new Error(`Invalid byte array length: wanted ${this.length}, got ${bytes.byteLength}`);
    }
    throw new Error("Invalid base64 byte array");
  }
};

// node_modules/algosdk/dist/esm/encoding/schema/blockhash.js
var import_hi_base322 = __toESM(require_base32(), 1);
var blockHashByteLength = 32;
var base32Length = 52;
var BlockHashSchema = class extends Schema {
  defaultValue() {
    return new Uint8Array(blockHashByteLength);
  }
  isDefaultValue(data) {
    return data instanceof Uint8Array && data.byteLength === blockHashByteLength && data.every((byte) => byte === 0);
  }
  prepareMsgpack(data) {
    if (data instanceof Uint8Array && data.byteLength === blockHashByteLength) {
      return data;
    }
    throw new Error(`Invalid block hash: (${typeof data}) ${data}`);
  }
  fromPreparedMsgpack(encoded, _rawStringProvider) {
    if (encoded instanceof Uint8Array && encoded.byteLength === blockHashByteLength) {
      return encoded;
    }
    throw new Error(`Invalid block hash: (${typeof encoded}) ${encoded}`);
  }
  prepareJSON(data, _options) {
    if (data instanceof Uint8Array && data.byteLength === blockHashByteLength) {
      return `blk-${import_hi_base322.default.encode(data).slice(0, base32Length)}`;
    }
    throw new Error(`Invalid block hash: (${typeof data}) ${data}`);
  }
  fromPreparedJSON(encoded) {
    if (typeof encoded === "string" && encoded.length === base32Length + 4 && encoded.startsWith("blk-")) {
      return Uint8Array.from(import_hi_base322.default.decode.asBytes(encoded.slice(4)));
    }
    throw new Error(`Invalid block hash: (${typeof encoded}) ${encoded}`);
  }
};

// node_modules/algosdk/dist/esm/encoding/schema/binarystring.js
var SpecialCaseBinaryStringSchema = class extends Schema {
  defaultValue() {
    return new Uint8Array();
  }
  isDefaultValue(data) {
    return data instanceof Uint8Array && data.byteLength === 0;
  }
  prepareMsgpack(data) {
    if (data instanceof Uint8Array) {
      return new RawBinaryString(data);
    }
    throw new Error(`Invalid byte array: (${typeof data}) ${data}`);
  }
  fromPreparedMsgpack(_encoded, rawStringProvider) {
    return rawStringProvider.getRawStringAtCurrentLocation();
  }
  prepareJSON(data, options) {
    if (data instanceof Uint8Array) {
      const stringValue = bytesToString(data);
      if (!options.lossyBinaryStringConversion && !arrayEqual(coerceToBytes(stringValue), data)) {
        throw new Error(`Invalid UTF-8 byte array encountered. Encode with lossyBinaryStringConversion enabled to bypass this check. Base64 value: ${bytesToBase64(data)}`);
      }
      return stringValue;
    }
    throw new Error(`Invalid byte array: (${typeof data}) ${data}`);
  }
  fromPreparedJSON(encoded) {
    if (typeof encoded === "string") {
      return coerceToBytes(encoded);
    }
    throw new Error(`Invalid byte array: (${typeof encoded}) ${encoded}`);
  }
};

// node_modules/algosdk/dist/esm/encoding/schema/array.js
var ArraySchema = class extends Schema {
  constructor(itemSchema) {
    super();
    this.itemSchema = itemSchema;
  }
  defaultValue() {
    return [];
  }
  isDefaultValue(data) {
    return Array.isArray(data) && data.length === 0;
  }
  prepareMsgpack(data) {
    if (Array.isArray(data)) {
      return data.map((item) => this.itemSchema.prepareMsgpack(item));
    }
    throw new Error("ArraySchema data must be an array");
  }
  fromPreparedMsgpack(encoded, rawStringProvider) {
    if (Array.isArray(encoded)) {
      return encoded.map((item, index) => this.itemSchema.fromPreparedMsgpack(item, rawStringProvider.withArrayElement(index)));
    }
    throw new Error(`ArraySchema encoded data must be an array: ${encoded} (${typeof encoded})`);
  }
  prepareJSON(data, options) {
    if (Array.isArray(data)) {
      return data.map((item) => this.itemSchema.prepareJSON(item, options));
    }
    throw new Error("ArraySchema data must be an array");
  }
  fromPreparedJSON(encoded) {
    if (Array.isArray(encoded)) {
      return encoded.map((item) => this.itemSchema.fromPreparedJSON(item));
    }
    throw new Error(`ArraySchema encoded data must be an array: ${encoded} (${typeof encoded})`);
  }
};

// node_modules/algosdk/dist/esm/encoding/schema/map.js
function allOmitEmpty(entries) {
  return entries.map((entry) => ({ ...entry, omitEmpty: true }));
}
var NamedMapSchema = class _NamedMapSchema extends Schema {
  constructor(entries) {
    super();
    this.entries = entries;
    this.checkEntries();
  }
  /**
   * Adds new entries to the map schema. WARNING: this is a mutable operation, and you should be very
   * careful when using it. Any error that happens here is non-recoverable and will corrupt the
   * NamedMapSchema object;
   * @param entries - The entries to add.
   */
  pushEntries(...entries) {
    this.entries.push(...entries);
    this.checkEntries();
  }
  checkEntries() {
    for (const entry of this.entries) {
      if (entry.embedded) {
        if (entry.key !== "") {
          throw new Error("Embedded entries must have an empty key");
        }
        if (!(entry.valueSchema instanceof _NamedMapSchema)) {
          throw new Error("Embedded entry valueSchema must be a NamedMapSchema");
        }
      }
    }
    const keys = /* @__PURE__ */ new Set();
    for (const entry of this.getEntries()) {
      if (keys.has(entry.key)) {
        throw new Error(`Duplicate key: ${entry.key}`);
      }
      keys.add(entry.key);
    }
  }
  /**
   * Returns all top-level entries, properly accounting for fields from embedded entries.
   * @returns An array of all top-level entries for this map.
   */
  getEntries() {
    const entries = [];
    for (const entry of this.entries) {
      if (entry.embedded) {
        const embeddedMapSchema = entry.valueSchema;
        entries.push(...embeddedMapSchema.getEntries());
      } else {
        entries.push(entry);
      }
    }
    return entries;
  }
  defaultValue() {
    const map = /* @__PURE__ */ new Map();
    for (const entry of this.getEntries()) {
      map.set(entry.key, entry.valueSchema.defaultValue());
    }
    return map;
  }
  isDefaultValue(data) {
    if (!(data instanceof Map))
      return false;
    for (const entry of this.getEntries()) {
      if (!entry.valueSchema.isDefaultValue(data.get(entry.key))) {
        return false;
      }
    }
    return true;
  }
  prepareMsgpack(data) {
    if (!(data instanceof Map)) {
      throw new Error(`NamedMapSchema data must be a Map. Got (${typeof data}) ${data}`);
    }
    const map = /* @__PURE__ */ new Map();
    for (const entry of this.getEntries()) {
      const value = data.get(entry.key);
      if (entry.omitEmpty && entry.valueSchema.isDefaultValue(value)) {
        continue;
      }
      map.set(entry.key, entry.valueSchema.prepareMsgpack(value));
    }
    return map;
  }
  fromPreparedMsgpack(encoded, rawStringProvider) {
    if (!(encoded instanceof Map)) {
      throw new Error("NamedMapSchema data must be a Map");
    }
    const map = /* @__PURE__ */ new Map();
    for (const entry of this.getEntries()) {
      if (encoded.has(entry.key)) {
        map.set(entry.key, entry.valueSchema.fromPreparedMsgpack(encoded.get(entry.key), rawStringProvider.withMapValue(entry.key)));
      } else if (entry.omitEmpty) {
        map.set(entry.key, entry.valueSchema.defaultValue());
      } else {
        throw new Error(`Missing key: ${entry.key}`);
      }
    }
    return map;
  }
  prepareJSON(data, options) {
    if (!(data instanceof Map)) {
      throw new Error("NamedMapSchema data must be a Map");
    }
    const obj = {};
    for (const entry of this.getEntries()) {
      const value = data.get(entry.key);
      if (entry.omitEmpty && entry.valueSchema.isDefaultValue(value)) {
        continue;
      }
      obj[entry.key] = entry.valueSchema.prepareJSON(value, options);
    }
    return obj;
  }
  fromPreparedJSON(encoded) {
    if (encoded == null || typeof encoded !== "object" || Array.isArray(encoded)) {
      throw new Error("NamedMapSchema data must be an object");
    }
    const map = /* @__PURE__ */ new Map();
    for (const entry of this.getEntries()) {
      if (Object.prototype.hasOwnProperty.call(encoded, entry.key)) {
        map.set(entry.key, entry.valueSchema.fromPreparedJSON(encoded[entry.key]));
      } else if (entry.omitEmpty) {
        map.set(entry.key, entry.valueSchema.defaultValue());
      } else {
        throw new Error(`Missing key: ${entry.key}`);
      }
    }
    return map;
  }
};
function combineMaps(...maps) {
  const combined = /* @__PURE__ */ new Map();
  for (const map of maps) {
    for (const [key, value] of map) {
      if (combined.has(key)) {
        throw new Error(`Duplicate key: ${key}`);
      }
      combined.set(key, value);
    }
  }
  return combined;
}
function convertMap(map, func) {
  const mapped = /* @__PURE__ */ new Map();
  for (const [key, value] of map) {
    const [newKey, newValue] = func(key, value);
    mapped.set(newKey, newValue);
  }
  return mapped;
}
var Uint64MapSchema = class extends Schema {
  constructor(valueSchema) {
    super();
    this.valueSchema = valueSchema;
  }
  defaultValue() {
    return /* @__PURE__ */ new Map();
  }
  isDefaultValue(data) {
    return data instanceof Map && data.size === 0;
  }
  prepareMsgpack(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Uint64MapSchema data must be a Map. Got (${typeof data}) ${data}`);
    }
    const prepared = /* @__PURE__ */ new Map();
    for (const [key, value] of data) {
      const bigintKey = ensureUint64(key);
      if (prepared.has(bigintKey)) {
        throw new Error(`Duplicate key: ${bigintKey}`);
      }
      prepared.set(bigintKey, this.valueSchema.prepareMsgpack(value));
    }
    return prepared;
  }
  fromPreparedMsgpack(encoded, rawStringProvider) {
    if (!(encoded instanceof Map)) {
      throw new Error("Uint64MapSchema data must be a Map");
    }
    const map = /* @__PURE__ */ new Map();
    for (const [key, value] of encoded) {
      const bigintKey = ensureUint64(key);
      if (map.has(bigintKey)) {
        throw new Error(`Duplicate key: ${bigintKey}`);
      }
      map.set(bigintKey, this.valueSchema.fromPreparedMsgpack(value, rawStringProvider.withMapValue(key)));
    }
    return map;
  }
  prepareJSON(data, options) {
    if (!(data instanceof Map)) {
      throw new Error(`Uint64MapSchema data must be a Map. Got (${typeof data}) ${data}`);
    }
    const prepared = /* @__PURE__ */ new Map();
    for (const [key, value] of data) {
      const bigintKey = ensureUint64(key);
      if (prepared.has(bigintKey)) {
        throw new Error(`Duplicate key: ${bigintKey}`);
      }
      prepared.set(bigintKey, this.valueSchema.prepareJSON(value, options));
    }
    const obj = {};
    for (const [key, value] of prepared) {
      obj[key.toString()] = value;
    }
    return obj;
  }
  fromPreparedJSON(encoded) {
    if (encoded == null || typeof encoded !== "object" || Array.isArray(encoded)) {
      throw new Error("Uint64MapSchema data must be an object");
    }
    const map = /* @__PURE__ */ new Map();
    for (const [key, value] of Object.entries(encoded)) {
      const bigintKey = BigInt(key);
      if (map.has(bigintKey)) {
        throw new Error(`Duplicate key: ${bigintKey}`);
      }
      map.set(bigintKey, this.valueSchema.fromPreparedJSON(value));
    }
    return map;
  }
};
var ByteArrayMapSchema = class extends Schema {
  constructor(valueSchema) {
    super();
    this.valueSchema = valueSchema;
  }
  defaultValue() {
    return /* @__PURE__ */ new Map();
  }
  isDefaultValue(data) {
    return data instanceof Map && data.size === 0;
  }
  prepareMsgpack(data) {
    if (!(data instanceof Map)) {
      throw new Error(`ByteArrayMapSchema data must be a Map. Got (${typeof data}) ${data}`);
    }
    const prepared = /* @__PURE__ */ new Map();
    for (const [key, value] of data) {
      if (!(key instanceof Uint8Array)) {
        throw new Error(`Invalid key: ${key} (${typeof key})`);
      }
      prepared.set(key, this.valueSchema.prepareMsgpack(value));
    }
    return prepared;
  }
  fromPreparedMsgpack(encoded, rawStringProvider) {
    if (!(encoded instanceof Map)) {
      throw new Error("ByteArrayMapSchema data must be a Map");
    }
    const map = /* @__PURE__ */ new Map();
    for (const [key, value] of encoded) {
      if (!(key instanceof Uint8Array)) {
        throw new Error(`Invalid key: ${key} (${typeof key})`);
      }
      map.set(key, this.valueSchema.fromPreparedMsgpack(value, rawStringProvider.withMapValue(key)));
    }
    return map;
  }
  prepareJSON(data, options) {
    if (!(data instanceof Map)) {
      throw new Error(`ByteArrayMapSchema data must be a Map. Got (${typeof data}) ${data}`);
    }
    const prepared = /* @__PURE__ */ new Map();
    for (const [key, value] of data) {
      if (!(key instanceof Uint8Array)) {
        throw new Error(`Invalid key: ${key} (${typeof key})`);
      }
      const b64Encoded = bytesToBase64(key);
      if (prepared.has(b64Encoded)) {
        throw new Error(`Duplicate key (base64): ${b64Encoded}`);
      }
      prepared.set(b64Encoded, this.valueSchema.prepareJSON(value, options));
    }
    const obj = {};
    for (const [key, value] of prepared) {
      obj[key] = value;
    }
    return obj;
  }
  fromPreparedJSON(encoded) {
    if (encoded == null || typeof encoded !== "object" || Array.isArray(encoded)) {
      throw new Error("ByteArrayMapSchema data must be an object");
    }
    const map = /* @__PURE__ */ new Map();
    for (const [key, value] of Object.entries(encoded)) {
      map.set(base64ToBytes(key), this.valueSchema.fromPreparedJSON(value));
    }
    return map;
  }
};
function convertRawStringsInMsgpackValue(value) {
  if (value instanceof RawBinaryString) {
    return bytesToString(value.rawBinaryValue);
  }
  if (value instanceof Map) {
    const newMap = /* @__PURE__ */ new Map();
    for (const [key, val] of value) {
      newMap.set(convertRawStringsInMsgpackValue(key), convertRawStringsInMsgpackValue(val));
    }
    return newMap;
  }
  if (Array.isArray(value)) {
    return value.map(convertRawStringsInMsgpackValue);
  }
  return value;
}
var SpecialCaseBinaryStringMapSchema = class extends Schema {
  constructor(valueSchema) {
    super();
    this.valueSchema = valueSchema;
  }
  defaultValue() {
    return /* @__PURE__ */ new Map();
  }
  isDefaultValue(data) {
    return data instanceof Map && data.size === 0;
  }
  prepareMsgpack(data) {
    if (!(data instanceof Map)) {
      throw new Error(`SpecialCaseBinaryStringMapSchema data must be a Map. Got (${typeof data}) ${data}`);
    }
    const prepared = /* @__PURE__ */ new Map();
    for (const [key, value] of data) {
      if (!(key instanceof Uint8Array)) {
        throw new Error(`Invalid key: ${key} (${typeof key})`);
      }
      prepared.set(new RawBinaryString(key), this.valueSchema.prepareMsgpack(value));
    }
    return prepared;
  }
  fromPreparedMsgpack(_encoded, rawStringProvider) {
    const map = /* @__PURE__ */ new Map();
    const keysAndValues = rawStringProvider.getRawStringKeysAndValuesAtCurrentLocation();
    for (const [key, value] of keysAndValues) {
      map.set(key, this.valueSchema.fromPreparedMsgpack(convertRawStringsInMsgpackValue(value), rawStringProvider.withMapValue(new RawBinaryString(key))));
    }
    return map;
  }
  prepareJSON(data, options) {
    if (!(data instanceof Map)) {
      throw new Error(`SpecialCaseBinaryStringMapSchema data must be a Map. Got (${typeof data}) ${data}`);
    }
    const prepared = /* @__PURE__ */ new Map();
    for (const [key, value] of data) {
      if (!(key instanceof Uint8Array)) {
        throw new Error(`Invalid key: ${key}`);
      }
      const keyStringValue = bytesToString(key);
      if (!options.lossyBinaryStringConversion && !arrayEqual(coerceToBytes(keyStringValue), key)) {
        throw new Error(`Invalid UTF-8 byte array encountered. Encode with lossyBinaryStringConversion enabled to bypass this check. Base64 value: ${bytesToBase64(key)}`);
      }
      prepared.set(keyStringValue, this.valueSchema.prepareJSON(value, options));
    }
    const obj = {};
    for (const [key, value] of prepared) {
      obj[key] = value;
    }
    return obj;
  }
  fromPreparedJSON(encoded) {
    if (encoded == null || typeof encoded !== "object" || Array.isArray(encoded)) {
      throw new Error("SpecialCaseBinaryStringMapSchema data must be an object");
    }
    const map = /* @__PURE__ */ new Map();
    for (const [key, value] of Object.entries(encoded)) {
      map.set(coerceToBytes(key), this.valueSchema.fromPreparedJSON(value));
    }
    return map;
  }
};

// node_modules/algosdk/dist/esm/encoding/schema/optional.js
var OptionalSchema = class extends Schema {
  constructor(valueSchema) {
    super();
    this.valueSchema = valueSchema;
  }
  defaultValue() {
    return void 0;
  }
  isDefaultValue(data) {
    return data === void 0 || this.valueSchema.isDefaultValue(data);
  }
  prepareMsgpack(data) {
    if (data === void 0) {
      return void 0;
    }
    return this.valueSchema.prepareMsgpack(data);
  }
  fromPreparedMsgpack(encoded, rawStringProvider) {
    if (encoded === void 0 || encoded === null) {
      return void 0;
    }
    return this.valueSchema.fromPreparedMsgpack(encoded, rawStringProvider);
  }
  prepareJSON(data, options) {
    if (data === void 0) {
      return null;
    }
    return this.valueSchema.prepareJSON(data, options);
  }
  fromPreparedJSON(encoded) {
    if (encoded === void 0 || encoded === null) {
      return void 0;
    }
    return this.valueSchema.fromPreparedJSON(encoded);
  }
};

// node_modules/algosdk/dist/esm/encoding/schema/untyped.js
var UntypedSchema = class extends Schema {
  defaultValue() {
    return void 0;
  }
  isDefaultValue(data) {
    return data === void 0;
  }
  prepareMsgpack(data) {
    return data;
  }
  fromPreparedMsgpack(encoded, _rawStringProvider) {
    return encoded;
  }
  prepareJSON(data, _options) {
    return msgpackEncodingDataToJSONEncodingData(data);
  }
  fromPreparedJSON(encoded) {
    return jsonEncodingDataToMsgpackEncodingData(encoded);
  }
};

// node_modules/algosdk/dist/esm/transaction.js
var import_hi_base323 = __toESM(require_base32(), 1);

// node_modules/algosdk/dist/esm/boxStorage.js
function boxReferenceToEncodingData(reference, foreignApps, appIndex) {
  const referenceId = BigInt(reference.appIndex);
  const referenceName = reference.name;
  const isOwnReference = referenceId === BigInt(0) || referenceId === appIndex;
  const index = foreignApps.indexOf(referenceId) + 1;
  if (index === 0 && !isOwnReference) {
    throw new Error(`Box ref with appId ${referenceId} not in foreign-apps`);
  }
  return /* @__PURE__ */ new Map([
    ["i", index],
    ["n", referenceName]
  ]);
}
function boxReferencesToEncodingData(references, foreignApps, appIndex) {
  const appIndexBigInt = BigInt(appIndex);
  const foreignAppsBigInt = foreignApps.map(BigInt);
  return references.map((bx) => boxReferenceToEncodingData(bx, foreignAppsBigInt, appIndexBigInt));
}

// node_modules/algosdk/dist/esm/appAccess.js
function resourceReferencesToEncodingData(appIndex, references) {
  const accessList = [];
  function ensure(target) {
    for (let idx = 0; idx < accessList.length; idx++) {
      const a2 = accessList[idx];
      const aAddress = a2.get("d");
      const addressesEqual = !target.address && !aAddress || target.address && aAddress && target.address.equals(aAddress);
      if (addressesEqual && a2.get("s") === target.assetIndex && a2.get("p") === target.appIndex) {
        return idx + 1;
      }
    }
    if (target.address) {
      accessList.push(/* @__PURE__ */ new Map([["d", target.address]]));
    }
    if (target.assetIndex) {
      accessList.push(/* @__PURE__ */ new Map([["s", target.assetIndex]]));
    }
    if (target.appIndex) {
      accessList.push(/* @__PURE__ */ new Map([["p", target.appIndex]]));
    }
    return accessList.length;
  }
  const zeroAddr = Address.zeroAddress();
  for (const rr of references) {
    if (rr.address || rr.assetIndex || rr.appIndex) {
      ensure(rr);
      continue;
    }
    if (rr.holding) {
      const h2 = rr.holding;
      let addrIdx = 0;
      if (h2.address && !h2.address.equals(zeroAddr)) {
        addrIdx = ensure({ address: h2.address });
      }
      const assetIdx = ensure({ assetIndex: h2.assetIndex });
      accessList.push(/* @__PURE__ */ new Map([
        [
          "h",
          /* @__PURE__ */ new Map([
            ["d", addrIdx],
            ["s", assetIdx]
          ])
        ]
      ]));
      continue;
    }
    if (rr.locals) {
      const l2 = rr.locals;
      let addrIdx = 0;
      if (l2.address && !l2.address.equals(zeroAddr)) {
        addrIdx = ensure({ address: l2.address });
      }
      let appIdx = 0;
      if (l2.appIndex && BigInt(l2.appIndex) !== appIndex) {
        appIdx = ensure({ appIndex: l2.appIndex });
      }
      accessList.push(/* @__PURE__ */ new Map([
        [
          "l",
          /* @__PURE__ */ new Map([
            ["d", addrIdx],
            ["p", appIdx]
          ])
        ]
      ]));
      continue;
    }
    if (rr.box) {
      const b2 = rr.box;
      let appIdx = 0;
      if (b2.appIndex && BigInt(b2.appIndex) !== appIndex) {
        appIdx = ensure({ appIndex: b2.appIndex });
      }
      accessList.push(/* @__PURE__ */ new Map([
        [
          "b",
          /* @__PURE__ */ new Map([
            ["i", appIdx],
            ["n", b2.name]
          ])
        ]
      ]));
    }
  }
  return accessList;
}
function convertIndicesToResourceReferences(accessList) {
  const references = [];
  for (const item of accessList) {
    const address = item.get("d");
    const assetIndex = item.get("s");
    const appIndex = item.get("p");
    if (address) {
      references.push({ address });
      continue;
    }
    if (assetIndex) {
      references.push({ assetIndex });
      continue;
    }
    if (appIndex) {
      references.push({ appIndex });
      continue;
    }
    const holding = item.get("h");
    if (holding) {
      const hAddressIndex = ensureSafeUnsignedInteger(holding.get("d") ?? 0);
      const hAssetIndex = ensureSafeUnsignedInteger(holding.get("s"));
      if (!hAssetIndex) {
        throw new Error(`Holding missing asset index: ${holding}`);
      }
      const hAddress = hAddressIndex === 0 ? Address.zeroAddress() : references[hAddressIndex - 1].address;
      const asset = references[hAssetIndex - 1].assetIndex;
      references.push({ holding: { address: hAddress, assetIndex: asset } });
      continue;
    }
    const locals = item.get("l");
    if (locals) {
      const lAddressIndex = ensureSafeUnsignedInteger(locals.get("d") ?? 0);
      const lAppIndex = ensureSafeUnsignedInteger(locals.get("p") ?? 0);
      const lAddress = lAddressIndex === 0 ? Address.zeroAddress() : references[lAddressIndex - 1].address;
      const app = lAppIndex === 0 ? BigInt(0) : references[lAppIndex - 1].appIndex;
      references.push({ locals: { address: lAddress, appIndex: app } });
      continue;
    }
    const box = item.get("b");
    if (box) {
      const bAppIndex = ensureSafeUnsignedInteger(box.get("i") ?? 0);
      const name = box.get("n");
      if (!name) {
        throw new Error(`Box missing name: ${box}`);
      }
      const app = bAppIndex === 0 ? BigInt(0) : references[bAppIndex - 1].appIndex;
      references.push({ box: { appIndex: app, name } });
    }
  }
  return references;
}
function foreignArraysToResourceReferences({ appIndex, accounts, foreignAssets, foreignApps, holdings, locals, boxes }) {
  const accessList = [];
  function ensureAddress2(addr) {
    let addr2;
    if (typeof addr === "string") {
      if (addr === "") {
        return;
      }
      addr2 = Address.fromString(addr);
    } else {
      addr2 = addr;
    }
    if (addr2.equals(Address.zeroAddress())) {
      return;
    }
    let addrFound = false;
    for (const rr of accessList) {
      if (!rr.address) {
        continue;
      }
      let rrAddress = rr.address;
      if (typeof rr.address === "string") {
        rrAddress = Address.fromString(rr.address);
      }
      if (rrAddress.equals(addr2)) {
        addrFound = true;
        break;
      }
    }
    if (!addrFound) {
      accessList.push({ address: addr });
    }
  }
  function ensureAsset(asset) {
    let assetFound = false;
    for (const rr of accessList) {
      if (rr.assetIndex === asset) {
        assetFound = true;
        break;
      }
    }
    if (!assetFound) {
      accessList.push({ assetIndex: asset });
    }
  }
  function ensureApp(app) {
    let appFound = false;
    for (const rr of accessList) {
      if (rr.appIndex === app) {
        appFound = true;
        break;
      }
    }
    if (!appFound) {
      accessList.push({ appIndex: app });
    }
  }
  for (const acct of accounts ?? []) {
    ensureAddress2(acct);
  }
  for (const asset of foreignAssets ?? []) {
    ensureAsset(asset);
  }
  for (const app of foreignApps ?? []) {
    ensureApp(app);
  }
  for (const holding of holdings ?? []) {
    if (holding.address) {
      ensureAddress2(holding.address);
    }
    ensureAsset(holding.assetIndex);
    accessList.push({ holding });
  }
  for (const local of locals ?? []) {
    if (local.address) {
      ensureAddress2(local.address);
    }
    if (local.appIndex && BigInt(local.appIndex) !== appIndex) {
      ensureApp(local.appIndex);
    }
    accessList.push({ locals: local });
  }
  for (const box of boxes ?? []) {
    if (box.appIndex && BigInt(box.appIndex) !== appIndex) {
      ensureApp(box.appIndex);
    }
    accessList.push({ box });
  }
  return accessList;
}

// node_modules/algosdk/dist/esm/types/transactions/base.js
var TransactionType;
(function(TransactionType2) {
  TransactionType2["pay"] = "pay";
  TransactionType2["keyreg"] = "keyreg";
  TransactionType2["acfg"] = "acfg";
  TransactionType2["axfer"] = "axfer";
  TransactionType2["afrz"] = "afrz";
  TransactionType2["appl"] = "appl";
  TransactionType2["stpf"] = "stpf";
  TransactionType2["hb"] = "hb";
})(TransactionType || (TransactionType = {}));
function isTransactionType(s2) {
  return s2 === TransactionType.pay || s2 === TransactionType.keyreg || s2 === TransactionType.acfg || s2 === TransactionType.axfer || s2 === TransactionType.afrz || s2 === TransactionType.appl || s2 === TransactionType.stpf || s2 === TransactionType.hb;
}
var OnApplicationComplete;
(function(OnApplicationComplete2) {
  OnApplicationComplete2[OnApplicationComplete2["NoOpOC"] = 0] = "NoOpOC";
  OnApplicationComplete2[OnApplicationComplete2["OptInOC"] = 1] = "OptInOC";
  OnApplicationComplete2[OnApplicationComplete2["CloseOutOC"] = 2] = "CloseOutOC";
  OnApplicationComplete2[OnApplicationComplete2["ClearStateOC"] = 3] = "ClearStateOC";
  OnApplicationComplete2[OnApplicationComplete2["UpdateApplicationOC"] = 4] = "UpdateApplicationOC";
  OnApplicationComplete2[OnApplicationComplete2["DeleteApplicationOC"] = 5] = "DeleteApplicationOC";
})(OnApplicationComplete || (OnApplicationComplete = {}));
function isOnApplicationComplete(v2) {
  return v2 === OnApplicationComplete.NoOpOC || v2 === OnApplicationComplete.OptInOC || v2 === OnApplicationComplete.CloseOutOC || v2 === OnApplicationComplete.ClearStateOC || v2 === OnApplicationComplete.UpdateApplicationOC || v2 === OnApplicationComplete.DeleteApplicationOC;
}

// node_modules/algosdk/dist/esm/stateproof.js
var HashFactory = class _HashFactory {
  constructor(params) {
    this.hashType = params.hashType;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _HashFactory.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([["t", this.hashType]]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded HashFactory: ${data}`);
    }
    return new _HashFactory({
      hashType: Number(data.get("t"))
    });
  }
};
HashFactory.encodingSchema = new NamedMapSchema(allOmitEmpty([
  { key: "t", valueSchema: new Uint64Schema() }
  // hashType
]));
var MerkleArrayProof = class _MerkleArrayProof {
  constructor(params) {
    this.path = params.path;
    this.hashFactory = params.hashFactory;
    this.treeDepth = params.treeDepth;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _MerkleArrayProof.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["pth", this.path],
      ["hsh", this.hashFactory.toEncodingData()],
      ["td", this.treeDepth]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded MerkleArrayProof: ${data}`);
    }
    return new _MerkleArrayProof({
      path: data.get("pth"),
      hashFactory: HashFactory.fromEncodingData(data.get("hsh")),
      treeDepth: Number(data.get("td"))
    });
  }
};
MerkleArrayProof.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "pth",
    // path
    valueSchema: new ArraySchema(new ByteArraySchema())
  },
  {
    key: "hsh",
    // hashFactory
    valueSchema: HashFactory.encodingSchema
  },
  {
    key: "td",
    // treeDepth
    valueSchema: new Uint64Schema()
  }
]));
var MerkleSignatureVerifier = class _MerkleSignatureVerifier {
  constructor(params) {
    this.commitment = params.commitment;
    this.keyLifetime = params.keyLifetime;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _MerkleSignatureVerifier.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["cmt", this.commitment],
      ["lf", this.keyLifetime]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded MerkleSignatureVerifier: ${data}`);
    }
    return new _MerkleSignatureVerifier({
      commitment: data.get("cmt"),
      keyLifetime: data.get("lf")
    });
  }
};
MerkleSignatureVerifier.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "cmt",
    // commitment
    valueSchema: new FixedLengthByteArraySchema(64)
  },
  {
    key: "lf",
    // keyLifetime
    valueSchema: new Uint64Schema()
  }
]));
var Participant = class _Participant {
  constructor(params) {
    this.pk = params.pk;
    this.weight = params.weight;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _Participant.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["p", this.pk.toEncodingData()],
      ["w", this.weight]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded Participant: ${data}`);
    }
    return new _Participant({
      pk: MerkleSignatureVerifier.fromEncodingData(data.get("p")),
      weight: data.get("w")
    });
  }
};
Participant.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "p",
    // pk
    valueSchema: MerkleSignatureVerifier.encodingSchema
  },
  {
    key: "w",
    // weight
    valueSchema: new Uint64Schema()
  }
]));
var FalconVerifier = class _FalconVerifier {
  constructor(params) {
    this.publicKey = params.publicKey;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _FalconVerifier.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([["k", this.publicKey]]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded FalconVerifier: ${data}`);
    }
    return new _FalconVerifier({
      publicKey: data.get("k")
    });
  }
};
FalconVerifier.encodingSchema = new NamedMapSchema(allOmitEmpty([
  { key: "k", valueSchema: new FixedLengthByteArraySchema(1793) }
  // publicKey
]));
var FalconSignatureStruct = class _FalconSignatureStruct {
  constructor(params) {
    this.signature = params.signature;
    this.vectorCommitmentIndex = params.index;
    this.proof = params.proof;
    this.verifyingKey = params.verifyingKey;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _FalconSignatureStruct.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["sig", this.signature],
      ["idx", this.vectorCommitmentIndex],
      ["prf", this.proof.toEncodingData()],
      ["vkey", this.verifyingKey.toEncodingData()]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded FalconSignatureStruct: ${data}`);
    }
    return new _FalconSignatureStruct({
      signature: data.get("sig"),
      index: data.get("idx"),
      proof: MerkleArrayProof.fromEncodingData(data.get("prf")),
      verifyingKey: FalconVerifier.fromEncodingData(data.get("vkey"))
    });
  }
};
FalconSignatureStruct.encodingSchema = new NamedMapSchema(allOmitEmpty([
  { key: "sig", valueSchema: new ByteArraySchema() },
  // signature
  { key: "idx", valueSchema: new Uint64Schema() },
  // index
  { key: "prf", valueSchema: MerkleArrayProof.encodingSchema },
  // proof
  { key: "vkey", valueSchema: FalconVerifier.encodingSchema }
  // verifyingKey
]));
var SigslotCommit = class _SigslotCommit {
  constructor(params) {
    this.sig = params.sig;
    this.l = params.l;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _SigslotCommit.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["s", this.sig.toEncodingData()],
      ["l", this.l]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded SigslotCommit: ${data}`);
    }
    return new _SigslotCommit({
      sig: FalconSignatureStruct.fromEncodingData(data.get("s")),
      l: data.get("l")
    });
  }
};
SigslotCommit.encodingSchema = new NamedMapSchema(allOmitEmpty([
  { key: "s", valueSchema: FalconSignatureStruct.encodingSchema },
  // sigslot
  { key: "l", valueSchema: new Uint64Schema() }
  // l
]));
var Reveal = class _Reveal {
  constructor(params) {
    this.sigslot = params.sigslot;
    this.participant = params.participant;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _Reveal.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["s", this.sigslot.toEncodingData()],
      ["p", this.participant.toEncodingData()]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded Reveal: ${data}`);
    }
    return new _Reveal({
      sigslot: SigslotCommit.fromEncodingData(data.get("s")),
      participant: Participant.fromEncodingData(data.get("p"))
    });
  }
};
Reveal.encodingSchema = new NamedMapSchema(allOmitEmpty([
  { key: "s", valueSchema: SigslotCommit.encodingSchema },
  // sigslotCommit
  { key: "p", valueSchema: Participant.encodingSchema }
  // participant
]));
var StateProof = class _StateProof {
  constructor(params) {
    this.sigCommit = params.sigCommit;
    this.signedWeight = params.signedWeight;
    this.sigProofs = params.sigProofs;
    this.partProofs = params.partProofs;
    this.merkleSignatureSaltVersion = params.merkleSignatureSaltVersion;
    this.reveals = params.reveals;
    this.positionsToReveal = params.positionsToReveal;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _StateProof.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["c", this.sigCommit],
      ["w", this.signedWeight],
      ["S", this.sigProofs.toEncodingData()],
      ["P", this.partProofs.toEncodingData()],
      ["v", this.merkleSignatureSaltVersion],
      [
        "r",
        convertMap(this.reveals, (key, value) => [key, value.toEncodingData()])
      ],
      ["pr", this.positionsToReveal]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded StateProof: ${data}`);
    }
    return new _StateProof({
      sigCommit: data.get("c"),
      signedWeight: data.get("w"),
      sigProofs: MerkleArrayProof.fromEncodingData(data.get("S")),
      partProofs: MerkleArrayProof.fromEncodingData(data.get("P")),
      merkleSignatureSaltVersion: Number(data.get("v")),
      reveals: convertMap(data.get("r"), (key, value) => [
        key,
        Reveal.fromEncodingData(value)
      ]),
      positionsToReveal: data.get("pr")
    });
  }
};
StateProof.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "c",
    // sigCommit
    valueSchema: new ByteArraySchema()
  },
  {
    key: "w",
    // signedWeight
    valueSchema: new Uint64Schema()
  },
  {
    key: "S",
    // sigProofs
    valueSchema: MerkleArrayProof.encodingSchema
  },
  {
    key: "P",
    // partProofs
    valueSchema: MerkleArrayProof.encodingSchema
  },
  {
    key: "v",
    // merkleSignatureSaltVersion
    valueSchema: new Uint64Schema()
  },
  {
    key: "r",
    // reveals
    valueSchema: new Uint64MapSchema(Reveal.encodingSchema)
  },
  {
    key: "pr",
    // positionsToReveal
    valueSchema: new ArraySchema(new Uint64Schema())
  }
]));
var StateProofMessage = class _StateProofMessage {
  constructor(params) {
    this.blockHeadersCommitment = params.blockHeadersCommitment;
    this.votersCommitment = params.votersCommitment;
    this.lnProvenWeight = params.lnProvenWeight;
    this.firstAttestedRound = params.firstAttestedRound;
    this.lastAttestedRound = params.lastAttestedRound;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _StateProofMessage.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["b", this.blockHeadersCommitment],
      ["v", this.votersCommitment],
      ["P", this.lnProvenWeight],
      ["f", this.firstAttestedRound],
      ["l", this.lastAttestedRound]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded StateProofMessage: ${data}`);
    }
    return new _StateProofMessage({
      blockHeadersCommitment: data.get("b"),
      votersCommitment: data.get("v"),
      lnProvenWeight: data.get("P"),
      firstAttestedRound: data.get("f"),
      lastAttestedRound: data.get("l")
    });
  }
  static fromMap(data) {
    return new _StateProofMessage({
      blockHeadersCommitment: data.get("b"),
      votersCommitment: data.get("v"),
      lnProvenWeight: data.get("P"),
      firstAttestedRound: data.get("f"),
      lastAttestedRound: data.get("l")
    });
  }
};
StateProofMessage.encodingSchema = new NamedMapSchema(allOmitEmpty([
  { key: "b", valueSchema: new ByteArraySchema() },
  // blockHeadersCommitment
  { key: "v", valueSchema: new ByteArraySchema() },
  // votersCommitment
  { key: "P", valueSchema: new Uint64Schema() },
  // lnProvenWeight
  { key: "f", valueSchema: new Uint64Schema() },
  // firstAttestedRound
  { key: "l", valueSchema: new Uint64Schema() }
  // lastAttestedRound
]));

// node_modules/algosdk/dist/esm/heartbeat.js
var HeartbeatProof = class _HeartbeatProof {
  constructor(params) {
    this.sig = params.sig;
    this.pk = params.pk;
    this.pk2 = params.pk2;
    this.pk1Sig = params.pk1Sig;
    this.pk2Sig = params.pk2Sig;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _HeartbeatProof.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["s", this.sig],
      ["p", this.pk],
      ["p2", this.pk2],
      ["p1s", this.pk1Sig],
      ["p2s", this.pk2Sig]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded HeartbeatProof: ${data}`);
    }
    return new _HeartbeatProof({
      sig: data.get("s"),
      pk: data.get("p"),
      pk2: data.get("p2"),
      pk1Sig: data.get("p1s"),
      pk2Sig: data.get("p2s")
    });
  }
};
HeartbeatProof.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "s",
    // Sig
    valueSchema: new FixedLengthByteArraySchema(64)
  },
  {
    key: "p",
    // PK
    valueSchema: new FixedLengthByteArraySchema(32)
  },
  {
    key: "p2",
    // PK2
    valueSchema: new FixedLengthByteArraySchema(32)
  },
  {
    key: "p1s",
    // PK1Sig
    valueSchema: new FixedLengthByteArraySchema(64)
  },
  {
    key: "p2s",
    // PK2Sig
    valueSchema: new FixedLengthByteArraySchema(64)
  }
]));
var Heartbeat = class _Heartbeat {
  constructor(params) {
    this.address = params.address;
    this.proof = params.proof;
    this.seed = params.seed;
    this.voteID = params.voteID;
    this.keyDilution = params.keyDilution;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _Heartbeat.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["a", this.address],
      ["prf", this.proof.toEncodingData()],
      ["sd", this.seed],
      ["vid", this.voteID],
      ["kd", this.keyDilution]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded Heartbeat: ${data}`);
    }
    return new _Heartbeat({
      address: data.get("a"),
      proof: HeartbeatProof.fromEncodingData(data.get("prf")),
      seed: data.get("sd"),
      voteID: data.get("vid"),
      keyDilution: data.get("kd")
    });
  }
};
Heartbeat.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "a",
    // HbAddress
    valueSchema: new AddressSchema()
  },
  {
    key: "prf",
    // HbProof
    valueSchema: HeartbeatProof.encodingSchema
  },
  {
    key: "sd",
    // HbSeed
    valueSchema: new ByteArraySchema()
  },
  {
    key: "vid",
    // HbVoteID
    valueSchema: new FixedLengthByteArraySchema(32)
  },
  {
    key: "kd",
    // HbKeyDilution
    valueSchema: new Uint64Schema()
  }
]));

// node_modules/algosdk/dist/esm/transaction.js
var ALGORAND_TRANSACTION_LENGTH = 52;
var ALGORAND_TRANSACTION_LEASE_LENGTH = 32;
var NUM_ADDL_BYTES_AFTER_SIGNING = 75;
var ASSET_METADATA_HASH_LENGTH = 32;
var KEYREG_VOTE_KEY_LENGTH = 32;
var KEYREG_SELECTION_KEY_LENGTH = 32;
var KEYREG_STATE_PROOF_KEY_LENGTH = 64;
var ALGORAND_TRANSACTION_GROUP_LENGTH = 32;
function uint8ArrayIsEmpty(input) {
  return input.every((value) => value === 0);
}
function getKeyregKey(input, inputName, length) {
  if (input == null) {
    return void 0;
  }
  let inputBytes;
  if (input instanceof Uint8Array) {
    inputBytes = input;
  }
  if (inputBytes == null || inputBytes.byteLength !== length) {
    throw Error(`${inputName} must be a ${length} byte Uint8Array`);
  }
  return inputBytes;
}
function ensureAddress(input) {
  if (input == null) {
    throw new Error("Address must not be null or undefined");
  }
  if (typeof input === "string") {
    return Address.fromString(input);
  }
  if (input instanceof Address) {
    return input;
  }
  throw new Error(`Not an address: ${input}`);
}
function optionalAddress(input) {
  if (input == null) {
    return void 0;
  }
  let addr;
  if (input instanceof Address) {
    addr = input;
  } else if (typeof input === "string") {
    addr = Address.fromString(input);
  } else {
    throw new Error(`Not an address: ${input}`);
  }
  if (uint8ArrayIsEmpty(addr.publicKey)) {
    throw new Error("Invalid use of the zero address. To omit this value, pass in undefined");
  }
  return addr;
}
function optionalUint8Array(input) {
  if (typeof input === "undefined") {
    return void 0;
  }
  if (input instanceof Uint8Array) {
    return input;
  }
  throw new Error(`Not a Uint8Array: ${input}`);
}
function ensureUint8Array2(input) {
  if (input instanceof Uint8Array) {
    return input;
  }
  throw new Error(`Not a Uint8Array: ${input}`);
}
function optionalUint64(input) {
  if (typeof input === "undefined") {
    return void 0;
  }
  return ensureUint64(input);
}
function ensureBoolean(input) {
  if (input === true || input === false) {
    return input;
  }
  throw new Error(`Not a boolean: ${input}`);
}
function ensureArray(input) {
  if (Array.isArray(input)) {
    return input.slice();
  }
  throw new Error(`Not an array: ${input}`);
}
function optionalFixedLengthByteArray(input, length, name) {
  const bytes = optionalUint8Array(input);
  if (typeof bytes === "undefined") {
    return void 0;
  }
  if (bytes.byteLength !== length) {
    throw new Error(`${name} must be ${length} bytes long, was ${bytes.byteLength}`);
  }
  if (uint8ArrayIsEmpty(bytes)) {
    return void 0;
  }
  return bytes;
}
function ensureBoxReference(input) {
  if (input != null && typeof input === "object") {
    const { appIndex, name } = input;
    return {
      appIndex: ensureUint64(appIndex),
      name: ensureUint8Array2(name)
    };
  }
  throw new Error(`Not a box reference: ${input}`);
}
function ensureHoldingReference(input) {
  if (input != null && typeof input === "object") {
    const { assetIndex, address } = input;
    return {
      assetIndex: ensureUint64(assetIndex),
      address: ensureAddress(address)
    };
  }
  throw new Error(`Not a holding reference: ${input}`);
}
function ensureLocalsReference(input) {
  if (input != null && typeof input === "object") {
    const { appIndex, address } = input;
    return {
      appIndex: ensureUint64(appIndex),
      address: ensureAddress(address)
    };
  }
  throw new Error(`Not a locals reference: ${input}`);
}
function ensureResourceReference(input) {
  if (input != null && typeof input === "object") {
    const { address, appIndex, assetIndex, holding, locals, box } = input;
    if (address !== void 0) {
      return { address: ensureAddress(address) };
    }
    if (appIndex !== void 0) {
      return { appIndex: ensureUint64(appIndex) };
    }
    if (assetIndex !== void 0) {
      return { assetIndex: ensureUint64(assetIndex) };
    }
    if (holding !== void 0) {
      return { holding: ensureHoldingReference(holding) };
    }
    if (locals !== void 0) {
      return { locals: ensureLocalsReference(locals) };
    }
    if (box !== void 0) {
      return { box: ensureBoxReference(box) };
    }
  }
  throw new Error(`Not a resource reference: ${input}`);
}
var TX_TAG = new TextEncoder().encode("TX");
var Transaction = class _Transaction {
  constructor(params) {
    if (!isTransactionType(params.type)) {
      throw new Error(`Invalid transaction type: ${params.type}`);
    }
    this.type = params.type;
    this.sender = ensureAddress(params.sender);
    this.note = ensureUint8Array2(params.note ?? new Uint8Array());
    this.lease = optionalFixedLengthByteArray(params.lease, ALGORAND_TRANSACTION_LEASE_LENGTH, "lease");
    this.rekeyTo = optionalAddress(params.rekeyTo);
    this.group = void 0;
    this.firstValid = ensureUint64(params.suggestedParams.firstValid);
    this.lastValid = ensureUint64(params.suggestedParams.lastValid);
    if (params.suggestedParams.genesisID) {
      if (typeof params.suggestedParams.genesisID !== "string") {
        throw new Error("Genesis ID must be a string if present");
      }
      this.genesisID = params.suggestedParams.genesisID;
    }
    this.genesisHash = optionalUint8Array(params.suggestedParams.genesisHash);
    const fieldsPresent = [];
    if (params.paymentParams)
      fieldsPresent.push(TransactionType.pay);
    if (params.keyregParams)
      fieldsPresent.push(TransactionType.keyreg);
    if (params.assetConfigParams)
      fieldsPresent.push(TransactionType.acfg);
    if (params.assetTransferParams)
      fieldsPresent.push(TransactionType.axfer);
    if (params.assetFreezeParams)
      fieldsPresent.push(TransactionType.afrz);
    if (params.appCallParams)
      fieldsPresent.push(TransactionType.appl);
    if (params.stateProofParams)
      fieldsPresent.push(TransactionType.stpf);
    if (params.heartbeatParams)
      fieldsPresent.push(TransactionType.hb);
    if (fieldsPresent.length !== 1) {
      throw new Error(`Transaction has wrong number of type fields present (${fieldsPresent.length}): ${fieldsPresent}`);
    }
    if (this.type !== fieldsPresent[0]) {
      throw new Error(`Transaction has type ${this.type} but fields present for ${fieldsPresent[0]}`);
    }
    if (params.paymentParams) {
      this.payment = {
        receiver: ensureAddress(params.paymentParams.receiver),
        amount: ensureUint64(params.paymentParams.amount),
        closeRemainderTo: optionalAddress(params.paymentParams.closeRemainderTo)
      };
    }
    if (params.keyregParams) {
      this.keyreg = {
        voteKey: getKeyregKey(params.keyregParams.voteKey, "voteKey", KEYREG_VOTE_KEY_LENGTH),
        selectionKey: getKeyregKey(params.keyregParams.selectionKey, "selectionKey", KEYREG_SELECTION_KEY_LENGTH),
        stateProofKey: getKeyregKey(params.keyregParams.stateProofKey, "stateProofKey", KEYREG_STATE_PROOF_KEY_LENGTH),
        voteFirst: optionalUint64(params.keyregParams.voteFirst),
        voteLast: optionalUint64(params.keyregParams.voteLast),
        voteKeyDilution: optionalUint64(params.keyregParams.voteKeyDilution),
        nonParticipation: ensureBoolean(params.keyregParams.nonParticipation ?? false)
      };
      if (this.keyreg.nonParticipation && (this.keyreg.voteKey || this.keyreg.selectionKey || this.keyreg.stateProofKey || typeof this.keyreg.voteFirst !== "undefined" || typeof this.keyreg.voteLast !== "undefined" || typeof this.keyreg.voteKeyDilution !== "undefined")) {
        throw new Error("nonParticipation is true but participation params are present.");
      }
      if (
        // If we are participating
        !this.keyreg.nonParticipation && // And *ANY* participating fields are present
        (this.keyreg.voteKey || this.keyreg.selectionKey || this.keyreg.stateProofKey || typeof this.keyreg.voteFirst !== "undefined" || typeof this.keyreg.voteLast !== "undefined" || typeof this.keyreg.voteKeyDilution !== "undefined") && // Then *ALL* participating fields must be present (with an exception for stateProofKey,
        // which was introduced later so for backwards compatibility we don't require it)
        !(this.keyreg.voteKey && this.keyreg.selectionKey && typeof this.keyreg.voteFirst !== "undefined" && typeof this.keyreg.voteLast !== "undefined" && typeof this.keyreg.voteKeyDilution !== "undefined")
      ) {
        throw new Error(`Online key registration missing at least one of the following fields: voteKey, selectionKey, voteFirst, voteLast, voteKeyDilution`);
      }
    }
    if (params.assetConfigParams) {
      this.assetConfig = {
        assetIndex: ensureUint64(params.assetConfigParams.assetIndex ?? 0),
        total: ensureUint64(params.assetConfigParams.total ?? 0),
        decimals: ensureSafeUnsignedInteger(params.assetConfigParams.decimals ?? 0),
        defaultFrozen: ensureBoolean(params.assetConfigParams.defaultFrozen ?? false),
        manager: optionalAddress(params.assetConfigParams.manager),
        reserve: optionalAddress(params.assetConfigParams.reserve),
        freeze: optionalAddress(params.assetConfigParams.freeze),
        clawback: optionalAddress(params.assetConfigParams.clawback),
        unitName: params.assetConfigParams.unitName,
        assetName: params.assetConfigParams.assetName,
        assetURL: params.assetConfigParams.assetURL,
        assetMetadataHash: optionalFixedLengthByteArray(params.assetConfigParams.assetMetadataHash, ASSET_METADATA_HASH_LENGTH, "assetMetadataHash")
      };
    }
    if (params.assetTransferParams) {
      this.assetTransfer = {
        assetIndex: ensureUint64(params.assetTransferParams.assetIndex),
        amount: ensureUint64(params.assetTransferParams.amount),
        assetSender: optionalAddress(params.assetTransferParams.assetSender),
        receiver: ensureAddress(params.assetTransferParams.receiver),
        closeRemainderTo: optionalAddress(params.assetTransferParams.closeRemainderTo)
      };
    }
    if (params.assetFreezeParams) {
      this.assetFreeze = {
        assetIndex: ensureUint64(params.assetFreezeParams.assetIndex),
        freezeAccount: ensureAddress(params.assetFreezeParams.freezeTarget),
        frozen: ensureBoolean(params.assetFreezeParams.frozen)
      };
    }
    if (params.appCallParams) {
      const { onComplete } = params.appCallParams;
      if (!isOnApplicationComplete(onComplete)) {
        throw new Error(`Invalid onCompletion value: ${onComplete}`);
      }
      this.applicationCall = {
        appIndex: ensureUint64(params.appCallParams.appIndex),
        onComplete,
        numLocalInts: ensureSafeUnsignedInteger(params.appCallParams.numLocalInts ?? 0),
        numLocalByteSlices: ensureSafeUnsignedInteger(params.appCallParams.numLocalByteSlices ?? 0),
        numGlobalInts: ensureSafeUnsignedInteger(params.appCallParams.numGlobalInts ?? 0),
        numGlobalByteSlices: ensureSafeUnsignedInteger(params.appCallParams.numGlobalByteSlices ?? 0),
        extraPages: ensureSafeUnsignedInteger(params.appCallParams.extraPages ?? 0),
        approvalProgram: ensureUint8Array2(params.appCallParams.approvalProgram ?? new Uint8Array()),
        clearProgram: ensureUint8Array2(params.appCallParams.clearProgram ?? new Uint8Array()),
        appArgs: ensureArray(params.appCallParams.appArgs ?? []).map(ensureUint8Array2),
        accounts: ensureArray(params.appCallParams.accounts ?? []).map(ensureAddress),
        foreignApps: ensureArray(params.appCallParams.foreignApps ?? []).map(ensureUint64),
        foreignAssets: ensureArray(params.appCallParams.foreignAssets ?? []).map(ensureUint64),
        boxes: ensureArray(params.appCallParams.boxes ?? []).map(ensureBoxReference),
        access: ensureArray(params.appCallParams.access ?? []).map(ensureResourceReference),
        rejectVersion: ensureSafeUnsignedInteger(params.appCallParams.rejectVersion ?? 0)
      };
    }
    if (params.stateProofParams) {
      this.stateProof = {
        stateProofType: ensureSafeUnsignedInteger(params.stateProofParams.stateProofType ?? 0),
        stateProof: params.stateProofParams.stateProof,
        message: params.stateProofParams.message
      };
    }
    if (params.heartbeatParams) {
      this.heartbeat = new Heartbeat({
        address: params.heartbeatParams.address,
        proof: params.heartbeatParams.proof,
        seed: params.heartbeatParams.seed,
        voteID: params.heartbeatParams.voteID,
        keyDilution: params.heartbeatParams.keyDilution
      });
    }
    this.fee = ensureUint64(params.suggestedParams.fee);
    const feeDependsOnSize = !ensureBoolean(params.suggestedParams.flatFee ?? false);
    if (feeDependsOnSize) {
      const minFee = ensureUint64(params.suggestedParams.minFee);
      this.fee *= BigInt(this.estimateSize());
      if (this.fee < minFee) {
        this.fee = minFee;
      }
    }
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _Transaction.encodingSchema;
  }
  toEncodingData() {
    const data = /* @__PURE__ */ new Map([
      ["type", this.type],
      ["fv", this.firstValid],
      ["lv", this.lastValid],
      ["snd", this.sender],
      ["gen", this.genesisID],
      ["gh", this.genesisHash],
      ["fee", this.fee],
      ["note", this.note],
      ["lx", this.lease],
      ["rekey", this.rekeyTo],
      ["grp", this.group]
    ]);
    if (this.payment) {
      data.set("amt", this.payment.amount);
      data.set("rcv", this.payment.receiver);
      data.set("close", this.payment.closeRemainderTo);
      return data;
    }
    if (this.keyreg) {
      data.set("votekey", this.keyreg.voteKey);
      data.set("selkey", this.keyreg.selectionKey);
      data.set("sprfkey", this.keyreg.stateProofKey);
      data.set("votefst", this.keyreg.voteFirst);
      data.set("votelst", this.keyreg.voteLast);
      data.set("votekd", this.keyreg.voteKeyDilution);
      data.set("nonpart", this.keyreg.nonParticipation);
      return data;
    }
    if (this.assetConfig) {
      data.set("caid", this.assetConfig.assetIndex);
      const assetParams = /* @__PURE__ */ new Map([
        ["t", this.assetConfig.total],
        ["dc", this.assetConfig.decimals],
        ["df", this.assetConfig.defaultFrozen],
        ["m", this.assetConfig.manager],
        ["r", this.assetConfig.reserve],
        ["f", this.assetConfig.freeze],
        ["c", this.assetConfig.clawback],
        ["un", this.assetConfig.unitName],
        ["an", this.assetConfig.assetName],
        ["au", this.assetConfig.assetURL],
        ["am", this.assetConfig.assetMetadataHash]
      ]);
      data.set("apar", assetParams);
      return data;
    }
    if (this.assetTransfer) {
      data.set("xaid", this.assetTransfer.assetIndex);
      data.set("aamt", this.assetTransfer.amount);
      data.set("arcv", this.assetTransfer.receiver);
      data.set("aclose", this.assetTransfer.closeRemainderTo);
      data.set("asnd", this.assetTransfer.assetSender);
      return data;
    }
    if (this.assetFreeze) {
      data.set("faid", this.assetFreeze.assetIndex);
      data.set("afrz", this.assetFreeze.frozen);
      data.set("fadd", this.assetFreeze.freezeAccount);
      return data;
    }
    if (this.applicationCall) {
      data.set("apid", this.applicationCall.appIndex);
      data.set("apan", this.applicationCall.onComplete);
      data.set("apaa", this.applicationCall.appArgs);
      data.set("apat", this.applicationCall.accounts);
      data.set("apas", this.applicationCall.foreignAssets);
      data.set("apfa", this.applicationCall.foreignApps);
      data.set("apbx", boxReferencesToEncodingData(this.applicationCall.boxes, this.applicationCall.foreignApps, this.applicationCall.appIndex));
      data.set("al", resourceReferencesToEncodingData(this.applicationCall.appIndex, this.applicationCall.access));
      data.set("apap", this.applicationCall.approvalProgram);
      data.set("apsu", this.applicationCall.clearProgram);
      data.set("apls", /* @__PURE__ */ new Map([
        ["nui", this.applicationCall.numLocalInts],
        ["nbs", this.applicationCall.numLocalByteSlices]
      ]));
      data.set("apgs", /* @__PURE__ */ new Map([
        ["nui", this.applicationCall.numGlobalInts],
        ["nbs", this.applicationCall.numGlobalByteSlices]
      ]));
      data.set("apep", this.applicationCall.extraPages);
      data.set("aprv", this.applicationCall.rejectVersion);
      return data;
    }
    if (this.stateProof) {
      data.set("sptype", this.stateProof.stateProofType);
      data.set("sp", this.stateProof.stateProof ? this.stateProof.stateProof.toEncodingData() : void 0);
      data.set("spmsg", this.stateProof.message ? this.stateProof.message.toEncodingData() : void 0);
      return data;
    }
    if (this.heartbeat) {
      const heartbeat = new Heartbeat({
        address: this.heartbeat.address,
        proof: this.heartbeat.proof,
        seed: this.heartbeat.seed,
        voteID: this.heartbeat.voteID,
        keyDilution: this.heartbeat.keyDilution
      });
      data.set("hb", heartbeat.toEncodingData());
      return data;
    }
    throw new Error(`Unexpected transaction type: ${this.type}`);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded logic sig account: ${data}`);
    }
    const suggestedParams = {
      minFee: BigInt(0),
      flatFee: true,
      fee: data.get("fee") ?? 0,
      firstValid: data.get("fv") ?? 0,
      lastValid: data.get("lv") ?? 0,
      genesisHash: data.get("gh"),
      genesisID: data.get("gen")
    };
    const txnType = data.get("type");
    if (!isTransactionType(txnType)) {
      throw new Error(`Unrecognized transaction type: ${txnType}`);
    }
    const params = {
      type: txnType,
      sender: data.get("snd") ?? Address.zeroAddress(),
      note: data.get("note"),
      lease: data.get("lx"),
      suggestedParams
    };
    if (data.get("rekey")) {
      params.rekeyTo = data.get("rekey");
    }
    if (params.type === TransactionType.pay) {
      const paymentParams = {
        amount: data.get("amt") ?? 0,
        receiver: data.get("rcv") ?? Address.zeroAddress()
      };
      if (data.get("close")) {
        paymentParams.closeRemainderTo = data.get("close");
      }
      params.paymentParams = paymentParams;
    } else if (params.type === TransactionType.keyreg) {
      const keyregParams = {
        voteKey: data.get("votekey"),
        selectionKey: data.get("selkey"),
        stateProofKey: data.get("sprfkey"),
        voteFirst: data.get("votefst"),
        voteLast: data.get("votelst"),
        voteKeyDilution: data.get("votekd"),
        nonParticipation: data.get("nonpart")
      };
      params.keyregParams = keyregParams;
    } else if (params.type === TransactionType.acfg) {
      const assetConfigParams = {
        assetIndex: data.get("caid")
      };
      if (data.get("apar")) {
        const assetParams = data.get("apar");
        assetConfigParams.total = assetParams.get("t");
        assetConfigParams.decimals = assetParams.get("dc");
        assetConfigParams.defaultFrozen = assetParams.get("df");
        assetConfigParams.unitName = assetParams.get("un");
        assetConfigParams.assetName = assetParams.get("an");
        assetConfigParams.assetURL = assetParams.get("au");
        assetConfigParams.assetMetadataHash = assetParams.get("am");
        if (assetParams.get("m")) {
          assetConfigParams.manager = assetParams.get("m");
        }
        if (assetParams.get("r")) {
          assetConfigParams.reserve = assetParams.get("r");
        }
        if (assetParams.get("f")) {
          assetConfigParams.freeze = assetParams.get("f");
        }
        if (assetParams.get("c")) {
          assetConfigParams.clawback = assetParams.get("c");
        }
      }
      params.assetConfigParams = assetConfigParams;
    } else if (params.type === TransactionType.axfer) {
      const assetTransferParams = {
        assetIndex: data.get("xaid") ?? 0,
        amount: data.get("aamt") ?? 0,
        receiver: data.get("arcv") ?? Address.zeroAddress()
      };
      if (data.get("aclose")) {
        assetTransferParams.closeRemainderTo = data.get("aclose");
      }
      if (data.get("asnd")) {
        assetTransferParams.assetSender = data.get("asnd");
      }
      params.assetTransferParams = assetTransferParams;
    } else if (params.type === TransactionType.afrz) {
      const assetFreezeParams = {
        assetIndex: data.get("faid") ?? 0,
        freezeTarget: data.get("fadd") ?? Address.zeroAddress(),
        frozen: data.get("afrz") ?? false
      };
      params.assetFreezeParams = assetFreezeParams;
    } else if (params.type === TransactionType.appl) {
      const appCallParams = {
        appIndex: data.get("apid") ?? 0,
        onComplete: ensureSafeUnsignedInteger(data.get("apan") ?? 0),
        appArgs: data.get("apaa"),
        accounts: data.get("apat"),
        foreignAssets: data.get("apas"),
        foreignApps: data.get("apfa"),
        approvalProgram: data.get("apap"),
        clearProgram: data.get("apsu"),
        extraPages: data.get("apep"),
        rejectVersion: data.get("aprv") ?? 0
      };
      const localSchema = data.get("apls");
      if (localSchema) {
        appCallParams.numLocalInts = localSchema.get("nui");
        appCallParams.numLocalByteSlices = localSchema.get("nbs");
      }
      const globalSchema = data.get("apgs");
      if (globalSchema) {
        appCallParams.numGlobalInts = globalSchema.get("nui");
        appCallParams.numGlobalByteSlices = globalSchema.get("nbs");
      }
      const boxes = data.get("apbx");
      if (boxes) {
        appCallParams.boxes = boxes.map((box) => {
          const index = ensureSafeUnsignedInteger(box.get("i") ?? 0);
          const name = ensureUint8Array2(box.get("n") ?? new Uint8Array());
          if (index === 0) {
            return {
              appIndex: 0,
              name
            };
          }
          if (!appCallParams.foreignApps || index > appCallParams.foreignApps.length) {
            throw new Error(`Cannot find foreign app index ${index} in ${appCallParams.foreignApps}`);
          }
          return {
            appIndex: appCallParams.foreignApps[index - 1],
            name
          };
        });
      }
      const references = data.get("al");
      if (references) {
        appCallParams.access = convertIndicesToResourceReferences(references);
      }
      params.appCallParams = appCallParams;
    } else if (params.type === TransactionType.stpf) {
      const stateProofParams = {
        stateProofType: data.get("sptype"),
        stateProof: data.get("sp") ? StateProof.fromEncodingData(data.get("sp")) : void 0,
        message: data.get("spmsg") ? StateProofMessage.fromEncodingData(data.get("spmsg")) : void 0
      };
      params.stateProofParams = stateProofParams;
    } else if (params.type === TransactionType.hb) {
      const heartbeat = Heartbeat.fromEncodingData(data.get("hb"));
      const heartbeatParams = {
        address: heartbeat.address,
        proof: heartbeat.proof,
        seed: heartbeat.seed,
        voteID: heartbeat.voteID,
        keyDilution: heartbeat.keyDilution
      };
      params.heartbeatParams = heartbeatParams;
    } else {
      const exhaustiveCheck = params.type;
      throw new Error(`Unexpected transaction type: ${exhaustiveCheck}`);
    }
    const txn = new _Transaction(params);
    if (data.get("grp")) {
      const group = ensureUint8Array2(data.get("grp"));
      if (group.byteLength !== ALGORAND_TRANSACTION_GROUP_LENGTH) {
        throw new Error(`Invalid group length: ${group.byteLength}`);
      }
      txn.group = group;
    }
    return txn;
  }
  estimateSize() {
    return this.toByte().length + NUM_ADDL_BYTES_AFTER_SIGNING;
  }
  bytesToSign() {
    const encodedMsg = this.toByte();
    return concatArrays2(TX_TAG, encodedMsg);
  }
  toByte() {
    return encodeMsgpack(this);
  }
  // returns the raw signature
  rawSignTxn(sk) {
    const toBeSigned = this.bytesToSign();
    const sig = sign(toBeSigned, sk);
    return sig;
  }
  signTxn(sk) {
    const keypair = keyPairFromSecretKey(sk);
    const signerAddr = new Address(keypair.publicKey);
    const sig = this.rawSignTxn(sk);
    return this.attachSignature(signerAddr, sig);
  }
  attachSignature(signerAddr, signature) {
    if (!isValidSignatureLength(signature.length)) {
      throw new Error("Invalid signature length");
    }
    const sTxn = /* @__PURE__ */ new Map([
      ["sig", signature],
      ["txn", this.toEncodingData()]
    ]);
    const signerAddrObj = ensureAddress(signerAddr);
    if (!this.sender.equals(signerAddrObj)) {
      sTxn.set("sgnr", signerAddrObj);
    }
    const stxnSchema = new NamedMapSchema(allOmitEmpty([
      {
        key: "txn",
        valueSchema: _Transaction.encodingSchema
      },
      {
        key: "sig",
        valueSchema: new FixedLengthByteArraySchema(64)
      },
      {
        key: "sgnr",
        valueSchema: new OptionalSchema(new AddressSchema())
      }
    ]));
    return msgpackRawEncode(stxnSchema.prepareMsgpack(sTxn));
  }
  rawTxID() {
    const enMsg = this.toByte();
    const gh = concatArrays2(TX_TAG, enMsg);
    return Uint8Array.from(genericHash(gh));
  }
  txID() {
    const hash = this.rawTxID();
    return import_hi_base323.default.encode(hash).slice(0, ALGORAND_TRANSACTION_LENGTH);
  }
};
Transaction.encodingSchema = new NamedMapSchema(allOmitEmpty([
  // Common
  { key: "type", valueSchema: new StringSchema() },
  { key: "snd", valueSchema: new AddressSchema() },
  { key: "lv", valueSchema: new Uint64Schema() },
  { key: "gen", valueSchema: new OptionalSchema(new StringSchema()) },
  {
    key: "gh",
    valueSchema: new OptionalSchema(new FixedLengthByteArraySchema(32))
  },
  { key: "fee", valueSchema: new Uint64Schema() },
  { key: "fv", valueSchema: new Uint64Schema() },
  { key: "note", valueSchema: new ByteArraySchema() },
  {
    key: "lx",
    valueSchema: new OptionalSchema(new FixedLengthByteArraySchema(32))
  },
  { key: "rekey", valueSchema: new OptionalSchema(new AddressSchema()) },
  {
    key: "grp",
    valueSchema: new OptionalSchema(new FixedLengthByteArraySchema(32))
  },
  // We mark all top-level type-specific fields optional because they will not be present when
  // the transaction is not that type.
  // Payment
  { key: "amt", valueSchema: new OptionalSchema(new Uint64Schema()) },
  { key: "rcv", valueSchema: new OptionalSchema(new AddressSchema()) },
  { key: "close", valueSchema: new OptionalSchema(new AddressSchema()) },
  // Keyreg
  {
    key: "votekey",
    valueSchema: new OptionalSchema(new FixedLengthByteArraySchema(32))
  },
  {
    key: "selkey",
    valueSchema: new OptionalSchema(new FixedLengthByteArraySchema(32))
  },
  {
    key: "sprfkey",
    valueSchema: new OptionalSchema(new FixedLengthByteArraySchema(64))
  },
  { key: "votefst", valueSchema: new OptionalSchema(new Uint64Schema()) },
  { key: "votelst", valueSchema: new OptionalSchema(new Uint64Schema()) },
  { key: "votekd", valueSchema: new OptionalSchema(new Uint64Schema()) },
  { key: "nonpart", valueSchema: new OptionalSchema(new BooleanSchema()) },
  // AssetConfig
  { key: "caid", valueSchema: new OptionalSchema(new Uint64Schema()) },
  {
    key: "apar",
    valueSchema: new OptionalSchema(new NamedMapSchema(allOmitEmpty([
      { key: "t", valueSchema: new Uint64Schema() },
      { key: "dc", valueSchema: new Uint64Schema() },
      { key: "df", valueSchema: new BooleanSchema() },
      {
        key: "m",
        valueSchema: new OptionalSchema(new AddressSchema())
      },
      {
        key: "r",
        valueSchema: new OptionalSchema(new AddressSchema())
      },
      {
        key: "f",
        valueSchema: new OptionalSchema(new AddressSchema())
      },
      {
        key: "c",
        valueSchema: new OptionalSchema(new AddressSchema())
      },
      {
        key: "un",
        valueSchema: new OptionalSchema(new StringSchema())
      },
      {
        key: "an",
        valueSchema: new OptionalSchema(new StringSchema())
      },
      {
        key: "au",
        valueSchema: new OptionalSchema(new StringSchema())
      },
      {
        key: "am",
        valueSchema: new OptionalSchema(new FixedLengthByteArraySchema(32))
      }
    ])))
  },
  // AssetTransfer
  { key: "xaid", valueSchema: new OptionalSchema(new Uint64Schema()) },
  { key: "aamt", valueSchema: new OptionalSchema(new Uint64Schema()) },
  { key: "arcv", valueSchema: new OptionalSchema(new AddressSchema()) },
  { key: "aclose", valueSchema: new OptionalSchema(new AddressSchema()) },
  { key: "asnd", valueSchema: new OptionalSchema(new AddressSchema()) },
  // AssetFreeze
  { key: "faid", valueSchema: new OptionalSchema(new Uint64Schema()) },
  { key: "afrz", valueSchema: new OptionalSchema(new BooleanSchema()) },
  { key: "fadd", valueSchema: new OptionalSchema(new AddressSchema()) },
  // Application
  { key: "apid", valueSchema: new OptionalSchema(new Uint64Schema()) },
  { key: "apan", valueSchema: new OptionalSchema(new Uint64Schema()) },
  {
    key: "apaa",
    valueSchema: new OptionalSchema(new ArraySchema(new ByteArraySchema()))
  },
  {
    key: "apat",
    valueSchema: new OptionalSchema(new ArraySchema(new AddressSchema()))
  },
  {
    key: "apas",
    valueSchema: new OptionalSchema(new ArraySchema(new Uint64Schema()))
  },
  {
    key: "apfa",
    valueSchema: new OptionalSchema(new ArraySchema(new Uint64Schema()))
  },
  {
    key: "apbx",
    valueSchema: new OptionalSchema(new ArraySchema(new NamedMapSchema(allOmitEmpty([
      {
        key: "i",
        valueSchema: new Uint64Schema()
      },
      {
        key: "n",
        valueSchema: new ByteArraySchema()
      }
    ]))))
  },
  {
    key: "al",
    valueSchema: new OptionalSchema(new ArraySchema(new NamedMapSchema(allOmitEmpty([
      {
        key: "d",
        valueSchema: new OptionalSchema(new AddressSchema())
      },
      {
        key: "s",
        valueSchema: new OptionalSchema(new Uint64Schema())
      },
      {
        key: "p",
        valueSchema: new OptionalSchema(new Uint64Schema())
      },
      {
        key: "h",
        valueSchema: new OptionalSchema(new NamedMapSchema(allOmitEmpty([
          {
            key: "d",
            valueSchema: new Uint64Schema()
          },
          {
            key: "s",
            valueSchema: new Uint64Schema()
          }
        ])))
      },
      {
        key: "l",
        valueSchema: new OptionalSchema(new NamedMapSchema(allOmitEmpty([
          {
            key: "d",
            valueSchema: new Uint64Schema()
          },
          {
            key: "p",
            valueSchema: new Uint64Schema()
          }
        ])))
      },
      {
        key: "b",
        valueSchema: new OptionalSchema(new NamedMapSchema(allOmitEmpty([
          {
            key: "i",
            valueSchema: new Uint64Schema()
          },
          {
            key: "n",
            valueSchema: new ByteArraySchema()
          }
        ])))
      }
    ]))))
  },
  { key: "apap", valueSchema: new OptionalSchema(new ByteArraySchema()) },
  { key: "apsu", valueSchema: new OptionalSchema(new ByteArraySchema()) },
  {
    key: "apls",
    valueSchema: new OptionalSchema(new NamedMapSchema(allOmitEmpty([
      {
        key: "nui",
        valueSchema: new Uint64Schema()
      },
      {
        key: "nbs",
        valueSchema: new Uint64Schema()
      }
    ])))
  },
  {
    key: "apgs",
    valueSchema: new OptionalSchema(new NamedMapSchema(allOmitEmpty([
      {
        key: "nui",
        valueSchema: new Uint64Schema()
      },
      {
        key: "nbs",
        valueSchema: new Uint64Schema()
      }
    ])))
  },
  { key: "apep", valueSchema: new OptionalSchema(new Uint64Schema()) },
  { key: "aprv", valueSchema: new OptionalSchema(new Uint64Schema()) },
  // StateProof
  { key: "sptype", valueSchema: new OptionalSchema(new Uint64Schema()) },
  { key: "sp", valueSchema: new OptionalSchema(StateProof.encodingSchema) },
  {
    key: "spmsg",
    valueSchema: new OptionalSchema(StateProofMessage.encodingSchema)
  },
  // Heartbeat
  { key: "hb", valueSchema: new OptionalSchema(Heartbeat.encodingSchema) }
]));
function encodeUnsignedTransaction(transactionObject) {
  return encodeMsgpack(transactionObject);
}
function decodeUnsignedTransaction(transactionBuffer) {
  return decodeMsgpack(transactionBuffer, Transaction);
}

// node_modules/algosdk/dist/esm/multisig.js
var MULTISIG_PREIMG2ADDR_PREFIX = new Uint8Array([
  77,
  117,
  108,
  116,
  105,
  115,
  105,
  103,
  65,
  100,
  100,
  114
]);
var INVALID_MSIG_VERSION_ERROR_MSG = "invalid multisig version";
var INVALID_MSIG_THRESHOLD_ERROR_MSG = "bad multisig threshold";
var INVALID_MSIG_PK_ERROR_MSG = "bad multisig public key - wrong length";
var UNEXPECTED_PK_LEN_ERROR_MSG = "nacl public key length is not 32 bytes";
function pksFromAddresses(addrs) {
  return addrs.map((addr) => {
    if (typeof addr === "string") {
      return Address.fromString(addr).publicKey;
    }
    return addr.publicKey;
  });
}
function addressFromMultisigPreImg({ version, threshold, pks }) {
  if (version !== 1 || version > 255 || version < 0) {
    throw new Error(INVALID_MSIG_VERSION_ERROR_MSG);
  }
  if (threshold === 0 || pks.length === 0 || threshold > pks.length || threshold > 255) {
    throw new Error(INVALID_MSIG_THRESHOLD_ERROR_MSG);
  }
  const pkLen = ALGORAND_ADDRESS_BYTE_LENGTH - ALGORAND_CHECKSUM_BYTE_LENGTH;
  if (pkLen !== PUBLIC_KEY_LENGTH) {
    throw new Error(UNEXPECTED_PK_LEN_ERROR_MSG);
  }
  const merged = new Uint8Array(MULTISIG_PREIMG2ADDR_PREFIX.length + 2 + pkLen * pks.length);
  merged.set(MULTISIG_PREIMG2ADDR_PREFIX, 0);
  merged.set([version], MULTISIG_PREIMG2ADDR_PREFIX.length);
  merged.set([threshold], MULTISIG_PREIMG2ADDR_PREFIX.length + 1);
  for (let i2 = 0; i2 < pks.length; i2++) {
    if (pks[i2].length !== pkLen) {
      throw new Error(INVALID_MSIG_PK_ERROR_MSG);
    }
    merged.set(pks[i2], MULTISIG_PREIMG2ADDR_PREFIX.length + 2 + i2 * pkLen);
  }
  return new Address(Uint8Array.from(genericHash(merged)));
}
function addressFromMultisigPreImgAddrs({ version, threshold, addrs }) {
  const pks = pksFromAddresses(addrs);
  return addressFromMultisigPreImg({ version, threshold, pks });
}
function verifyMultisig(toBeVerified, msig, publicKey) {
  const version = msig.v;
  const threshold = msig.thr;
  const subsigs = msig.subsig;
  const pks = subsigs.map((subsig) => subsig.pk);
  if (msig.subsig.length < threshold) {
    return false;
  }
  let pk;
  try {
    pk = addressFromMultisigPreImg({ version, threshold, pks }).publicKey;
  } catch (e2) {
    return false;
  }
  if (!arrayEqual(pk, publicKey)) {
    return false;
  }
  let counter = 0;
  for (const subsig of subsigs) {
    if (subsig.s !== void 0) {
      counter += 1;
    }
  }
  if (counter < threshold) {
    return false;
  }
  let verifiedCounter = 0;
  for (const subsig of subsigs) {
    if (subsig.s !== void 0) {
      if (verify(toBeVerified, subsig.s, subsig.pk)) {
        verifiedCounter += 1;
      }
    }
  }
  if (verifiedCounter < threshold) {
    return false;
  }
  return true;
}
function multisigAddress({ version, threshold, addrs }) {
  return addressFromMultisigPreImgAddrs({ version, threshold, addrs });
}

// node_modules/algosdk/dist/esm/types/transactions/encoded.js
var ENCODED_SUBSIG_SCHEMA = new NamedMapSchema(allOmitEmpty([
  {
    key: "pk",
    valueSchema: new FixedLengthByteArraySchema(32)
  },
  {
    key: "s",
    valueSchema: new OptionalSchema(new FixedLengthByteArraySchema(64))
  }
]));
function encodedSubsigFromEncodingData(data) {
  if (!(data instanceof Map)) {
    throw new Error(`Invalid decoded EncodedSubsig: ${data}`);
  }
  const subsig = {
    pk: data.get("pk")
  };
  if (data.get("s")) {
    subsig.s = data.get("s");
  }
  return subsig;
}
function encodedSubsigToEncodingData(subsig) {
  const data = /* @__PURE__ */ new Map([["pk", subsig.pk]]);
  if (subsig.s) {
    data.set("s", subsig.s);
  }
  return data;
}
var ENCODED_MULTISIG_SCHEMA = new NamedMapSchema(allOmitEmpty([
  {
    key: "v",
    valueSchema: new Uint64Schema()
  },
  {
    key: "thr",
    valueSchema: new Uint64Schema()
  },
  {
    key: "subsig",
    valueSchema: new ArraySchema(ENCODED_SUBSIG_SCHEMA)
  }
]));
function encodedMultiSigFromEncodingData(data) {
  if (!(data instanceof Map)) {
    throw new Error(`Invalid decoded EncodedMultiSig: ${data}`);
  }
  return {
    v: ensureSafeUnsignedInteger(data.get("v")),
    thr: ensureSafeUnsignedInteger(data.get("thr")),
    subsig: data.get("subsig").map(encodedSubsigFromEncodingData)
  };
}
function encodedMultiSigToEncodingData(msig) {
  return /* @__PURE__ */ new Map([
    ["v", msig.v],
    ["thr", msig.thr],
    ["subsig", msig.subsig.map(encodedSubsigToEncodingData)]
  ]);
}

// node_modules/algosdk/dist/esm/logicsig.js
var base64regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
function sanityCheckProgram(program) {
  if (!program || program.length === 0)
    throw new Error("empty program");
  const lineBreakOrd = "\n".charCodeAt(0);
  const blankSpaceOrd = " ".charCodeAt(0);
  const tildeOrd = "~".charCodeAt(0);
  const isPrintable = (x2) => blankSpaceOrd <= x2 && x2 <= tildeOrd;
  const isAsciiPrintable = program.every((x2) => x2 === lineBreakOrd || isPrintable(x2));
  if (isAsciiPrintable) {
    const programStr = new TextDecoder().decode(program);
    if (isValidAddress2(programStr))
      throw new Error("requesting program bytes, get Algorand address");
    if (base64regex.test(programStr))
      throw new Error("program should not be b64 encoded");
    throw new Error("program bytes are all ASCII printable characters, not looking like Teal byte code");
  }
}
var programTag = new TextEncoder().encode("Program");
var multisigProgramTag = new TextEncoder().encode("MsigProgram");
var LogicSig = class _LogicSig {
  constructor(program, programArgs) {
    if (programArgs && (!Array.isArray(programArgs) || !programArgs.every((arg) => arg.constructor === Uint8Array))) {
      throw new TypeError("Invalid arguments");
    }
    let args = [];
    if (programArgs != null)
      args = programArgs.map((arg) => new Uint8Array(arg));
    sanityCheckProgram(program);
    this.logic = program;
    this.args = args;
    this.sig = void 0;
    this.msig = void 0;
    this.lmsig = void 0;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _LogicSig.encodingSchema;
  }
  toEncodingData() {
    const data = /* @__PURE__ */ new Map([
      ["l", this.logic],
      ["arg", this.args],
      ["sig", this.sig]
    ]);
    if (this.msig) {
      data.set("msig", encodedMultiSigToEncodingData(this.msig));
    }
    if (this.lmsig) {
      data.set("lmsig", encodedMultiSigToEncodingData(this.lmsig));
    }
    return data;
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded logic sig: ${data}`);
    }
    const lsig = new _LogicSig(data.get("l"), data.get("arg"));
    lsig.sig = data.get("sig");
    if (data.get("msig")) {
      lsig.msig = encodedMultiSigFromEncodingData(data.get("msig"));
    }
    if (data.get("lmsig")) {
      lsig.lmsig = encodedMultiSigFromEncodingData(data.get("lmsig"));
    }
    return lsig;
  }
  /**
   * Performs signature verification
   * @param publicKey - Verification key (derived from sender address or escrow address)
   */
  verify(publicKey) {
    const sigCount = [this.sig, this.msig, this.lmsig].filter(Boolean).length;
    if (sigCount > 1) {
      return false;
    }
    try {
      sanityCheckProgram(this.logic);
    } catch (e2) {
      return false;
    }
    const toBeSigned = concatArrays2(programTag, this.logic);
    if (!this.sig && !this.msig && !this.lmsig) {
      const hash = genericHash(toBeSigned);
      return arrayEqual(hash, publicKey);
    }
    if (this.sig) {
      return verify(toBeSigned, this.sig, publicKey);
    }
    if (this.lmsig) {
      const multisigAddr = addressFromMultisigPreImg({
        version: this.lmsig.v,
        threshold: this.lmsig.thr,
        pks: this.lmsig.subsig.map((subsig) => subsig.pk)
      });
      const lmsigProgram = concatArrays2(multisigProgramTag, multisigAddr.publicKey, this.logic);
      return verifyMultisig(lmsigProgram, this.lmsig, publicKey);
    }
    if (this.msig) {
      return verifyMultisig(toBeSigned, this.msig, publicKey);
    }
    return false;
  }
  /**
   * Compute hash of the logic sig program (that is the same as escrow account address) as string address
   * @returns String representation of the address
   */
  address() {
    const toBeSigned = concatArrays2(programTag, this.logic);
    const hash = genericHash(toBeSigned);
    return new Address(Uint8Array.from(hash));
  }
  /**
   * Creates signature (if no msig provided) or multi signature otherwise
   * @param secretKey - Secret key to sign with
   * @param msig - Multisig account as \{version, threshold, addrs\}
   */
  sign(secretKey, msig) {
    if (msig == null) {
      this.sig = this.signProgram(secretKey);
    } else {
      const subsigs = pksFromAddresses(msig.addrs).map((pk) => ({ pk }));
      this.lmsig = {
        v: msig.version,
        thr: msig.threshold,
        subsig: subsigs
      };
      const [sig, index] = this.singleSignMultisig(secretKey, this.lmsig);
      this.lmsig.subsig[index].s = sig;
    }
  }
  /**
   * Appends a signature to multi signature
   * @param secretKey - Secret key to sign with
   */
  appendToMultisig(secretKey) {
    if (this.lmsig === void 0) {
      throw new Error("no multisig present");
    }
    const [sig, index] = this.singleSignMultisig(secretKey, this.lmsig);
    this.lmsig.subsig[index].s = sig;
  }
  signProgram(secretKey) {
    const toBeSigned = concatArrays2(programTag, this.logic);
    const sig = sign(toBeSigned, secretKey);
    return sig;
  }
  signProgramMultisig(secretKey, msig) {
    const multisigAddr = addressFromMultisigPreImg({
      version: msig.v,
      threshold: msig.thr,
      pks: msig.subsig.map((subsig) => subsig.pk)
    });
    const toBeSigned = concatArrays2(multisigProgramTag, multisigAddr.publicKey, this.logic);
    const sig = sign(toBeSigned, secretKey);
    return sig;
  }
  singleSignMultisig(secretKey, msig) {
    let index = -1;
    const myPk = keyPairFromSecretKey(secretKey).publicKey;
    for (let i2 = 0; i2 < msig.subsig.length; i2++) {
      const { pk } = msig.subsig[i2];
      if (arrayEqual(pk, myPk)) {
        index = i2;
        break;
      }
    }
    if (index === -1) {
      throw new Error("invalid secret key");
    }
    const sig = this.signProgramMultisig(secretKey, msig);
    return [sig, index];
  }
  toByte() {
    return encodeMsgpack(this);
  }
  static fromByte(encoded) {
    return decodeMsgpack(encoded, _LogicSig);
  }
};
LogicSig.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "l",
    valueSchema: new ByteArraySchema()
  },
  {
    key: "arg",
    valueSchema: new ArraySchema(new ByteArraySchema())
  },
  {
    key: "sig",
    valueSchema: new OptionalSchema(new FixedLengthByteArraySchema(64))
  },
  {
    key: "msig",
    valueSchema: new OptionalSchema(ENCODED_MULTISIG_SCHEMA)
  },
  {
    key: "lmsig",
    valueSchema: new OptionalSchema(ENCODED_MULTISIG_SCHEMA)
  }
]));
var LogicSigAccount = class _LogicSigAccount {
  /**
   * Create a new LogicSigAccount. By default this will create an escrow
   * LogicSig account. Call `sign` or `signMultisig` on the newly created
   * LogicSigAccount to make it a delegated account.
   *
   * @param program - The compiled TEAL program which contains the logic for
   *   this LogicSig.
   * @param args - An optional array of arguments for the program.
   */
  constructor(program, args) {
    this.lsig = new LogicSig(program, args);
    this.sigkey = void 0;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _LogicSigAccount.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["lsig", this.lsig.toEncodingData()],
      ["sigkey", this.sigkey]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded logic sig account: ${data}`);
    }
    const value = data;
    const lsig = LogicSig.fromEncodingData(value.get("lsig"));
    const lsigAccount = new _LogicSigAccount(lsig.logic, lsig.args);
    lsigAccount.lsig = lsig;
    lsigAccount.sigkey = value.get("sigkey");
    return lsigAccount;
  }
  /**
   * Encode this object into msgpack.
   */
  toByte() {
    return encodeMsgpack(this);
  }
  /**
   * Decode a msgpack object into a LogicSigAccount.
   * @param encoded - The encoded LogicSigAccount.
   */
  static fromByte(encoded) {
    return decodeMsgpack(encoded, _LogicSigAccount);
  }
  /**
   * Check if this LogicSigAccount has been delegated to another account with a
   * signature.
   *
   * Note this function only checks for the presence of a delegation signature.
   * To verify the delegation signature, use `verify`.
   */
  isDelegated() {
    return !!(this.lsig.sig || this.lsig.msig || this.lsig.lmsig);
  }
  /**
   * Verifies this LogicSig's program and signatures.
   * @returns true if and only if the LogicSig program and signatures are valid.
   */
  verify() {
    const addr = this.address();
    return this.lsig.verify(addr.publicKey);
  }
  /**
   * Get the address of this LogicSigAccount.
   *
   * If the LogicSig is delegated to another account, this will return the
   * address of that account.
   *
   * If the LogicSig is not delegated to another account, this will return an
   *  escrow address that is the hash of the LogicSig's program code.
   */
  address() {
    const sigCount = [this.lsig.sig, this.lsig.msig, this.lsig.lmsig].filter(Boolean).length;
    if (sigCount > 1) {
      throw new Error("LogicSig has too many signatures. At most one of sig, msig, or lmsig may be present");
    }
    if (this.lsig.sig) {
      if (!this.sigkey) {
        throw new Error("Signing key for delegated account is missing");
      }
      return new Address(this.sigkey);
    }
    const msig = this.lsig.lmsig || this.lsig.msig;
    if (msig) {
      const msigMetadata = {
        version: msig.v,
        threshold: msig.thr,
        pks: msig.subsig.map((subsig) => subsig.pk)
      };
      return addressFromMultisigPreImg(msigMetadata);
    }
    return this.lsig.address();
  }
  /**
   * Turns this LogicSigAccount into a delegated LogicSig. This type of LogicSig
   * has the authority to sign transactions on behalf of another account, called
   * the delegating account. Use this function if the delegating account is a
   * multisig account.
   *
   * @param msig - The multisig delegating account
   * @param secretKey - The secret key of one of the members of the delegating
   *   multisig account. Use `appendToMultisig` to add additional signatures
   *   from other members.
   */
  signMultisig(msig, secretKey) {
    this.lsig.sign(secretKey, msig);
  }
  /**
   * Adds an additional signature from a member of the delegating multisig
   * account.
   *
   * @param secretKey - The secret key of one of the members of the delegating
   *   multisig account.
   */
  appendToMultisig(secretKey) {
    this.lsig.appendToMultisig(secretKey);
  }
  /**
   * Turns this LogicSigAccount into a delegated LogicSig. This type of LogicSig
   * has the authority to sign transactions on behalf of another account, called
   * the delegating account. If the delegating account is a multisig account,
   * use `signMultisig` instead.
   *
   * @param secretKey - The secret key of the delegating account.
   */
  sign(secretKey) {
    this.lsig.sign(secretKey);
    this.sigkey = keyPairFromSecretKey(secretKey).publicKey;
  }
};
LogicSigAccount.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "lsig",
    valueSchema: LogicSig.encodingSchema
  },
  {
    key: "sigkey",
    valueSchema: new OptionalSchema(new FixedLengthByteArraySchema(32))
  }
]));
function logicSigFromByte(encoded) {
  return decodeMsgpack(encoded, LogicSig);
}
var SIGN_PROGRAM_DATA_PREFIX = new TextEncoder().encode("ProgData");
function tealSign(sk, data, programHash) {
  const programAddr = typeof programHash === "string" ? Address.fromString(programHash) : programHash;
  const parts = concatArrays2(programAddr.publicKey, data);
  const toBeSigned = concatArrays2(SIGN_PROGRAM_DATA_PREFIX, parts);
  return sign(toBeSigned, sk);
}
function verifyTealSign(data, programHash, sig, pk) {
  const programAddr = typeof programHash === "string" ? Address.fromString(programHash) : programHash;
  const parts = concatArrays2(programAddr.publicKey, data);
  const toBeSigned = concatArrays2(SIGN_PROGRAM_DATA_PREFIX, parts);
  return verify(toBeSigned, sig, pk);
}
function tealSignFromProgram(sk, data, program) {
  const lsig = new LogicSig(program);
  const contractAddress = lsig.address();
  return tealSign(sk, data, contractAddress);
}

// node_modules/algosdk/dist/esm/signedTransaction.js
var SignedTransaction = class _SignedTransaction {
  constructor({ txn, sig, msig, lsig, sgnr }) {
    this.txn = txn;
    this.sig = sig;
    this.msig = msig;
    this.lsig = lsig;
    this.sgnr = sgnr;
    let numberOfSigs = 0;
    if (sig)
      numberOfSigs += 1;
    if (msig)
      numberOfSigs += 1;
    if (lsig)
      numberOfSigs += 1;
    if (numberOfSigs > 1) {
      throw new Error(`SignedTransaction must not have more than 1 signature. Got ${numberOfSigs}`);
    }
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _SignedTransaction.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["txn", this.txn.toEncodingData()],
      ["sig", this.sig],
      [
        "msig",
        this.msig ? encodedMultiSigToEncodingData(this.msig) : void 0
      ],
      ["lsig", this.lsig ? this.lsig.toEncodingData() : void 0],
      ["sgnr", this.sgnr]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded SignedTransaction: ${data}`);
    }
    return new _SignedTransaction({
      txn: Transaction.fromEncodingData(data.get("txn")),
      sig: data.get("sig"),
      msig: data.get("msig") ? encodedMultiSigFromEncodingData(data.get("msig")) : void 0,
      lsig: data.get("lsig") ? LogicSig.fromEncodingData(data.get("lsig")) : void 0,
      sgnr: data.get("sgnr")
    });
  }
};
SignedTransaction.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "txn",
    valueSchema: Transaction.encodingSchema
  },
  {
    key: "sig",
    valueSchema: new OptionalSchema(new FixedLengthByteArraySchema(64))
  },
  {
    key: "msig",
    valueSchema: new OptionalSchema(ENCODED_MULTISIG_SCHEMA)
  },
  {
    key: "lsig",
    valueSchema: new OptionalSchema(LogicSig.encodingSchema)
  },
  {
    key: "sgnr",
    valueSchema: new OptionalSchema(new AddressSchema())
  }
]));
function decodeSignedTransaction(transactionBuffer) {
  return decodeMsgpack(transactionBuffer, SignedTransaction);
}
function encodeUnsignedSimulateTransaction(txn) {
  const stxn = new SignedTransaction({ txn });
  return encodeMsgpack(stxn);
}

// node_modules/algosdk/dist/esm/types/block.js
var StateProofTrackingData = class _StateProofTrackingData {
  constructor(params) {
    this.stateProofVotersCommitment = params.stateProofVotersCommitment;
    this.stateProofOnlineTotalWeight = params.stateProofOnlineTotalWeight;
    this.stateProofNextRound = params.stateProofNextRound;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _StateProofTrackingData.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["v", this.stateProofVotersCommitment],
      ["t", this.stateProofOnlineTotalWeight],
      ["n", this.stateProofNextRound]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded StateProofTrackingData: ${data}`);
    }
    return new _StateProofTrackingData({
      stateProofVotersCommitment: data.get("v"),
      stateProofOnlineTotalWeight: data.get("t"),
      stateProofNextRound: data.get("n")
    });
  }
};
StateProofTrackingData.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "v",
    // stateProofVotersCommitment
    valueSchema: new ByteArraySchema()
  },
  {
    key: "t",
    // stateProofOnlineTotalWeight
    valueSchema: new Uint64Schema()
  },
  {
    key: "n",
    // stateProofNextRound
    valueSchema: new Uint64Schema()
  }
]));
var TxnCommitments = class _TxnCommitments {
  constructor(params) {
    this.nativeSha512_256Commitment = params.nativeSha512_256Commitment;
    this.sha256Commitment = params.sha256Commitment;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _TxnCommitments.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["txn", this.nativeSha512_256Commitment],
      ["txn256", this.sha256Commitment]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded TxnCommitments: ${data}`);
    }
    return new _TxnCommitments({
      nativeSha512_256Commitment: data.get("txn"),
      sha256Commitment: data.get("txn256")
    });
  }
};
TxnCommitments.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "txn",
    // nativeSha512_256Commitment
    valueSchema: new FixedLengthByteArraySchema(32)
  },
  {
    key: "txn256",
    // sha256Commitment
    valueSchema: new FixedLengthByteArraySchema(32)
  }
]));
var RewardState = class _RewardState {
  constructor(params) {
    this.feeSink = params.feeSink;
    this.rewardsPool = params.rewardsPool;
    this.rewardsLevel = params.rewardsLevel;
    this.rewardsRate = params.rewardsRate;
    this.rewardsResidue = params.rewardsResidue;
    this.rewardsRecalculationRound = params.rewardsRecalculationRound;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _RewardState.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["fees", this.feeSink],
      ["rwd", this.rewardsPool],
      ["earn", this.rewardsLevel],
      ["rate", this.rewardsRate],
      ["frac", this.rewardsResidue],
      ["rwcalr", this.rewardsRecalculationRound]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded RewardState: ${data}`);
    }
    return new _RewardState({
      feeSink: data.get("fees"),
      rewardsPool: data.get("rwd"),
      rewardsLevel: data.get("earn"),
      rewardsRate: data.get("rate"),
      rewardsResidue: data.get("frac"),
      rewardsRecalculationRound: data.get("rwcalr")
    });
  }
};
RewardState.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "fees",
    // feeSink
    valueSchema: new AddressSchema()
  },
  {
    key: "rwd",
    // rewardsPool
    valueSchema: new AddressSchema()
  },
  {
    key: "earn",
    // rewardsLevel
    valueSchema: new Uint64Schema()
  },
  {
    key: "rate",
    // rewardsRate
    valueSchema: new Uint64Schema()
  },
  {
    key: "frac",
    // rewardsResidue
    valueSchema: new Uint64Schema()
  },
  {
    key: "rwcalr",
    // rewardsRecalculationRound
    valueSchema: new Uint64Schema()
  }
]));
var UpgradeState = class _UpgradeState {
  constructor(params) {
    this.currentProtocol = params.currentProtocol;
    this.nextProtocol = params.nextProtocol;
    this.nextProtocolApprovals = params.nextProtocolApprovals;
    this.nextProtocolVoteBefore = params.nextProtocolVoteBefore;
    this.nextProtocolSwitchOn = params.nextProtocolSwitchOn;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _UpgradeState.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["proto", this.currentProtocol],
      ["nextproto", this.nextProtocol],
      ["nextyes", this.nextProtocolApprovals],
      ["nextbefore", this.nextProtocolVoteBefore],
      ["nextswitch", this.nextProtocolSwitchOn]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded UpgradeState: ${data}`);
    }
    return new _UpgradeState({
      currentProtocol: data.get("proto"),
      nextProtocol: data.get("nextproto"),
      nextProtocolApprovals: data.get("nextyes"),
      nextProtocolVoteBefore: data.get("nextbefore"),
      nextProtocolSwitchOn: data.get("nextswitch")
    });
  }
};
UpgradeState.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "proto",
    // currentProtocol
    valueSchema: new StringSchema()
  },
  {
    key: "nextproto",
    // nextProtocol
    valueSchema: new StringSchema()
  },
  {
    key: "nextyes",
    // nextProtocolApprovals
    valueSchema: new Uint64Schema()
  },
  {
    key: "nextbefore",
    // nextProtocolVoteBefore
    valueSchema: new Uint64Schema()
  },
  {
    key: "nextswitch",
    // nextProtocolSwitchOn
    valueSchema: new Uint64Schema()
  }
]));
var UpgradeVote = class _UpgradeVote {
  constructor(params) {
    this.upgradePropose = params.upgradePropose;
    this.upgradeDelay = params.upgradeDelay;
    this.upgradeApprove = params.upgradeApprove;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _UpgradeVote.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["upgradeprop", this.upgradePropose],
      ["upgradedelay", this.upgradeDelay],
      ["upgradeyes", this.upgradeApprove]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded UpgradeVote: ${data}`);
    }
    return new _UpgradeVote({
      upgradePropose: data.get("upgradeprop"),
      upgradeDelay: data.get("upgradedelay"),
      upgradeApprove: data.get("upgradeyes")
    });
  }
};
UpgradeVote.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "upgradeprop",
    // upgradePropose
    valueSchema: new StringSchema()
  },
  {
    key: "upgradedelay",
    // upgradeDelay
    valueSchema: new Uint64Schema()
  },
  {
    key: "upgradeyes",
    // upgradeApprove
    valueSchema: new BooleanSchema()
  }
]));
var ParticipationUpdates = class _ParticipationUpdates {
  constructor(params) {
    this.expiredParticipationAccounts = params.expiredParticipationAccounts;
    this.absentParticipationAccounts = params.absentParticipationAccounts;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _ParticipationUpdates.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["partupdrmv", this.expiredParticipationAccounts],
      ["partupdabs", this.absentParticipationAccounts]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded ParticipationUpdates: ${data}`);
    }
    return new _ParticipationUpdates({
      expiredParticipationAccounts: data.get("partupdrmv"),
      absentParticipationAccounts: data.get("partupdabs")
    });
  }
};
ParticipationUpdates.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "partupdrmv",
    // expiredParticipationAccounts
    valueSchema: new ArraySchema(new AddressSchema())
  },
  {
    key: "partupdabs",
    // absentParticipationAccounts
    valueSchema: new ArraySchema(new AddressSchema())
  }
]));
var BlockHeader = class _BlockHeader {
  constructor(params) {
    this.round = params.round;
    this.branch = params.branch;
    this.seed = params.seed;
    this.txnCommitments = params.txnCommitments;
    this.timestamp = params.timestamp;
    this.genesisID = params.genesisID;
    this.genesisHash = params.genesisHash;
    this.proposer = params.proposer;
    this.feesCollected = params.feesCollected;
    this.bonus = params.bonus;
    this.proposerPayout = params.proposerPayout;
    this.rewardState = params.rewardState;
    this.upgradeState = params.upgradeState;
    this.upgradeVote = params.upgradeVote;
    this.txnCounter = params.txnCounter;
    this.stateproofTracking = params.stateproofTracking;
    this.participationUpdates = params.participationUpdates;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _BlockHeader.encodingSchema;
  }
  toEncodingData() {
    const data = /* @__PURE__ */ new Map([
      ["rnd", this.round],
      ["prev", this.branch],
      ["seed", this.seed],
      ["ts", this.timestamp],
      ["gen", this.genesisID],
      ["gh", this.genesisHash],
      ["prp", this.proposer],
      ["fc", this.feesCollected],
      ["bi", this.bonus],
      ["pp", this.proposerPayout],
      ["tc", this.txnCounter],
      [
        "spt",
        convertMap(this.stateproofTracking, (key, value) => [
          key,
          value.toEncodingData()
        ])
      ]
    ]);
    return combineMaps(data, this.txnCommitments.toEncodingData(), this.rewardState.toEncodingData(), this.upgradeState.toEncodingData(), this.upgradeVote.toEncodingData(), this.participationUpdates.toEncodingData());
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded BlockHeader: ${data}`);
    }
    return new _BlockHeader({
      round: data.get("rnd"),
      branch: data.get("prev"),
      seed: data.get("seed"),
      txnCommitments: TxnCommitments.fromEncodingData(data),
      timestamp: data.get("ts"),
      genesisID: data.get("gen"),
      genesisHash: data.get("gh"),
      proposer: data.get("prp"),
      feesCollected: data.get("fc"),
      bonus: data.get("bi"),
      proposerPayout: data.get("pp"),
      rewardState: RewardState.fromEncodingData(data),
      upgradeState: UpgradeState.fromEncodingData(data),
      upgradeVote: UpgradeVote.fromEncodingData(data),
      txnCounter: data.get("tc"),
      stateproofTracking: convertMap(data.get("spt"), (key, value) => [
        Number(key),
        StateProofTrackingData.fromEncodingData(value)
      ]),
      participationUpdates: ParticipationUpdates.fromEncodingData(data)
    });
  }
};
BlockHeader.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "rnd",
    // round
    valueSchema: new Uint64Schema()
  },
  {
    key: "prev",
    // branch
    valueSchema: new BlockHashSchema()
  },
  {
    key: "seed",
    // seed
    valueSchema: new ByteArraySchema()
  },
  {
    key: "",
    valueSchema: TxnCommitments.encodingSchema,
    embedded: true
  },
  {
    key: "ts",
    // timestamp
    valueSchema: new Uint64Schema()
  },
  {
    key: "gen",
    // genesisID
    valueSchema: new StringSchema()
  },
  {
    key: "gh",
    // genesisHash
    valueSchema: new FixedLengthByteArraySchema(32)
  },
  {
    key: "prp",
    // proposer
    valueSchema: new AddressSchema()
  },
  {
    key: "fc",
    // feesCollected
    valueSchema: new Uint64Schema()
  },
  {
    key: "bi",
    // bonus
    valueSchema: new Uint64Schema()
  },
  {
    key: "pp",
    // proposerPayout
    valueSchema: new Uint64Schema()
  },
  {
    key: "",
    valueSchema: RewardState.encodingSchema,
    embedded: true
  },
  {
    key: "",
    valueSchema: UpgradeState.encodingSchema,
    embedded: true
  },
  {
    key: "",
    valueSchema: UpgradeVote.encodingSchema,
    embedded: true
  },
  {
    key: "tc",
    // txnCounter
    valueSchema: new Uint64Schema()
  },
  {
    key: "spt",
    // stateproofTracking
    valueSchema: new Uint64MapSchema(StateProofTrackingData.encodingSchema)
  },
  {
    key: "",
    valueSchema: ParticipationUpdates.encodingSchema,
    embedded: true
  }
]));
var ValueDelta = class _ValueDelta {
  constructor(params) {
    this.action = params.action;
    this.bytes = params.bytes;
    this.uint = params.uint;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _ValueDelta.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["at", this.action],
      ["bs", this.bytes],
      ["ui", this.uint]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded ValueDelta: ${data}`);
    }
    return new _ValueDelta({
      action: Number(data.get("at")),
      bytes: data.get("bs"),
      uint: data.get("ui")
    });
  }
};
ValueDelta.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "at",
    // action
    valueSchema: new Uint64Schema()
  },
  {
    key: "bs",
    // bytes
    valueSchema: new SpecialCaseBinaryStringSchema()
  },
  {
    key: "ui",
    // uint
    valueSchema: new Uint64Schema()
  }
]));
var EvalDelta = class _EvalDelta {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries(...allOmitEmpty([
        {
          key: "gd",
          // globalDelta
          valueSchema: new OptionalSchema(new SpecialCaseBinaryStringMapSchema(ValueDelta.encodingSchema))
        },
        {
          key: "ld",
          // localDeltas
          valueSchema: new OptionalSchema(new Uint64MapSchema(new SpecialCaseBinaryStringMapSchema(ValueDelta.encodingSchema)))
        },
        {
          key: "sa",
          // sharedAccts
          valueSchema: new OptionalSchema(new ArraySchema(new AddressSchema()))
        },
        {
          key: "lg",
          // logs
          valueSchema: new OptionalSchema(new ArraySchema(new SpecialCaseBinaryStringSchema()))
        },
        {
          key: "itx",
          // innerTxns
          valueSchema: new OptionalSchema(
            // eslint-disable-next-line no-use-before-define
            new ArraySchema(SignedTxnWithAD.encodingSchema)
          )
        }
      ]));
    }
    return this.encodingSchemaValue;
  }
  constructor(params) {
    this.globalDelta = params.globalDelta ?? /* @__PURE__ */ new Map();
    this.localDeltas = params.localDeltas ?? /* @__PURE__ */ new Map();
    this.sharedAccts = params.sharedAccts ?? [];
    this.logs = params.logs ?? [];
    this.innerTxns = params.innerTxns ?? [];
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _EvalDelta.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      [
        "gd",
        convertMap(this.globalDelta, (key, value) => [
          key,
          value.toEncodingData()
        ])
      ],
      [
        "ld",
        convertMap(this.localDeltas, (key, value) => [
          key,
          convertMap(value, (k2, v2) => [k2, v2.toEncodingData()])
        ])
      ],
      ["sa", this.sharedAccts],
      ["lg", this.logs],
      ["itx", this.innerTxns.map((t) => t.toEncodingData())]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded EvalDelta: ${data}`);
    }
    return new _EvalDelta({
      globalDelta: data.get("gd") ? convertMap(data.get("gd"), (key, value) => [key, ValueDelta.fromEncodingData(value)]) : void 0,
      localDeltas: data.get("ld") ? convertMap(data.get("ld"), (key, value) => [
        Number(key),
        convertMap(value, (k2, v2) => [k2, ValueDelta.fromEncodingData(v2)])
      ]) : void 0,
      sharedAccts: data.get("sa"),
      logs: data.get("lg"),
      // eslint-disable-next-line no-use-before-define
      innerTxns: (data.get("itx") ?? []).map(SignedTxnWithAD.fromEncodingData)
    });
  }
};
var ApplyData = class _ApplyData {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries(...allOmitEmpty([
        {
          key: "ca",
          // closingAmount
          valueSchema: new OptionalSchema(new Uint64Schema())
        },
        {
          key: "aca",
          // assetClosingAmount
          valueSchema: new OptionalSchema(new Uint64Schema())
        },
        {
          key: "rs",
          // senderRewards
          valueSchema: new OptionalSchema(new Uint64Schema())
        },
        {
          key: "rr",
          // receiverRewards
          valueSchema: new OptionalSchema(new Uint64Schema())
        },
        {
          key: "rc",
          // closeRewards
          valueSchema: new OptionalSchema(new Uint64Schema())
        },
        {
          key: "dt",
          // evalDelta
          valueSchema: new OptionalSchema(EvalDelta.encodingSchema)
        },
        {
          key: "caid",
          // configAsset
          valueSchema: new OptionalSchema(new Uint64Schema())
        },
        {
          key: "apid",
          // applicationID
          valueSchema: new OptionalSchema(new Uint64Schema())
        }
      ]));
    }
    return this.encodingSchemaValue;
  }
  constructor(params) {
    this.closingAmount = params.closingAmount;
    this.assetClosingAmount = params.assetClosingAmount;
    this.senderRewards = params.senderRewards;
    this.receiverRewards = params.receiverRewards;
    this.closeRewards = params.closeRewards;
    this.evalDelta = params.evalDelta;
    this.configAsset = params.configAsset;
    this.applicationID = params.applicationID;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _ApplyData.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["ca", this.closingAmount],
      ["aca", this.assetClosingAmount],
      ["rs", this.senderRewards],
      ["rr", this.receiverRewards],
      ["rc", this.closeRewards],
      ["dt", this.evalDelta ? this.evalDelta.toEncodingData() : void 0],
      ["caid", this.configAsset],
      ["apid", this.applicationID]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded ApplyData: ${data}`);
    }
    return new _ApplyData({
      closingAmount: data.get("ca"),
      assetClosingAmount: data.get("aca"),
      senderRewards: data.get("rs"),
      receiverRewards: data.get("rr"),
      closeRewards: data.get("rc"),
      evalDelta: data.get("dt") ? EvalDelta.fromEncodingData(data.get("dt")) : void 0,
      configAsset: data.get("caid"),
      applicationID: data.get("apid")
    });
  }
};
var SignedTxnWithAD = class _SignedTxnWithAD {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries(...allOmitEmpty([
        {
          key: "",
          valueSchema: SignedTransaction.encodingSchema,
          embedded: true
        },
        {
          key: "",
          valueSchema: ApplyData.encodingSchema,
          embedded: true
        }
      ]));
    }
    return this.encodingSchemaValue;
  }
  constructor(params) {
    this.signedTxn = params.signedTxn;
    this.applyData = params.applyData;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _SignedTxnWithAD.encodingSchema;
  }
  toEncodingData() {
    return combineMaps(this.signedTxn.toEncodingData(), this.applyData.toEncodingData());
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded SignedTxnWithAD: ${data}`);
    }
    return new _SignedTxnWithAD({
      signedTxn: SignedTransaction.fromEncodingData(data),
      applyData: ApplyData.fromEncodingData(data)
    });
  }
};
var SignedTxnInBlock = class _SignedTxnInBlock {
  constructor(params) {
    this.signedTxn = params.signedTxn;
    this.hasGenesisID = params.hasGenesisID;
    this.hasGenesisHash = params.hasGenesisHash;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _SignedTxnInBlock.encodingSchema;
  }
  toEncodingData() {
    const data = /* @__PURE__ */ new Map([
      ["hgi", this.hasGenesisID],
      ["hgh", this.hasGenesisHash]
    ]);
    return combineMaps(data, this.signedTxn.toEncodingData());
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded SignedTxnInBlock: ${data}`);
    }
    return new _SignedTxnInBlock({
      signedTxn: SignedTxnWithAD.fromEncodingData(data),
      hasGenesisID: data.get("hgi"),
      hasGenesisHash: data.get("hgh")
    });
  }
};
SignedTxnInBlock.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "",
    valueSchema: SignedTxnWithAD.encodingSchema,
    embedded: true
  },
  {
    key: "hgi",
    // hasGenesisID
    valueSchema: new BooleanSchema()
  },
  {
    key: "hgh",
    // hasGenesisHash
    valueSchema: new BooleanSchema()
  }
]));
var Block = class _Block {
  constructor(params) {
    this.header = params.header;
    this.payset = params.payset;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _Block.encodingSchema;
  }
  toEncodingData() {
    const data = /* @__PURE__ */ new Map([
      ["txns", this.payset.map((p2) => p2.toEncodingData())]
    ]);
    return combineMaps(data, this.header.toEncodingData());
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded BlockHeader: ${data}`);
    }
    return new _Block({
      header: BlockHeader.fromEncodingData(data),
      payset: data.get("txns").map(SignedTxnInBlock.fromEncodingData)
    });
  }
};
Block.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "",
    valueSchema: BlockHeader.encodingSchema,
    embedded: true
  },
  {
    key: "txns",
    // payset
    valueSchema: new ArraySchema(SignedTxnInBlock.encodingSchema)
  }
]));

// node_modules/algosdk/dist/esm/client/v2/untypedmodel.js
var UntypedValue = class _UntypedValue {
  constructor(data) {
    this.data = data;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _UntypedValue.encodingSchema;
  }
  toEncodingData() {
    return this.data;
  }
  static fromEncodingData(data) {
    return new _UntypedValue(data);
  }
};
UntypedValue.encodingSchema = new UntypedSchema();

// node_modules/algosdk/dist/esm/types/statedelta.js
var TealValue = class _TealValue {
  constructor(params) {
    this.type = params.type;
    this.bytes = params.bytes;
    this.uint = params.uint;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _TealValue.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["tt", this.type],
      ["tb", this.bytes],
      ["ui", this.uint]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded TealValue: ${data}`);
    }
    return new _TealValue({
      type: Number(data.get("tt")),
      bytes: data.get("tb"),
      uint: data.get("ui")
    });
  }
};
TealValue.encodingSchema = new NamedMapSchema(allOmitEmpty([
  { key: "tt", valueSchema: new Uint64Schema() },
  // type
  {
    key: "tb",
    // bytes
    valueSchema: new OptionalSchema(new SpecialCaseBinaryStringSchema())
  },
  { key: "ui", valueSchema: new OptionalSchema(new Uint64Schema()) }
  // uint
]));
var StateSchema = class _StateSchema {
  constructor(params) {
    this.numUints = params.numUints;
    this.numByteSlices = params.numByteSlices;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _StateSchema.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["nui", this.numUints],
      ["nbs", this.numByteSlices]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded StateSchema: ${data}`);
    }
    return new _StateSchema({
      numUints: Number(data.get("nui")),
      numByteSlices: Number(data.get("nbs"))
    });
  }
};
StateSchema.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "nui",
    // numUints
    valueSchema: new Uint64Schema()
  },
  {
    key: "nbs",
    // numByteSlices
    valueSchema: new Uint64Schema()
  }
]));
var AppParams = class _AppParams {
  constructor(params) {
    this.approvalProgram = params.approvalProgram;
    this.clearStateProgram = params.clearStateProgram;
    this.globalState = params.globalState;
    this.localStateSchema = params.localStateSchema;
    this.globalStateSchema = params.globalStateSchema;
    this.extraProgramPages = params.extraProgramPages;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AppParams.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["approv", this.approvalProgram],
      ["clearp", this.clearStateProgram],
      ["gs", convertMap(this.globalState, (k2, v2) => [k2, v2.toEncodingData()])],
      ["lsch", this.localStateSchema.toEncodingData()],
      ["gsch", this.globalStateSchema.toEncodingData()],
      ["epp", this.extraProgramPages]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AppParams: ${data}`);
    }
    return new _AppParams({
      approvalProgram: data.get("approv"),
      clearStateProgram: data.get("clearp"),
      globalState: convertMap(data.get("gs"), (k2, v2) => [k2, TealValue.fromEncodingData(v2)]),
      localStateSchema: StateSchema.fromEncodingData(data.get("lsch")),
      globalStateSchema: StateSchema.fromEncodingData(data.get("gsch")),
      extraProgramPages: Number(data.get("epp"))
    });
  }
};
AppParams.encodingSchema = new NamedMapSchema(allOmitEmpty([
  { key: "approv", valueSchema: new ByteArraySchema() },
  // approvalProgram
  { key: "clearp", valueSchema: new ByteArraySchema() },
  // alearStateProgram
  {
    key: "gs",
    valueSchema: new SpecialCaseBinaryStringMapSchema(TealValue.encodingSchema)
  },
  // globalState
  { key: "lsch", valueSchema: StateSchema.encodingSchema },
  // localStateSchema
  { key: "gsch", valueSchema: StateSchema.encodingSchema },
  // globalStateSchema
  { key: "epp", valueSchema: new Uint64Schema() }
  // extraProgramPages
]));
var AppLocalState = class _AppLocalState {
  constructor(params) {
    this.schema = params.schema;
    this.keyValue = params.keyValue;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AppLocalState.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["hsch", this.schema.toEncodingData()],
      ["tkv", convertMap(this.keyValue, (k2, v2) => [k2, v2.toEncodingData()])]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AppLocalState: ${data}`);
    }
    return new _AppLocalState({
      schema: StateSchema.fromEncodingData(data.get("hsch")),
      keyValue: convertMap(data.get("tkv"), (k2, v2) => [k2, TealValue.fromEncodingData(v2)])
    });
  }
};
AppLocalState.encodingSchema = new NamedMapSchema(allOmitEmpty([
  { key: "hsch", valueSchema: StateSchema.encodingSchema },
  // schema
  {
    key: "tkv",
    // keyValue
    valueSchema: new SpecialCaseBinaryStringMapSchema(TealValue.encodingSchema)
  }
]));
var AppLocalStateDelta = class _AppLocalStateDelta {
  constructor(params) {
    this.localState = params.localState;
    this.deleted = params.deleted;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AppLocalStateDelta.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      [
        "LocalState",
        this.localState ? this.localState.toEncodingData() : void 0
      ],
      ["Deleted", this.deleted]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AppLocalStateDelta: ${data}`);
    }
    return new _AppLocalStateDelta({
      localState: data.get("LocalState") ? AppLocalState.fromEncodingData(data.get("LocalState")) : void 0,
      deleted: data.get("Deleted")
    });
  }
};
AppLocalStateDelta.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "LocalState",
    // localState
    valueSchema: new OptionalSchema(AppLocalState.encodingSchema)
  },
  { key: "Deleted", valueSchema: new BooleanSchema() }
  // deleted
]));
var AppParamsDelta = class _AppParamsDelta {
  constructor(params) {
    this.params = params.params;
    this.deleted = params.deleted;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AppParamsDelta.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["Params", this.params ? this.params.toEncodingData() : void 0],
      ["Deleted", this.deleted]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AppParamsDelta: ${data}`);
    }
    return new _AppParamsDelta({
      params: data.get("Params") ? AppParams.fromEncodingData(data.get("Params")) : void 0,
      deleted: data.get("Deleted")
    });
  }
};
AppParamsDelta.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "Params",
    // params
    valueSchema: new OptionalSchema(AppParams.encodingSchema)
  },
  { key: "Deleted", valueSchema: new BooleanSchema() }
  // deleted
]));
var AppResourceRecord = class _AppResourceRecord {
  constructor(params) {
    this.id = params.id;
    this.address = params.address;
    this.params = params.params;
    this.state = params.state;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AppResourceRecord.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["Aidx", this.id],
      ["Addr", this.address],
      ["Params", this.params.toEncodingData()],
      ["State", this.state.toEncodingData()]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AppResourceRecord: ${data}`);
    }
    return new _AppResourceRecord({
      id: data.get("Aidx"),
      address: data.get("Addr"),
      params: AppParamsDelta.fromEncodingData(data.get("Params")),
      state: AppLocalStateDelta.fromEncodingData(data.get("State"))
    });
  }
};
AppResourceRecord.encodingSchema = new NamedMapSchema(allOmitEmpty([
  { key: "Aidx", valueSchema: new Uint64Schema() },
  // id
  { key: "Addr", valueSchema: new AddressSchema() },
  // address
  {
    key: "Params",
    // params
    valueSchema: AppParamsDelta.encodingSchema
  },
  {
    key: "State",
    // state
    valueSchema: AppLocalStateDelta.encodingSchema
  }
]));
var AssetHolding = class _AssetHolding {
  constructor(params) {
    this.amount = params.amount;
    this.frozen = params.frozen;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AssetHolding.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["a", this.amount],
      ["f", this.frozen]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AssetHolding: ${data}`);
    }
    return new _AssetHolding({
      amount: data.get("a"),
      frozen: data.get("f")
    });
  }
};
AssetHolding.encodingSchema = new NamedMapSchema(allOmitEmpty([
  { key: "a", valueSchema: new Uint64Schema() },
  // amount
  { key: "f", valueSchema: new BooleanSchema() }
  // frozen
]));
var AssetHoldingDelta = class _AssetHoldingDelta {
  constructor(params) {
    this.holding = params.holding;
    this.deleted = params.deleted;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AssetHoldingDelta.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["Holding", this.holding ? this.holding.toEncodingData() : void 0],
      ["Deleted", this.deleted]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AssetHoldingDelta: ${data}`);
    }
    return new _AssetHoldingDelta({
      holding: data.get("Holding") ? AssetHolding.fromEncodingData(data.get("Holding")) : void 0,
      deleted: data.get("Deleted")
    });
  }
};
AssetHoldingDelta.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "Holding",
    // holding
    valueSchema: new OptionalSchema(AssetHolding.encodingSchema)
  },
  { key: "Deleted", valueSchema: new BooleanSchema() }
  // deleted
]));
var AssetParams = class _AssetParams {
  constructor(params) {
    this.total = params.total;
    this.decimals = params.decimals;
    this.defaultFrozen = params.defaultFrozen;
    this.unitName = params.unitName;
    this.assetName = params.assetName;
    this.url = params.url;
    this.metadataHash = params.metadataHash;
    this.manager = params.manager;
    this.reserve = params.reserve;
    this.freeze = params.freeze;
    this.clawback = params.clawback;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AssetParams.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["t", this.total],
      ["dc", this.decimals],
      ["df", this.defaultFrozen],
      ["un", this.unitName],
      ["an", this.assetName],
      ["au", this.url],
      ["am", this.metadataHash],
      ["m", this.manager],
      ["r", this.reserve],
      ["f", this.freeze],
      ["c", this.clawback]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AssetParams: ${data}`);
    }
    return new _AssetParams({
      total: data.get("t"),
      decimals: data.get("dc"),
      defaultFrozen: data.get("df"),
      unitName: data.get("un"),
      assetName: data.get("an"),
      url: data.get("au"),
      metadataHash: data.get("am"),
      manager: data.get("m"),
      reserve: data.get("r"),
      freeze: data.get("f"),
      clawback: data.get("c")
    });
  }
};
AssetParams.encodingSchema = new NamedMapSchema(allOmitEmpty([
  { key: "t", valueSchema: new Uint64Schema() },
  // total
  { key: "dc", valueSchema: new Uint64Schema() },
  // decimals
  { key: "df", valueSchema: new BooleanSchema() },
  // defaultFrozen
  {
    key: "un",
    // unitName
    valueSchema: new OptionalSchema(new SpecialCaseBinaryStringSchema())
  },
  {
    key: "an",
    // assetName
    valueSchema: new OptionalSchema(new SpecialCaseBinaryStringSchema())
  },
  {
    key: "au",
    // url
    valueSchema: new OptionalSchema(new SpecialCaseBinaryStringSchema())
  },
  { key: "am", valueSchema: new FixedLengthByteArraySchema(32) },
  // metadataHash
  { key: "m", valueSchema: new OptionalSchema(new AddressSchema()) },
  // manager
  { key: "r", valueSchema: new OptionalSchema(new AddressSchema()) },
  // reserve
  { key: "f", valueSchema: new OptionalSchema(new AddressSchema()) },
  // freeze
  { key: "c", valueSchema: new OptionalSchema(new AddressSchema()) }
  // clawback
]));
var AssetParamsDelta = class _AssetParamsDelta {
  constructor(params) {
    this.params = params.params;
    this.deleted = params.deleted;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AssetParamsDelta.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["Params", this.params ? this.params.toEncodingData() : void 0],
      ["Deleted", this.deleted]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AssetParamsDelta: ${data}`);
    }
    return new _AssetParamsDelta({
      params: data.get("Params") ? AssetParams.fromEncodingData(data.get("Params")) : void 0,
      deleted: data.get("Deleted")
    });
  }
};
AssetParamsDelta.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "Params",
    // params
    valueSchema: new OptionalSchema(AssetParams.encodingSchema)
  },
  { key: "Deleted", valueSchema: new BooleanSchema() }
  // deleted
]));
var AssetResourceRecord = class _AssetResourceRecord {
  constructor(params) {
    this.id = params.id;
    this.address = params.address;
    this.params = params.params;
    this.holding = params.holding;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AssetResourceRecord.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["Aidx", this.id],
      ["Addr", this.address],
      ["Params", this.params.toEncodingData()],
      ["Holding", this.holding.toEncodingData()]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AssetResourceRecord: ${data}`);
    }
    return new _AssetResourceRecord({
      id: data.get("Aidx"),
      address: data.get("Addr"),
      params: AssetParamsDelta.fromEncodingData(data.get("Params")),
      holding: AssetHoldingDelta.fromEncodingData(data.get("Holding"))
    });
  }
};
AssetResourceRecord.encodingSchema = new NamedMapSchema(allOmitEmpty([
  { key: "Aidx", valueSchema: new Uint64Schema() },
  // id
  { key: "Addr", valueSchema: new AddressSchema() },
  // address
  {
    key: "Params",
    // params
    valueSchema: AssetParamsDelta.encodingSchema
  },
  {
    key: "Holding",
    // holding
    valueSchema: AssetHoldingDelta.encodingSchema
  }
]));
var VotingData = class _VotingData {
  constructor(params) {
    this.voteID = params.voteID;
    this.selectionID = params.selectionID;
    this.stateProofID = params.stateProofID;
    this.voteFirstValid = params.voteFirstValid;
    this.voteLastValid = params.voteLastValid;
    this.voteKeyDilution = params.voteKeyDilution;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _VotingData.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["VoteID", this.voteID],
      ["SelectionID", this.selectionID],
      ["StateProofID", this.stateProofID],
      ["VoteFirstValid", this.voteFirstValid],
      ["VoteLastValid", this.voteLastValid],
      ["VoteKeyDilution", this.voteKeyDilution]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded VotingData: ${data}`);
    }
    return new _VotingData({
      voteID: data.get("VoteID"),
      selectionID: data.get("SelectionID"),
      stateProofID: data.get("StateProofID"),
      voteFirstValid: data.get("VoteFirstValid"),
      voteLastValid: data.get("VoteLastValid"),
      voteKeyDilution: data.get("VoteKeyDilution")
    });
  }
};
VotingData.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "VoteID",
    // voteID
    valueSchema: new FixedLengthByteArraySchema(32)
  },
  {
    key: "SelectionID",
    // selectionID
    valueSchema: new FixedLengthByteArraySchema(32)
  },
  {
    key: "StateProofID",
    // stateProofID
    valueSchema: new FixedLengthByteArraySchema(64)
  },
  {
    key: "VoteFirstValid",
    // voteFirstValid
    valueSchema: new Uint64Schema()
  },
  {
    key: "VoteLastValid",
    // voteLastValid
    valueSchema: new Uint64Schema()
  },
  {
    key: "VoteKeyDilution",
    // voteKeyDilution
    valueSchema: new Uint64Schema()
  }
]));
var AccountBaseData = class _AccountBaseData {
  constructor(params) {
    this.status = params.status;
    this.microAlgos = params.microAlgos;
    this.rewardsBase = params.rewardsBase;
    this.rewardedMicroAlgos = params.rewardedMicroAlgos;
    this.authAddr = params.authAddr;
    this.incentiveEligible = params.incentiveEligible;
    this.totalAppSchema = params.totalAppSchema;
    this.totalExtraAppPages = params.totalExtraAppPages;
    this.totalAppParams = params.totalAppParams;
    this.totalAppLocalStates = params.totalAppLocalStates;
    this.totalAssetParams = params.totalAssetParams;
    this.totalAssets = params.totalAssets;
    this.totalBoxes = params.totalBoxes;
    this.totalBoxBytes = params.totalBoxBytes;
    this.lastProposed = params.lastProposed;
    this.lastHeartbeat = params.lastHeartbeat;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AccountBaseData.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["Status", this.status],
      ["MicroAlgos", this.microAlgos],
      ["RewardsBase", this.rewardsBase],
      ["RewardedMicroAlgos", this.rewardedMicroAlgos],
      ["AuthAddr", this.authAddr],
      ["IncentiveEligible", this.incentiveEligible],
      ["TotalAppSchema", this.totalAppSchema.toEncodingData()],
      ["TotalExtraAppPages", this.totalExtraAppPages],
      ["TotalAppParams", this.totalAppParams],
      ["TotalAppLocalStates", this.totalAppLocalStates],
      ["TotalAssetParams", this.totalAssetParams],
      ["TotalAssets", this.totalAssets],
      ["TotalBoxes", this.totalBoxes],
      ["TotalBoxBytes", this.totalBoxBytes],
      ["LastProposed", this.lastProposed],
      ["LastHeartbeat", this.lastHeartbeat]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AccountBaseData: ${data}`);
    }
    return new _AccountBaseData({
      status: Number(data.get("Status")),
      microAlgos: data.get("MicroAlgos"),
      rewardsBase: data.get("RewardsBase"),
      rewardedMicroAlgos: data.get("RewardedMicroAlgos"),
      authAddr: data.get("AuthAddr"),
      incentiveEligible: data.get("IncentiveEligible"),
      totalAppSchema: StateSchema.fromEncodingData(data.get("TotalAppSchema")),
      totalExtraAppPages: Number(data.get("TotalExtraAppPages")),
      totalAppParams: data.get("TotalAppParams"),
      totalAppLocalStates: data.get("TotalAppLocalStates"),
      totalAssetParams: data.get("TotalAssetParams"),
      totalAssets: data.get("TotalAssets"),
      totalBoxes: data.get("TotalBoxes"),
      totalBoxBytes: data.get("TotalBoxBytes"),
      lastProposed: data.get("LastProposed"),
      lastHeartbeat: data.get("LastHeartbeat")
    });
  }
};
AccountBaseData.encodingSchema = new NamedMapSchema(allOmitEmpty([
  { key: "Status", valueSchema: new Uint64Schema() },
  // status
  { key: "MicroAlgos", valueSchema: new Uint64Schema() },
  // microAlgos
  { key: "RewardsBase", valueSchema: new Uint64Schema() },
  // rewardsBase
  {
    key: "RewardedMicroAlgos",
    // rewardedMicroAlgos
    valueSchema: new Uint64Schema()
  },
  { key: "AuthAddr", valueSchema: new AddressSchema() },
  // authAddr
  {
    key: "IncentiveEligible",
    // incentiveEligible
    valueSchema: new BooleanSchema()
  },
  {
    key: "TotalAppSchema",
    // totalAppSchema
    valueSchema: StateSchema.encodingSchema
  },
  {
    key: "TotalExtraAppPages",
    // totalExtraAppPages
    valueSchema: new Uint64Schema()
  },
  {
    key: "TotalAppParams",
    // totalAppParams
    valueSchema: new Uint64Schema()
  },
  {
    key: "TotalAppLocalStates",
    // totalAppLocalStates
    valueSchema: new Uint64Schema()
  },
  {
    key: "TotalAssetParams",
    // totalAssetParams
    valueSchema: new Uint64Schema()
  },
  { key: "TotalAssets", valueSchema: new Uint64Schema() },
  // totalAssets
  { key: "TotalBoxes", valueSchema: new Uint64Schema() },
  // totalBoxes
  {
    key: "TotalBoxBytes",
    // totalBoxBytes
    valueSchema: new Uint64Schema()
  },
  { key: "LastProposed", valueSchema: new Uint64Schema() },
  // lastProposed
  {
    key: "LastHeartbeat",
    // lastHeartbeat
    valueSchema: new Uint64Schema()
  }
]));
var AccountData = class _AccountData {
  constructor(params) {
    this.accountBaseData = params.accountBaseData;
    this.votingData = params.votingData;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AccountData.encodingSchema;
  }
  toEncodingData() {
    return combineMaps(this.accountBaseData.toEncodingData(), this.votingData.toEncodingData());
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AccountData: ${data}`);
    }
    return new _AccountData({
      accountBaseData: AccountBaseData.fromEncodingData(data),
      votingData: VotingData.fromEncodingData(data)
    });
  }
};
AccountData.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "",
    valueSchema: AccountBaseData.encodingSchema,
    embedded: true
  },
  {
    key: "",
    valueSchema: VotingData.encodingSchema,
    embedded: true
  }
]));
var BalanceRecord = class _BalanceRecord {
  constructor(params) {
    this.addr = params.addr;
    this.accountData = params.accountData;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _BalanceRecord.encodingSchema;
  }
  toEncodingData() {
    return combineMaps(/* @__PURE__ */ new Map([["Addr", this.addr]]), this.accountData.toEncodingData());
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded BalanceRecord: ${data}`);
    }
    return new _BalanceRecord({
      addr: data.get("Addr"),
      accountData: AccountData.fromEncodingData(data)
    });
  }
};
BalanceRecord.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "Addr",
    valueSchema: new AddressSchema()
  },
  {
    key: "",
    valueSchema: AccountData.encodingSchema,
    embedded: true
  }
]));
var AccountDeltas = class _AccountDeltas {
  constructor(params) {
    this.accounts = params.accounts;
    this.appResources = params.appResources;
    this.assetResources = params.assetResources;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AccountDeltas.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["Accts", this.accounts.map((account) => account.toEncodingData())],
      [
        "AppResources",
        this.appResources.length === 0 ? void 0 : this.appResources.map((appResource) => appResource.toEncodingData())
      ],
      [
        "AssetResources",
        this.assetResources.length === 0 ? void 0 : this.assetResources.map((assetResource) => assetResource.toEncodingData())
      ]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AccountDeltas: ${data}`);
    }
    return new _AccountDeltas({
      accounts: (data.get("Accts") ?? []).map(BalanceRecord.fromEncodingData),
      appResources: (data.get("AppResources") ?? []).map(AppResourceRecord.fromEncodingData),
      assetResources: (data.get("AssetResources") ?? []).map(AssetResourceRecord.fromEncodingData)
    });
  }
};
AccountDeltas.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "Accts",
    // accounts
    valueSchema: new ArraySchema(BalanceRecord.encodingSchema)
  },
  {
    key: "AppResources",
    // appResources
    valueSchema: new OptionalSchema(new ArraySchema(AppResourceRecord.encodingSchema))
  },
  {
    key: "AssetResources",
    // assetResources
    valueSchema: new OptionalSchema(new ArraySchema(AssetResourceRecord.encodingSchema))
  }
]));
var KvValueDelta = class _KvValueDelta {
  constructor(params) {
    this.data = params.data;
    this.oldData = params.oldData;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _KvValueDelta.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["Data", this.data],
      ["OldData", this.oldData]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded KvValueDelta: ${data}`);
    }
    return new _KvValueDelta({
      data: data.get("Data"),
      oldData: data.get("OldData")
    });
  }
};
KvValueDelta.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "Data",
    valueSchema: new OptionalSchema(new ByteArraySchema())
  },
  {
    key: "OldData",
    valueSchema: new OptionalSchema(new ByteArraySchema())
  }
]));
var IncludedTransactions = class _IncludedTransactions {
  constructor(params) {
    this.lastValid = params.lastValid;
    this.intra = params.intra;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _IncludedTransactions.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["LastValid", this.lastValid],
      ["Intra", this.intra]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded IncludedTransactions: ${data}`);
    }
    return new _IncludedTransactions({
      lastValid: data.get("LastValid"),
      intra: Number(data.get("Intra"))
    });
  }
};
IncludedTransactions.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "LastValid",
    valueSchema: new Uint64Schema()
  },
  {
    key: "Intra",
    valueSchema: new Uint64Schema()
  }
]));
var ModifiedCreatable = class _ModifiedCreatable {
  constructor(params) {
    this.creatableType = params.creatableType;
    this.created = params.created;
    this.creator = params.creator;
    this.ndeltas = params.ndeltas;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _ModifiedCreatable.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["Ctype", this.creatableType],
      ["Created", this.created],
      ["Creator", this.creator],
      ["Ndeltas", this.ndeltas]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded ModifiedCreatable: ${data}`);
    }
    return new _ModifiedCreatable({
      creatableType: Number(data.get("Ctype")),
      created: data.get("Created"),
      creator: data.get("Creator"),
      ndeltas: Number(data.get("Ndeltas"))
    });
  }
};
ModifiedCreatable.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "Ctype",
    // creatableType
    valueSchema: new Uint64Schema()
  },
  {
    key: "Created",
    // created
    valueSchema: new BooleanSchema()
  },
  {
    key: "Creator",
    // creator
    valueSchema: new AddressSchema()
  },
  {
    key: "Ndeltas",
    // ndeltas
    valueSchema: new Uint64Schema()
  }
]));
var AlgoCount = class _AlgoCount {
  constructor(params) {
    this.money = params.money;
    this.rewardUnits = params.rewardUnits;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AlgoCount.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["mon", this.money],
      ["rwd", this.rewardUnits]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AlgoCount: ${data}`);
    }
    return new _AlgoCount({
      money: data.get("mon"),
      rewardUnits: data.get("rwd")
    });
  }
};
AlgoCount.encodingSchema = new NamedMapSchema(allOmitEmpty([
  { key: "mon", valueSchema: new Uint64Schema() },
  // money
  { key: "rwd", valueSchema: new Uint64Schema() }
  // rewardUnits
]));
var AccountTotals = class _AccountTotals {
  constructor(params) {
    this.online = params.online;
    this.offline = params.offline;
    this.notParticipating = params.notParticipating;
    this.rewardsLevel = params.rewardsLevel;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AccountTotals.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["online", this.online.toEncodingData()],
      ["offline", this.offline.toEncodingData()],
      ["notpart", this.notParticipating.toEncodingData()],
      ["rwdlvl", this.rewardsLevel]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AccountTotals: ${data}`);
    }
    return new _AccountTotals({
      online: AlgoCount.fromEncodingData(data.get("online")),
      offline: AlgoCount.fromEncodingData(data.get("offline")),
      notParticipating: AlgoCount.fromEncodingData(data.get("notpart")),
      rewardsLevel: data.get("rwdlvl")
    });
  }
};
AccountTotals.encodingSchema = new NamedMapSchema(allOmitEmpty([
  { key: "online", valueSchema: AlgoCount.encodingSchema },
  // online
  { key: "offline", valueSchema: AlgoCount.encodingSchema },
  // offline
  { key: "notpart", valueSchema: AlgoCount.encodingSchema },
  // notParticipating
  { key: "rwdlvl", valueSchema: new Uint64Schema() }
  // rewardsLevel
]));
var LedgerStateDelta = class _LedgerStateDelta {
  constructor(params) {
    this.accounts = params.accounts;
    this.kvMods = params.kvMods;
    this.txids = params.txids;
    this.txleases = params.txleases;
    this.creatables = params.creatables;
    this.blockHeader = params.blockHeader;
    this.stateProofNext = params.stateProofNext;
    this.prevTimestamp = params.prevTimestamp;
    this.totals = params.totals;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _LedgerStateDelta.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["Accts", this.accounts.toEncodingData()],
      [
        "KvMods",
        this.kvMods.size === 0 ? void 0 : convertMap(this.kvMods, (key, value) => [
          key,
          value.toEncodingData()
        ])
      ],
      [
        "Txids",
        convertMap(this.txids, (key, value) => [key, value.toEncodingData()])
      ],
      ["Txleases", this.txleases.toEncodingData()],
      [
        "Creatables",
        this.creatables.size === 0 ? void 0 : convertMap(this.creatables, (key, value) => [
          key,
          value.toEncodingData()
        ])
      ],
      ["Hdr", this.blockHeader.toEncodingData()],
      ["StateProofNext", this.stateProofNext],
      ["PrevTimestamp", this.prevTimestamp],
      ["Totals", this.totals.toEncodingData()]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded LedgerStateDelta: ${data}`);
    }
    return new _LedgerStateDelta({
      accounts: AccountDeltas.fromEncodingData(data.get("Accts")),
      kvMods: convertMap(data.get("KvMods") ?? /* @__PURE__ */ new Map(), (key, value) => [key, KvValueDelta.fromEncodingData(value)]),
      txids: convertMap(data.get("Txids"), (key, value) => [key, IncludedTransactions.fromEncodingData(value)]),
      txleases: UntypedValue.fromEncodingData(data.get("Txleases")),
      creatables: convertMap(data.get("Creatables") ?? /* @__PURE__ */ new Map(), (key, value) => [key, ModifiedCreatable.fromEncodingData(value)]),
      blockHeader: BlockHeader.fromEncodingData(data.get("Hdr")),
      stateProofNext: data.get("StateProofNext"),
      prevTimestamp: data.get("PrevTimestamp"),
      totals: AccountTotals.fromEncodingData(data.get("Totals"))
    });
  }
};
LedgerStateDelta.encodingSchema = new NamedMapSchema(allOmitEmpty([
  {
    key: "Accts",
    // accounts
    valueSchema: AccountDeltas.encodingSchema
  },
  {
    key: "KvMods",
    // kvMods
    valueSchema: new OptionalSchema(new SpecialCaseBinaryStringMapSchema(KvValueDelta.encodingSchema))
  },
  {
    key: "Txids",
    // txids
    valueSchema: new ByteArrayMapSchema(IncludedTransactions.encodingSchema)
  },
  {
    key: "Txleases",
    // txleases
    // Note: because txleases is currently just an UntypedSchema and we are expected to decode
    // null values for this field, we use OptionalSchema to coerce null values to undefined so
    // that the values can be properly omitted during encoding.
    valueSchema: new OptionalSchema(new UntypedSchema())
  },
  {
    key: "Creatables",
    // creatables
    valueSchema: new OptionalSchema(new Uint64MapSchema(ModifiedCreatable.encodingSchema))
  },
  {
    key: "Hdr",
    // blockHeader
    valueSchema: BlockHeader.encodingSchema
  },
  {
    key: "StateProofNext",
    // stateProofNext
    valueSchema: new Uint64Schema()
  },
  {
    key: "PrevTimestamp",
    // prevTimestamp
    valueSchema: new Uint64Schema()
  },
  {
    key: "Totals",
    // totals
    valueSchema: AccountTotals.encodingSchema
  }
]));

// node_modules/algosdk/dist/esm/client/v2/algod/models/types.js
var Account = class _Account {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "address", valueSchema: new StringSchema(), omitEmpty: true }, { key: "amount", valueSchema: new Uint64Schema(), omitEmpty: true }, {
        key: "amount-without-pending-rewards",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "min-balance",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "pending-rewards",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, { key: "rewards", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "round", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "status", valueSchema: new StringSchema(), omitEmpty: true }, {
        key: "total-apps-opted-in",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "total-assets-opted-in",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "total-created-apps",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "total-created-assets",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "apps-local-state",
        valueSchema: new OptionalSchema(new ArraySchema(ApplicationLocalState.encodingSchema)),
        omitEmpty: true
      }, {
        key: "apps-total-extra-pages",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "apps-total-schema",
        valueSchema: new OptionalSchema(ApplicationStateSchema.encodingSchema),
        omitEmpty: true
      }, {
        key: "assets",
        valueSchema: new OptionalSchema(new ArraySchema(AssetHolding2.encodingSchema)),
        omitEmpty: true
      }, {
        key: "auth-addr",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "created-apps",
        valueSchema: new OptionalSchema(new ArraySchema(Application.encodingSchema)),
        omitEmpty: true
      }, {
        key: "created-assets",
        valueSchema: new OptionalSchema(new ArraySchema(Asset.encodingSchema)),
        omitEmpty: true
      }, {
        key: "incentive-eligible",
        valueSchema: new OptionalSchema(new BooleanSchema()),
        omitEmpty: true
      }, {
        key: "last-heartbeat",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "last-proposed",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "participation",
        valueSchema: new OptionalSchema(AccountParticipation.encodingSchema),
        omitEmpty: true
      }, {
        key: "reward-base",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "sig-type",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "total-box-bytes",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "total-boxes",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `Account` object.
   * @param address - the account public key
   * @param amount - (algo) total number of MicroAlgos in the account
   * @param amountWithoutPendingRewards - specifies the amount of MicroAlgos in the account, without the pending rewards.
   * @param minBalance - MicroAlgo balance required by the account.
   * The requirement grows based on asset and application usage.
   * @param pendingRewards - amount of MicroAlgos of pending rewards in this account.
   * @param rewards - (ern) total rewards of MicroAlgos the account has received, including pending
   * rewards.
   * @param round - The round for which this information is relevant.
   * @param status - (onl) delegation status of the account's MicroAlgos
   * * Offline - indicates that the associated account is delegated.
   * * Online - indicates that the associated account used as part of the delegation
   * pool.
   * * NotParticipating - indicates that the associated account is neither a
   * delegator nor a delegate.
   * @param totalAppsOptedIn - The count of all applications that have been opted in, equivalent to the count
   * of application local data (AppLocalState objects) stored in this account.
   * @param totalAssetsOptedIn - The count of all assets that have been opted in, equivalent to the count of
   * AssetHolding objects held by this account.
   * @param totalCreatedApps - The count of all apps (AppParams objects) created by this account.
   * @param totalCreatedAssets - The count of all assets (AssetParams objects) created by this account.
   * @param appsLocalState - (appl) applications local data stored in this account.
   * Note the raw object uses `map[int] -> AppLocalState` for this type.
   * @param appsTotalExtraPages - (teap) the sum of all extra application program pages for this account.
   * @param appsTotalSchema - (tsch) stores the sum of all of the local schemas and global schemas in this
   * account.
   * Note: the raw account uses `StateSchema` for this type.
   * @param assets - (asset) assets held by this account.
   * Note the raw object uses `map[int] -> AssetHolding` for this type.
   * @param authAddr - (spend) the address against which signing should be checked. If empty, the
   * address of the current account is used. This field can be updated in any
   * transaction by setting the RekeyTo field.
   * @param createdApps - (appp) parameters of applications created by this account including app global
   * data.
   * Note: the raw account uses `map[int] -> AppParams` for this type.
   * @param createdAssets - (apar) parameters of assets created by this account.
   * Note: the raw account uses `map[int] -> Asset` for this type.
   * @param incentiveEligible - Whether or not the account can receive block incentives if its balance is in
   * range at proposal time.
   * @param lastHeartbeat - The round in which this account last went online, or explicitly renewed their
   * online status.
   * @param lastProposed - The round in which this account last proposed the block.
   * @param participation - AccountParticipation describes the parameters used by this account in consensus
   * protocol.
   * @param rewardBase - (ebase) used as part of the rewards computation. Only applicable to accounts
   * which are participating.
   * @param sigType - Indicates what type of signature is used by this account, must be one of:
   * * sig
   * * msig
   * * lsig
   * @param totalBoxBytes - (tbxb) The total number of bytes used by this account's app's box keys and
   * values.
   * @param totalBoxes - (tbx) The number of existing boxes created by this account's app.
   */
  constructor({ address, amount, amountWithoutPendingRewards, minBalance, pendingRewards, rewards, round, status, totalAppsOptedIn, totalAssetsOptedIn, totalCreatedApps, totalCreatedAssets, appsLocalState, appsTotalExtraPages, appsTotalSchema, assets, authAddr, createdApps, createdAssets, incentiveEligible, lastHeartbeat, lastProposed, participation, rewardBase, sigType, totalBoxBytes, totalBoxes }) {
    this.address = address;
    this.amount = ensureBigInt(amount);
    this.amountWithoutPendingRewards = ensureBigInt(amountWithoutPendingRewards);
    this.minBalance = ensureBigInt(minBalance);
    this.pendingRewards = ensureBigInt(pendingRewards);
    this.rewards = ensureBigInt(rewards);
    this.round = ensureBigInt(round);
    this.status = status;
    this.totalAppsOptedIn = ensureSafeInteger(totalAppsOptedIn);
    this.totalAssetsOptedIn = ensureSafeInteger(totalAssetsOptedIn);
    this.totalCreatedApps = ensureSafeInteger(totalCreatedApps);
    this.totalCreatedAssets = ensureSafeInteger(totalCreatedAssets);
    this.appsLocalState = appsLocalState;
    this.appsTotalExtraPages = typeof appsTotalExtraPages === "undefined" ? void 0 : ensureSafeInteger(appsTotalExtraPages);
    this.appsTotalSchema = appsTotalSchema;
    this.assets = assets;
    this.authAddr = typeof authAddr === "string" ? Address.fromString(authAddr) : authAddr;
    this.createdApps = createdApps;
    this.createdAssets = createdAssets;
    this.incentiveEligible = incentiveEligible;
    this.lastHeartbeat = typeof lastHeartbeat === "undefined" ? void 0 : ensureSafeInteger(lastHeartbeat);
    this.lastProposed = typeof lastProposed === "undefined" ? void 0 : ensureSafeInteger(lastProposed);
    this.participation = participation;
    this.rewardBase = typeof rewardBase === "undefined" ? void 0 : ensureBigInt(rewardBase);
    this.sigType = sigType;
    this.totalBoxBytes = typeof totalBoxBytes === "undefined" ? void 0 : ensureSafeInteger(totalBoxBytes);
    this.totalBoxes = typeof totalBoxes === "undefined" ? void 0 : ensureSafeInteger(totalBoxes);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _Account.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["address", this.address],
      ["amount", this.amount],
      ["amount-without-pending-rewards", this.amountWithoutPendingRewards],
      ["min-balance", this.minBalance],
      ["pending-rewards", this.pendingRewards],
      ["rewards", this.rewards],
      ["round", this.round],
      ["status", this.status],
      ["total-apps-opted-in", this.totalAppsOptedIn],
      ["total-assets-opted-in", this.totalAssetsOptedIn],
      ["total-created-apps", this.totalCreatedApps],
      ["total-created-assets", this.totalCreatedAssets],
      [
        "apps-local-state",
        typeof this.appsLocalState !== "undefined" ? this.appsLocalState.map((v2) => v2.toEncodingData()) : void 0
      ],
      ["apps-total-extra-pages", this.appsTotalExtraPages],
      [
        "apps-total-schema",
        typeof this.appsTotalSchema !== "undefined" ? this.appsTotalSchema.toEncodingData() : void 0
      ],
      [
        "assets",
        typeof this.assets !== "undefined" ? this.assets.map((v2) => v2.toEncodingData()) : void 0
      ],
      [
        "auth-addr",
        typeof this.authAddr !== "undefined" ? this.authAddr.toString() : void 0
      ],
      [
        "created-apps",
        typeof this.createdApps !== "undefined" ? this.createdApps.map((v2) => v2.toEncodingData()) : void 0
      ],
      [
        "created-assets",
        typeof this.createdAssets !== "undefined" ? this.createdAssets.map((v2) => v2.toEncodingData()) : void 0
      ],
      ["incentive-eligible", this.incentiveEligible],
      ["last-heartbeat", this.lastHeartbeat],
      ["last-proposed", this.lastProposed],
      [
        "participation",
        typeof this.participation !== "undefined" ? this.participation.toEncodingData() : void 0
      ],
      ["reward-base", this.rewardBase],
      ["sig-type", this.sigType],
      ["total-box-bytes", this.totalBoxBytes],
      ["total-boxes", this.totalBoxes]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded Account: ${data}`);
    }
    return new _Account({
      address: data.get("address"),
      amount: data.get("amount"),
      amountWithoutPendingRewards: data.get("amount-without-pending-rewards"),
      minBalance: data.get("min-balance"),
      pendingRewards: data.get("pending-rewards"),
      rewards: data.get("rewards"),
      round: data.get("round"),
      status: data.get("status"),
      totalAppsOptedIn: data.get("total-apps-opted-in"),
      totalAssetsOptedIn: data.get("total-assets-opted-in"),
      totalCreatedApps: data.get("total-created-apps"),
      totalCreatedAssets: data.get("total-created-assets"),
      appsLocalState: typeof data.get("apps-local-state") !== "undefined" ? data.get("apps-local-state").map((v2) => ApplicationLocalState.fromEncodingData(v2)) : void 0,
      appsTotalExtraPages: data.get("apps-total-extra-pages"),
      appsTotalSchema: typeof data.get("apps-total-schema") !== "undefined" ? ApplicationStateSchema.fromEncodingData(data.get("apps-total-schema")) : void 0,
      assets: typeof data.get("assets") !== "undefined" ? data.get("assets").map((v2) => AssetHolding2.fromEncodingData(v2)) : void 0,
      authAddr: data.get("auth-addr"),
      createdApps: typeof data.get("created-apps") !== "undefined" ? data.get("created-apps").map((v2) => Application.fromEncodingData(v2)) : void 0,
      createdAssets: typeof data.get("created-assets") !== "undefined" ? data.get("created-assets").map((v2) => Asset.fromEncodingData(v2)) : void 0,
      incentiveEligible: data.get("incentive-eligible"),
      lastHeartbeat: data.get("last-heartbeat"),
      lastProposed: data.get("last-proposed"),
      participation: typeof data.get("participation") !== "undefined" ? AccountParticipation.fromEncodingData(data.get("participation")) : void 0,
      rewardBase: data.get("reward-base"),
      sigType: data.get("sig-type"),
      totalBoxBytes: data.get("total-box-bytes"),
      totalBoxes: data.get("total-boxes")
    });
  }
};
var AccountApplicationResponse = class _AccountApplicationResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "round", valueSchema: new Uint64Schema(), omitEmpty: true }, {
        key: "app-local-state",
        valueSchema: new OptionalSchema(ApplicationLocalState.encodingSchema),
        omitEmpty: true
      }, {
        key: "created-app",
        valueSchema: new OptionalSchema(ApplicationParams.encodingSchema),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `AccountApplicationResponse` object.
   * @param round - The round for which this information is relevant.
   * @param appLocalState - (appl) the application local data stored in this account.
   * The raw account uses `AppLocalState` for this type.
   * @param createdApp - (appp) parameters of the application created by this account including app
   * global data.
   * The raw account uses `AppParams` for this type.
   */
  constructor({ round, appLocalState, createdApp }) {
    this.round = ensureBigInt(round);
    this.appLocalState = appLocalState;
    this.createdApp = createdApp;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AccountApplicationResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["round", this.round],
      [
        "app-local-state",
        typeof this.appLocalState !== "undefined" ? this.appLocalState.toEncodingData() : void 0
      ],
      [
        "created-app",
        typeof this.createdApp !== "undefined" ? this.createdApp.toEncodingData() : void 0
      ]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AccountApplicationResponse: ${data}`);
    }
    return new _AccountApplicationResponse({
      round: data.get("round"),
      appLocalState: typeof data.get("app-local-state") !== "undefined" ? ApplicationLocalState.fromEncodingData(data.get("app-local-state")) : void 0,
      createdApp: typeof data.get("created-app") !== "undefined" ? ApplicationParams.fromEncodingData(data.get("created-app")) : void 0
    });
  }
};
var AccountAssetHolding = class _AccountAssetHolding {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "asset-holding",
        valueSchema: AssetHolding2.encodingSchema,
        omitEmpty: true
      }, {
        key: "asset-params",
        valueSchema: new OptionalSchema(AssetParams2.encodingSchema),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `AccountAssetHolding` object.
   * @param assetHolding - (asset) Details about the asset held by this account.
   * The raw account uses `AssetHolding` for this type.
   * @param assetParams - (apar) parameters of the asset held by this account.
   * The raw account uses `AssetParams` for this type.
   */
  constructor({ assetHolding, assetParams }) {
    this.assetHolding = assetHolding;
    this.assetParams = assetParams;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AccountAssetHolding.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["asset-holding", this.assetHolding.toEncodingData()],
      [
        "asset-params",
        typeof this.assetParams !== "undefined" ? this.assetParams.toEncodingData() : void 0
      ]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AccountAssetHolding: ${data}`);
    }
    return new _AccountAssetHolding({
      assetHolding: AssetHolding2.fromEncodingData(data.get("asset-holding") ?? /* @__PURE__ */ new Map()),
      assetParams: typeof data.get("asset-params") !== "undefined" ? AssetParams2.fromEncodingData(data.get("asset-params")) : void 0
    });
  }
};
var AccountAssetResponse = class _AccountAssetResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "round", valueSchema: new Uint64Schema(), omitEmpty: true }, {
        key: "asset-holding",
        valueSchema: new OptionalSchema(AssetHolding2.encodingSchema),
        omitEmpty: true
      }, {
        key: "created-asset",
        valueSchema: new OptionalSchema(AssetParams2.encodingSchema),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `AccountAssetResponse` object.
   * @param round - The round for which this information is relevant.
   * @param assetHolding - (asset) Details about the asset held by this account.
   * The raw account uses `AssetHolding` for this type.
   * @param createdAsset - (apar) parameters of the asset created by this account.
   * The raw account uses `AssetParams` for this type.
   */
  constructor({ round, assetHolding, createdAsset }) {
    this.round = ensureBigInt(round);
    this.assetHolding = assetHolding;
    this.createdAsset = createdAsset;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AccountAssetResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["round", this.round],
      [
        "asset-holding",
        typeof this.assetHolding !== "undefined" ? this.assetHolding.toEncodingData() : void 0
      ],
      [
        "created-asset",
        typeof this.createdAsset !== "undefined" ? this.createdAsset.toEncodingData() : void 0
      ]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AccountAssetResponse: ${data}`);
    }
    return new _AccountAssetResponse({
      round: data.get("round"),
      assetHolding: typeof data.get("asset-holding") !== "undefined" ? AssetHolding2.fromEncodingData(data.get("asset-holding")) : void 0,
      createdAsset: typeof data.get("created-asset") !== "undefined" ? AssetParams2.fromEncodingData(data.get("created-asset")) : void 0
    });
  }
};
var AccountAssetsInformationResponse = class _AccountAssetsInformationResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "round", valueSchema: new Uint64Schema(), omitEmpty: true }, {
        key: "asset-holdings",
        valueSchema: new OptionalSchema(new ArraySchema(AccountAssetHolding.encodingSchema)),
        omitEmpty: true
      }, {
        key: "next-token",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `AccountAssetsInformationResponse` object.
   * @param round - The round for which this information is relevant.
   * @param assetHoldings -
   * @param nextToken - Used for pagination, when making another request provide this token with the
   * next parameter.
   */
  constructor({ round, assetHoldings, nextToken }) {
    this.round = ensureSafeInteger(round);
    this.assetHoldings = assetHoldings;
    this.nextToken = nextToken;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AccountAssetsInformationResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["round", this.round],
      [
        "asset-holdings",
        typeof this.assetHoldings !== "undefined" ? this.assetHoldings.map((v2) => v2.toEncodingData()) : void 0
      ],
      ["next-token", this.nextToken]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AccountAssetsInformationResponse: ${data}`);
    }
    return new _AccountAssetsInformationResponse({
      round: data.get("round"),
      assetHoldings: typeof data.get("asset-holdings") !== "undefined" ? data.get("asset-holdings").map((v2) => AccountAssetHolding.fromEncodingData(v2)) : void 0,
      nextToken: data.get("next-token")
    });
  }
};
var AccountParticipation = class _AccountParticipation {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "selection-participation-key",
        valueSchema: new ByteArraySchema(),
        omitEmpty: true
      }, {
        key: "vote-first-valid",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "vote-key-dilution",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "vote-last-valid",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "vote-participation-key",
        valueSchema: new ByteArraySchema(),
        omitEmpty: true
      }, {
        key: "state-proof-key",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `AccountParticipation` object.
   * @param selectionParticipationKey - (sel) Selection public key (if any) currently registered for this round.
   * @param voteFirstValid - (voteFst) First round for which this participation is valid.
   * @param voteKeyDilution - (voteKD) Number of subkeys in each batch of participation keys.
   * @param voteLastValid - (voteLst) Last round for which this participation is valid.
   * @param voteParticipationKey - (vote) root participation public key (if any) currently registered for this
   * round.
   * @param stateProofKey - (stprf) Root of the state proof key (if any)
   */
  constructor({ selectionParticipationKey, voteFirstValid, voteKeyDilution, voteLastValid, voteParticipationKey, stateProofKey }) {
    this.selectionParticipationKey = typeof selectionParticipationKey === "string" ? base64ToBytes(selectionParticipationKey) : selectionParticipationKey;
    this.voteFirstValid = ensureBigInt(voteFirstValid);
    this.voteKeyDilution = ensureBigInt(voteKeyDilution);
    this.voteLastValid = ensureBigInt(voteLastValid);
    this.voteParticipationKey = typeof voteParticipationKey === "string" ? base64ToBytes(voteParticipationKey) : voteParticipationKey;
    this.stateProofKey = typeof stateProofKey === "string" ? base64ToBytes(stateProofKey) : stateProofKey;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AccountParticipation.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["selection-participation-key", this.selectionParticipationKey],
      ["vote-first-valid", this.voteFirstValid],
      ["vote-key-dilution", this.voteKeyDilution],
      ["vote-last-valid", this.voteLastValid],
      ["vote-participation-key", this.voteParticipationKey],
      ["state-proof-key", this.stateProofKey]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AccountParticipation: ${data}`);
    }
    return new _AccountParticipation({
      selectionParticipationKey: data.get("selection-participation-key"),
      voteFirstValid: data.get("vote-first-valid"),
      voteKeyDilution: data.get("vote-key-dilution"),
      voteLastValid: data.get("vote-last-valid"),
      voteParticipationKey: data.get("vote-participation-key"),
      stateProofKey: data.get("state-proof-key")
    });
  }
};
var AccountStateDelta = class _AccountStateDelta {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "address", valueSchema: new StringSchema(), omitEmpty: true }, {
        key: "delta",
        valueSchema: new ArraySchema(EvalDeltaKeyValue.encodingSchema),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `AccountStateDelta` object.
   * @param address -
   * @param delta - Application state delta.
   */
  constructor({ address, delta }) {
    this.address = address;
    this.delta = delta;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AccountStateDelta.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["address", this.address],
      ["delta", this.delta.map((v2) => v2.toEncodingData())]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AccountStateDelta: ${data}`);
    }
    return new _AccountStateDelta({
      address: data.get("address"),
      delta: (data.get("delta") ?? []).map((v2) => EvalDeltaKeyValue.fromEncodingData(v2))
    });
  }
};
var AppCallLogs = class _AppCallLogs {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "application-index",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "logs",
        valueSchema: new ArraySchema(new ByteArraySchema()),
        omitEmpty: true
      }, { key: "txId", valueSchema: new StringSchema(), omitEmpty: true });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `AppCallLogs` object.
   * @param applicationIndex - The application from which the logs were generated
   * @param logs - An array of logs
   * @param txid - The transaction ID of the outer app call that lead to these logs
   */
  constructor({ applicationIndex, logs, txid }) {
    this.applicationIndex = ensureSafeInteger(applicationIndex);
    this.logs = logs;
    this.txid = txid;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AppCallLogs.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["application-index", this.applicationIndex],
      ["logs", this.logs],
      ["txId", this.txid]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AppCallLogs: ${data}`);
    }
    return new _AppCallLogs({
      applicationIndex: data.get("application-index"),
      logs: data.get("logs"),
      txid: data.get("txId")
    });
  }
};
var Application = class _Application {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "id", valueSchema: new Uint64Schema(), omitEmpty: true }, {
        key: "params",
        valueSchema: ApplicationParams.encodingSchema,
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `Application` object.
   * @param id - (appidx) application index.
   * @param params - (appparams) application parameters.
   */
  constructor({ id, params }) {
    this.id = ensureBigInt(id);
    this.params = params;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _Application.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["id", this.id],
      ["params", this.params.toEncodingData()]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded Application: ${data}`);
    }
    return new _Application({
      id: data.get("id"),
      params: ApplicationParams.fromEncodingData(data.get("params") ?? /* @__PURE__ */ new Map())
    });
  }
};
var ApplicationInitialStates = class _ApplicationInitialStates {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "id", valueSchema: new Uint64Schema(), omitEmpty: true }, {
        key: "app-boxes",
        valueSchema: new OptionalSchema(ApplicationKVStorage.encodingSchema),
        omitEmpty: true
      }, {
        key: "app-globals",
        valueSchema: new OptionalSchema(ApplicationKVStorage.encodingSchema),
        omitEmpty: true
      }, {
        key: "app-locals",
        valueSchema: new OptionalSchema(new ArraySchema(ApplicationKVStorage.encodingSchema)),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `ApplicationInitialStates` object.
   * @param id - Application index.
   * @param appBoxes - An application's global/local/box state.
   * @param appGlobals - An application's global/local/box state.
   * @param appLocals - An application's initial local states tied to different accounts.
   */
  constructor({ id, appBoxes, appGlobals, appLocals }) {
    this.id = ensureBigInt(id);
    this.appBoxes = appBoxes;
    this.appGlobals = appGlobals;
    this.appLocals = appLocals;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _ApplicationInitialStates.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["id", this.id],
      [
        "app-boxes",
        typeof this.appBoxes !== "undefined" ? this.appBoxes.toEncodingData() : void 0
      ],
      [
        "app-globals",
        typeof this.appGlobals !== "undefined" ? this.appGlobals.toEncodingData() : void 0
      ],
      [
        "app-locals",
        typeof this.appLocals !== "undefined" ? this.appLocals.map((v2) => v2.toEncodingData()) : void 0
      ]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded ApplicationInitialStates: ${data}`);
    }
    return new _ApplicationInitialStates({
      id: data.get("id"),
      appBoxes: typeof data.get("app-boxes") !== "undefined" ? ApplicationKVStorage.fromEncodingData(data.get("app-boxes")) : void 0,
      appGlobals: typeof data.get("app-globals") !== "undefined" ? ApplicationKVStorage.fromEncodingData(data.get("app-globals")) : void 0,
      appLocals: typeof data.get("app-locals") !== "undefined" ? data.get("app-locals").map((v2) => ApplicationKVStorage.fromEncodingData(v2)) : void 0
    });
  }
};
var ApplicationKVStorage = class _ApplicationKVStorage {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "kvs",
        valueSchema: new ArraySchema(AvmKeyValue.encodingSchema),
        omitEmpty: true
      }, {
        key: "account",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `ApplicationKVStorage` object.
   * @param kvs - Key-Value pairs representing application states.
   * @param account - The address of the account associated with the local state.
   */
  constructor({ kvs, account }) {
    this.kvs = kvs;
    this.account = typeof account === "string" ? Address.fromString(account) : account;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _ApplicationKVStorage.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["kvs", this.kvs.map((v2) => v2.toEncodingData())],
      [
        "account",
        typeof this.account !== "undefined" ? this.account.toString() : void 0
      ]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded ApplicationKVStorage: ${data}`);
    }
    return new _ApplicationKVStorage({
      kvs: (data.get("kvs") ?? []).map((v2) => AvmKeyValue.fromEncodingData(v2)),
      account: data.get("account")
    });
  }
};
var ApplicationLocalReference = class _ApplicationLocalReference {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "account", valueSchema: new StringSchema(), omitEmpty: true }, { key: "app", valueSchema: new Uint64Schema(), omitEmpty: true });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `ApplicationLocalReference` object.
   * @param account - Address of the account with the local state.
   * @param app - Application ID of the local state application.
   */
  constructor({ account, app }) {
    this.account = typeof account === "string" ? Address.fromString(account) : account;
    this.app = ensureBigInt(app);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _ApplicationLocalReference.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["account", this.account.toString()],
      ["app", this.app]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded ApplicationLocalReference: ${data}`);
    }
    return new _ApplicationLocalReference({
      account: data.get("account"),
      app: data.get("app")
    });
  }
};
var ApplicationLocalState = class _ApplicationLocalState {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "id", valueSchema: new Uint64Schema(), omitEmpty: true }, {
        key: "schema",
        valueSchema: ApplicationStateSchema.encodingSchema,
        omitEmpty: true
      }, {
        key: "key-value",
        valueSchema: new OptionalSchema(new ArraySchema(TealKeyValue.encodingSchema)),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `ApplicationLocalState` object.
   * @param id - The application which this local state is for.
   * @param schema - (hsch) schema.
   * @param keyValue - (tkv) storage.
   */
  constructor({ id, schema, keyValue }) {
    this.id = ensureBigInt(id);
    this.schema = schema;
    this.keyValue = keyValue;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _ApplicationLocalState.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["id", this.id],
      ["schema", this.schema.toEncodingData()],
      [
        "key-value",
        typeof this.keyValue !== "undefined" ? this.keyValue.map((v2) => v2.toEncodingData()) : void 0
      ]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded ApplicationLocalState: ${data}`);
    }
    return new _ApplicationLocalState({
      id: data.get("id"),
      schema: ApplicationStateSchema.fromEncodingData(data.get("schema") ?? /* @__PURE__ */ new Map()),
      keyValue: typeof data.get("key-value") !== "undefined" ? data.get("key-value").map((v2) => TealKeyValue.fromEncodingData(v2)) : void 0
    });
  }
};
var ApplicationParams = class _ApplicationParams {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "approval-program",
        valueSchema: new ByteArraySchema(),
        omitEmpty: true
      }, {
        key: "clear-state-program",
        valueSchema: new ByteArraySchema(),
        omitEmpty: true
      }, { key: "creator", valueSchema: new StringSchema(), omitEmpty: true }, {
        key: "extra-program-pages",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "global-state",
        valueSchema: new OptionalSchema(new ArraySchema(TealKeyValue.encodingSchema)),
        omitEmpty: true
      }, {
        key: "global-state-schema",
        valueSchema: new OptionalSchema(ApplicationStateSchema.encodingSchema),
        omitEmpty: true
      }, {
        key: "local-state-schema",
        valueSchema: new OptionalSchema(ApplicationStateSchema.encodingSchema),
        omitEmpty: true
      }, {
        key: "version",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `ApplicationParams` object.
   * @param approvalProgram - (approv) approval program.
   * @param clearStateProgram - (clearp) approval program.
   * @param creator - The address that created this application. This is the address where the
   * parameters and global state for this application can be found.
   * @param extraProgramPages - (epp) the amount of extra program pages available to this app.
   * @param globalState - (gs) global state
   * @param globalStateSchema - (gsch) global schema
   * @param localStateSchema - (lsch) local schema
   * @param version - (v) the number of updates to the application programs
   */
  constructor({ approvalProgram, clearStateProgram, creator, extraProgramPages, globalState, globalStateSchema, localStateSchema, version }) {
    this.approvalProgram = typeof approvalProgram === "string" ? base64ToBytes(approvalProgram) : approvalProgram;
    this.clearStateProgram = typeof clearStateProgram === "string" ? base64ToBytes(clearStateProgram) : clearStateProgram;
    this.creator = typeof creator === "string" ? Address.fromString(creator) : creator;
    this.extraProgramPages = typeof extraProgramPages === "undefined" ? void 0 : ensureSafeInteger(extraProgramPages);
    this.globalState = globalState;
    this.globalStateSchema = globalStateSchema;
    this.localStateSchema = localStateSchema;
    this.version = typeof version === "undefined" ? void 0 : ensureSafeInteger(version);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _ApplicationParams.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["approval-program", this.approvalProgram],
      ["clear-state-program", this.clearStateProgram],
      ["creator", this.creator.toString()],
      ["extra-program-pages", this.extraProgramPages],
      [
        "global-state",
        typeof this.globalState !== "undefined" ? this.globalState.map((v2) => v2.toEncodingData()) : void 0
      ],
      [
        "global-state-schema",
        typeof this.globalStateSchema !== "undefined" ? this.globalStateSchema.toEncodingData() : void 0
      ],
      [
        "local-state-schema",
        typeof this.localStateSchema !== "undefined" ? this.localStateSchema.toEncodingData() : void 0
      ],
      ["version", this.version]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded ApplicationParams: ${data}`);
    }
    return new _ApplicationParams({
      approvalProgram: data.get("approval-program"),
      clearStateProgram: data.get("clear-state-program"),
      creator: data.get("creator"),
      extraProgramPages: data.get("extra-program-pages"),
      globalState: typeof data.get("global-state") !== "undefined" ? data.get("global-state").map((v2) => TealKeyValue.fromEncodingData(v2)) : void 0,
      globalStateSchema: typeof data.get("global-state-schema") !== "undefined" ? ApplicationStateSchema.fromEncodingData(data.get("global-state-schema")) : void 0,
      localStateSchema: typeof data.get("local-state-schema") !== "undefined" ? ApplicationStateSchema.fromEncodingData(data.get("local-state-schema")) : void 0,
      version: data.get("version")
    });
  }
};
var ApplicationStateOperation = class _ApplicationStateOperation {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "app-state-type",
        valueSchema: new StringSchema(),
        omitEmpty: true
      }, { key: "key", valueSchema: new ByteArraySchema(), omitEmpty: true }, { key: "operation", valueSchema: new StringSchema(), omitEmpty: true }, {
        key: "account",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "new-value",
        valueSchema: new OptionalSchema(AvmValue.encodingSchema),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `ApplicationStateOperation` object.
   * @param appStateType - Type of application state. Value `g` is **global state**, `l` is **local
   * state**, `b` is **boxes**.
   * @param key - The key (name) of the global/local/box state.
   * @param operation - Operation type. Value `w` is **write**, `d` is **delete**.
   * @param account - For local state changes, the address of the account associated with the local
   * state.
   * @param newValue - Represents an AVM value.
   */
  constructor({ appStateType, key, operation, account, newValue }) {
    this.appStateType = appStateType;
    this.key = typeof key === "string" ? base64ToBytes(key) : key;
    this.operation = operation;
    this.account = typeof account === "string" ? Address.fromString(account) : account;
    this.newValue = newValue;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _ApplicationStateOperation.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["app-state-type", this.appStateType],
      ["key", this.key],
      ["operation", this.operation],
      [
        "account",
        typeof this.account !== "undefined" ? this.account.toString() : void 0
      ],
      [
        "new-value",
        typeof this.newValue !== "undefined" ? this.newValue.toEncodingData() : void 0
      ]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded ApplicationStateOperation: ${data}`);
    }
    return new _ApplicationStateOperation({
      appStateType: data.get("app-state-type"),
      key: data.get("key"),
      operation: data.get("operation"),
      account: data.get("account"),
      newValue: typeof data.get("new-value") !== "undefined" ? AvmValue.fromEncodingData(data.get("new-value")) : void 0
    });
  }
};
var ApplicationStateSchema = class _ApplicationStateSchema {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "num-byte-slice",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, { key: "num-uint", valueSchema: new Uint64Schema(), omitEmpty: true });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `ApplicationStateSchema` object.
   * @param numByteSlice - (nbs) num of byte slices.
   * @param numUint - (nui) num of uints.
   */
  constructor({ numByteSlice, numUint }) {
    this.numByteSlice = ensureSafeInteger(numByteSlice);
    this.numUint = ensureSafeInteger(numUint);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _ApplicationStateSchema.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["num-byte-slice", this.numByteSlice],
      ["num-uint", this.numUint]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded ApplicationStateSchema: ${data}`);
    }
    return new _ApplicationStateSchema({
      numByteSlice: data.get("num-byte-slice"),
      numUint: data.get("num-uint")
    });
  }
};
var Asset = class _Asset {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "index", valueSchema: new Uint64Schema(), omitEmpty: true }, {
        key: "params",
        valueSchema: AssetParams2.encodingSchema,
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `Asset` object.
   * @param index - unique asset identifier
   * @param params - AssetParams specifies the parameters for an asset.
   * (apar) when part of an AssetConfig transaction.
   * Definition:
   * data/transactions/asset.go : AssetParams
   */
  constructor({ index, params }) {
    this.index = ensureBigInt(index);
    this.params = params;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _Asset.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["index", this.index],
      ["params", this.params.toEncodingData()]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded Asset: ${data}`);
    }
    return new _Asset({
      index: data.get("index"),
      params: AssetParams2.fromEncodingData(data.get("params") ?? /* @__PURE__ */ new Map())
    });
  }
};
var AssetHolding2 = class _AssetHolding {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "amount", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "asset-id", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "is-frozen", valueSchema: new BooleanSchema(), omitEmpty: true });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `AssetHolding` object.
   * @param amount - (a) number of units held.
   * @param assetId - Asset ID of the holding.
   * @param isFrozen - (f) whether or not the holding is frozen.
   */
  constructor({ amount, assetId, isFrozen }) {
    this.amount = ensureBigInt(amount);
    this.assetId = ensureBigInt(assetId);
    this.isFrozen = isFrozen;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AssetHolding.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["amount", this.amount],
      ["asset-id", this.assetId],
      ["is-frozen", this.isFrozen]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AssetHolding: ${data}`);
    }
    return new _AssetHolding({
      amount: data.get("amount"),
      assetId: data.get("asset-id"),
      isFrozen: data.get("is-frozen")
    });
  }
};
var AssetHoldingReference = class _AssetHoldingReference {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "account", valueSchema: new StringSchema(), omitEmpty: true }, { key: "asset", valueSchema: new Uint64Schema(), omitEmpty: true });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `AssetHoldingReference` object.
   * @param account - Address of the account holding the asset.
   * @param asset - Asset ID of the holding.
   */
  constructor({ account, asset }) {
    this.account = typeof account === "string" ? Address.fromString(account) : account;
    this.asset = ensureBigInt(asset);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AssetHoldingReference.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["account", this.account.toString()],
      ["asset", this.asset]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AssetHoldingReference: ${data}`);
    }
    return new _AssetHoldingReference({
      account: data.get("account"),
      asset: data.get("asset")
    });
  }
};
var AssetParams2 = class _AssetParams {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "creator", valueSchema: new StringSchema(), omitEmpty: true }, { key: "decimals", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "total", valueSchema: new Uint64Schema(), omitEmpty: true }, {
        key: "clawback",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "default-frozen",
        valueSchema: new OptionalSchema(new BooleanSchema()),
        omitEmpty: true
      }, {
        key: "freeze",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "manager",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "metadata-hash",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      }, {
        key: "name",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "name-b64",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      }, {
        key: "reserve",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "unit-name",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "unit-name-b64",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      }, {
        key: "url",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "url-b64",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `AssetParams` object.
   * @param creator - The address that created this asset. This is the address where the parameters
   * for this asset can be found, and also the address where unwanted asset units can
   * be sent in the worst case.
   * @param decimals - (dc) The number of digits to use after the decimal point when displaying this
   * asset. If 0, the asset is not divisible. If 1, the base unit of the asset is in
   * tenths. If 2, the base unit of the asset is in hundredths, and so on. This value
   * must be between 0 and 19 (inclusive).
   * @param total - (t) The total number of units of this asset.
   * @param clawback - (c) Address of account used to clawback holdings of this asset. If empty,
   * clawback is not permitted.
   * @param defaultFrozen - (df) Whether holdings of this asset are frozen by default.
   * @param freeze - (f) Address of account used to freeze holdings of this asset. If empty, freezing
   * is not permitted.
   * @param manager - (m) Address of account used to manage the keys of this asset and to destroy it.
   * @param metadataHash - (am) A commitment to some unspecified asset metadata. The format of this
   * metadata is up to the application.
   * @param name - (an) Name of this asset, as supplied by the creator. Included only when the
   * asset name is composed of printable utf-8 characters.
   * @param nameB64 - Base64 encoded name of this asset, as supplied by the creator.
   * @param reserve - (r) Address of account holding reserve (non-minted) units of this asset.
   * @param unitName - (un) Name of a unit of this asset, as supplied by the creator. Included only
   * when the name of a unit of this asset is composed of printable utf-8 characters.
   * @param unitNameB64 - Base64 encoded name of a unit of this asset, as supplied by the creator.
   * @param url - (au) URL where more information about the asset can be retrieved. Included only
   * when the URL is composed of printable utf-8 characters.
   * @param urlB64 - Base64 encoded URL where more information about the asset can be retrieved.
   */
  constructor({ creator, decimals, total, clawback, defaultFrozen, freeze, manager, metadataHash, name, nameB64, reserve, unitName, unitNameB64, url, urlB64 }) {
    this.creator = creator;
    this.decimals = ensureSafeInteger(decimals);
    this.total = ensureBigInt(total);
    this.clawback = clawback;
    this.defaultFrozen = defaultFrozen;
    this.freeze = freeze;
    this.manager = manager;
    this.metadataHash = typeof metadataHash === "string" ? base64ToBytes(metadataHash) : metadataHash;
    this.name = name;
    this.nameB64 = typeof nameB64 === "string" ? base64ToBytes(nameB64) : nameB64;
    this.reserve = reserve;
    this.unitName = unitName;
    this.unitNameB64 = typeof unitNameB64 === "string" ? base64ToBytes(unitNameB64) : unitNameB64;
    this.url = url;
    this.urlB64 = typeof urlB64 === "string" ? base64ToBytes(urlB64) : urlB64;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AssetParams.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["creator", this.creator],
      ["decimals", this.decimals],
      ["total", this.total],
      ["clawback", this.clawback],
      ["default-frozen", this.defaultFrozen],
      ["freeze", this.freeze],
      ["manager", this.manager],
      ["metadata-hash", this.metadataHash],
      ["name", this.name],
      ["name-b64", this.nameB64],
      ["reserve", this.reserve],
      ["unit-name", this.unitName],
      ["unit-name-b64", this.unitNameB64],
      ["url", this.url],
      ["url-b64", this.urlB64]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AssetParams: ${data}`);
    }
    return new _AssetParams({
      creator: data.get("creator"),
      decimals: data.get("decimals"),
      total: data.get("total"),
      clawback: data.get("clawback"),
      defaultFrozen: data.get("default-frozen"),
      freeze: data.get("freeze"),
      manager: data.get("manager"),
      metadataHash: data.get("metadata-hash"),
      name: data.get("name"),
      nameB64: data.get("name-b64"),
      reserve: data.get("reserve"),
      unitName: data.get("unit-name"),
      unitNameB64: data.get("unit-name-b64"),
      url: data.get("url"),
      urlB64: data.get("url-b64")
    });
  }
};
var AvmKeyValue = class _AvmKeyValue {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "key", valueSchema: new ByteArraySchema(), omitEmpty: true }, { key: "value", valueSchema: AvmValue.encodingSchema, omitEmpty: true });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `AvmKeyValue` object.
   * @param key -
   * @param value - Represents an AVM value.
   */
  constructor({ key, value }) {
    this.key = typeof key === "string" ? base64ToBytes(key) : key;
    this.value = value;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AvmKeyValue.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["key", this.key],
      ["value", this.value.toEncodingData()]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AvmKeyValue: ${data}`);
    }
    return new _AvmKeyValue({
      key: data.get("key"),
      value: AvmValue.fromEncodingData(data.get("value") ?? /* @__PURE__ */ new Map())
    });
  }
};
var AvmValue = class _AvmValue {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "type", valueSchema: new Uint64Schema(), omitEmpty: true }, {
        key: "bytes",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      }, {
        key: "uint",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `AvmValue` object.
   * @param type - value type. Value `1` refers to **bytes**, value `2` refers to **uint64**
   * @param bytes - bytes value.
   * @param uint - uint value.
   */
  constructor({ type, bytes, uint }) {
    this.type = ensureSafeInteger(type);
    this.bytes = typeof bytes === "string" ? base64ToBytes(bytes) : bytes;
    this.uint = typeof uint === "undefined" ? void 0 : ensureBigInt(uint);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AvmValue.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["type", this.type],
      ["bytes", this.bytes],
      ["uint", this.uint]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AvmValue: ${data}`);
    }
    return new _AvmValue({
      type: data.get("type"),
      bytes: data.get("bytes"),
      uint: data.get("uint")
    });
  }
};
var BlockHashResponse = class _BlockHashResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "blockHash",
        valueSchema: new StringSchema(),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `BlockHashResponse` object.
   * @param blockhash - Block header hash.
   */
  constructor({ blockhash }) {
    this.blockhash = blockhash;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _BlockHashResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([["blockHash", this.blockhash]]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded BlockHashResponse: ${data}`);
    }
    return new _BlockHashResponse({
      blockhash: data.get("blockHash")
    });
  }
};
var BlockLogsResponse = class _BlockLogsResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "logs",
        valueSchema: new ArraySchema(AppCallLogs.encodingSchema),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `BlockLogsResponse` object.
   * @param logs -
   */
  constructor({ logs }) {
    this.logs = logs;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _BlockLogsResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["logs", this.logs.map((v2) => v2.toEncodingData())]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded BlockLogsResponse: ${data}`);
    }
    return new _BlockLogsResponse({
      logs: (data.get("logs") ?? []).map((v2) => AppCallLogs.fromEncodingData(v2))
    });
  }
};
var BlockResponse = class _BlockResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "block", valueSchema: Block.encodingSchema, omitEmpty: true }, {
        key: "cert",
        valueSchema: new OptionalSchema(UntypedValue.encodingSchema),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `BlockResponse` object.
   * @param block - Block header data.
   * @param cert - Optional certificate object. This is only included when the format is set to
   * message pack.
   */
  constructor({ block, cert }) {
    this.block = block;
    this.cert = cert;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _BlockResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["block", this.block.toEncodingData()],
      [
        "cert",
        typeof this.cert !== "undefined" ? this.cert.toEncodingData() : void 0
      ]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded BlockResponse: ${data}`);
    }
    return new _BlockResponse({
      block: Block.fromEncodingData(data.get("block") ?? /* @__PURE__ */ new Map()),
      cert: typeof data.get("cert") !== "undefined" ? UntypedValue.fromEncodingData(data.get("cert")) : void 0
    });
  }
};
var BlockTxidsResponse = class _BlockTxidsResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "blockTxids",
        valueSchema: new ArraySchema(new StringSchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `BlockTxidsResponse` object.
   * @param blocktxids - Block transaction IDs.
   */
  constructor({ blocktxids }) {
    this.blocktxids = blocktxids;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _BlockTxidsResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([["blockTxids", this.blocktxids]]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded BlockTxidsResponse: ${data}`);
    }
    return new _BlockTxidsResponse({
      blocktxids: data.get("blockTxids")
    });
  }
};
var Box = class _Box {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "name", valueSchema: new ByteArraySchema(), omitEmpty: true }, { key: "round", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "value", valueSchema: new ByteArraySchema(), omitEmpty: true });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `Box` object.
   * @param name - The box name, base64 encoded
   * @param round - The round for which this information is relevant
   * @param value - The box value, base64 encoded.
   */
  constructor({ name, round, value }) {
    this.name = typeof name === "string" ? base64ToBytes(name) : name;
    this.round = ensureBigInt(round);
    this.value = typeof value === "string" ? base64ToBytes(value) : value;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _Box.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["name", this.name],
      ["round", this.round],
      ["value", this.value]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded Box: ${data}`);
    }
    return new _Box({
      name: data.get("name"),
      round: data.get("round"),
      value: data.get("value")
    });
  }
};
var BoxDescriptor = class _BoxDescriptor {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "name",
        valueSchema: new ByteArraySchema(),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `BoxDescriptor` object.
   * @param name - Base64 encoded box name
   */
  constructor({ name }) {
    this.name = typeof name === "string" ? base64ToBytes(name) : name;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _BoxDescriptor.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([["name", this.name]]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded BoxDescriptor: ${data}`);
    }
    return new _BoxDescriptor({
      name: data.get("name")
    });
  }
};
var BoxReference = class _BoxReference {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "app", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "name", valueSchema: new ByteArraySchema(), omitEmpty: true });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `BoxReference` object.
   * @param app - Application ID which this box belongs to
   * @param name - Base64 encoded box name
   */
  constructor({ app, name }) {
    this.app = ensureBigInt(app);
    this.name = typeof name === "string" ? base64ToBytes(name) : name;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _BoxReference.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["app", this.app],
      ["name", this.name]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded BoxReference: ${data}`);
    }
    return new _BoxReference({
      app: data.get("app"),
      name: data.get("name")
    });
  }
};
var BoxesResponse = class _BoxesResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "boxes",
        valueSchema: new ArraySchema(BoxDescriptor.encodingSchema),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `BoxesResponse` object.
   * @param boxes -
   */
  constructor({ boxes }) {
    this.boxes = boxes;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _BoxesResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["boxes", this.boxes.map((v2) => v2.toEncodingData())]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded BoxesResponse: ${data}`);
    }
    return new _BoxesResponse({
      boxes: (data.get("boxes") ?? []).map((v2) => BoxDescriptor.fromEncodingData(v2))
    });
  }
};
var BuildVersion = class _BuildVersion {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "branch", valueSchema: new StringSchema(), omitEmpty: true }, {
        key: "build_number",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, { key: "channel", valueSchema: new StringSchema(), omitEmpty: true }, {
        key: "commit_hash",
        valueSchema: new StringSchema(),
        omitEmpty: true
      }, { key: "major", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "minor", valueSchema: new Uint64Schema(), omitEmpty: true });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `BuildVersion` object.
   * @param branch -
   * @param buildNumber -
   * @param channel -
   * @param commitHash -
   * @param major -
   * @param minor -
   */
  constructor({ branch, buildNumber, channel, commitHash, major, minor }) {
    this.branch = branch;
    this.buildNumber = ensureSafeInteger(buildNumber);
    this.channel = channel;
    this.commitHash = commitHash;
    this.major = ensureSafeInteger(major);
    this.minor = ensureSafeInteger(minor);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _BuildVersion.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["branch", this.branch],
      ["build_number", this.buildNumber],
      ["channel", this.channel],
      ["commit_hash", this.commitHash],
      ["major", this.major],
      ["minor", this.minor]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded BuildVersion: ${data}`);
    }
    return new _BuildVersion({
      branch: data.get("branch"),
      buildNumber: data.get("build_number"),
      channel: data.get("channel"),
      commitHash: data.get("commit_hash"),
      major: data.get("major"),
      minor: data.get("minor")
    });
  }
};
var CompileResponse = class _CompileResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "hash", valueSchema: new StringSchema(), omitEmpty: true }, { key: "result", valueSchema: new StringSchema(), omitEmpty: true }, {
        key: "sourcemap",
        valueSchema: new OptionalSchema(UntypedValue.encodingSchema),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `CompileResponse` object.
   * @param hash - base32 SHA512_256 of program bytes (Address style)
   * @param result - base64 encoded program bytes
   * @param sourcemap - JSON of the source map
   */
  constructor({ hash, result, sourcemap }) {
    this.hash = hash;
    this.result = result;
    this.sourcemap = sourcemap;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _CompileResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["hash", this.hash],
      ["result", this.result],
      [
        "sourcemap",
        typeof this.sourcemap !== "undefined" ? this.sourcemap.toEncodingData() : void 0
      ]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded CompileResponse: ${data}`);
    }
    return new _CompileResponse({
      hash: data.get("hash"),
      result: data.get("result"),
      sourcemap: typeof data.get("sourcemap") !== "undefined" ? UntypedValue.fromEncodingData(data.get("sourcemap")) : void 0
    });
  }
};
var DisassembleResponse = class _DisassembleResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "result",
        valueSchema: new StringSchema(),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `DisassembleResponse` object.
   * @param result - disassembled Teal code
   */
  constructor({ result }) {
    this.result = result;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _DisassembleResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([["result", this.result]]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded DisassembleResponse: ${data}`);
    }
    return new _DisassembleResponse({
      result: data.get("result")
    });
  }
};
var DryrunRequest = class _DryrunRequest {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "accounts",
        valueSchema: new ArraySchema(Account.encodingSchema),
        omitEmpty: true
      }, {
        key: "apps",
        valueSchema: new ArraySchema(Application.encodingSchema),
        omitEmpty: true
      }, {
        key: "latest-timestamp",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "protocol-version",
        valueSchema: new StringSchema(),
        omitEmpty: true
      }, { key: "round", valueSchema: new Uint64Schema(), omitEmpty: true }, {
        key: "sources",
        valueSchema: new ArraySchema(DryrunSource.encodingSchema),
        omitEmpty: true
      }, {
        key: "txns",
        valueSchema: new ArraySchema(SignedTransaction.encodingSchema),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `DryrunRequest` object.
   * @param accounts -
   * @param apps -
   * @param latestTimestamp - LatestTimestamp is available to some TEAL scripts. Defaults to the latest
   * confirmed timestamp this algod is attached to.
   * @param protocolVersion - ProtocolVersion specifies a specific version string to operate under, otherwise
   * whatever the current protocol of the network this algod is running in.
   * @param round - Round is available to some TEAL scripts. Defaults to the current round on the
   * network this algod is attached to.
   * @param sources -
   * @param txns -
   */
  constructor({ accounts, apps, latestTimestamp, protocolVersion, round, sources, txns }) {
    this.accounts = accounts;
    this.apps = apps;
    this.latestTimestamp = ensureSafeInteger(latestTimestamp);
    this.protocolVersion = protocolVersion;
    this.round = ensureBigInt(round);
    this.sources = sources;
    this.txns = txns;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _DryrunRequest.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["accounts", this.accounts.map((v2) => v2.toEncodingData())],
      ["apps", this.apps.map((v2) => v2.toEncodingData())],
      ["latest-timestamp", this.latestTimestamp],
      ["protocol-version", this.protocolVersion],
      ["round", this.round],
      ["sources", this.sources.map((v2) => v2.toEncodingData())],
      ["txns", this.txns.map((v2) => v2.toEncodingData())]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded DryrunRequest: ${data}`);
    }
    return new _DryrunRequest({
      accounts: (data.get("accounts") ?? []).map((v2) => Account.fromEncodingData(v2)),
      apps: (data.get("apps") ?? []).map((v2) => Application.fromEncodingData(v2)),
      latestTimestamp: data.get("latest-timestamp"),
      protocolVersion: data.get("protocol-version"),
      round: data.get("round"),
      sources: (data.get("sources") ?? []).map((v2) => DryrunSource.fromEncodingData(v2)),
      txns: (data.get("txns") ?? []).map((v2) => SignedTransaction.fromEncodingData(v2))
    });
  }
};
var DryrunResponse = class _DryrunResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "error", valueSchema: new StringSchema(), omitEmpty: true }, {
        key: "protocol-version",
        valueSchema: new StringSchema(),
        omitEmpty: true
      }, {
        key: "txns",
        valueSchema: new ArraySchema(DryrunTxnResult.encodingSchema),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `DryrunResponse` object.
   * @param error -
   * @param protocolVersion - Protocol version is the protocol version Dryrun was operated under.
   * @param txns -
   */
  constructor({ error, protocolVersion, txns }) {
    this.error = error;
    this.protocolVersion = protocolVersion;
    this.txns = txns;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _DryrunResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["error", this.error],
      ["protocol-version", this.protocolVersion],
      ["txns", this.txns.map((v2) => v2.toEncodingData())]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded DryrunResponse: ${data}`);
    }
    return new _DryrunResponse({
      error: data.get("error"),
      protocolVersion: data.get("protocol-version"),
      txns: (data.get("txns") ?? []).map((v2) => DryrunTxnResult.fromEncodingData(v2))
    });
  }
};
var DryrunSource = class _DryrunSource {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "app-index", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "field-name", valueSchema: new StringSchema(), omitEmpty: true }, { key: "source", valueSchema: new StringSchema(), omitEmpty: true }, { key: "txn-index", valueSchema: new Uint64Schema(), omitEmpty: true });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `DryrunSource` object.
   * @param appIndex -
   * @param fieldName - FieldName is what kind of sources this is. If lsig then it goes into the
   * transactions[this.TxnIndex].LogicSig. If approv or clearp it goes into the
   * Approval Program or Clear State Program of application[this.AppIndex].
   * @param source -
   * @param txnIndex -
   */
  constructor({ appIndex, fieldName, source, txnIndex }) {
    this.appIndex = ensureBigInt(appIndex);
    this.fieldName = fieldName;
    this.source = source;
    this.txnIndex = ensureSafeInteger(txnIndex);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _DryrunSource.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["app-index", this.appIndex],
      ["field-name", this.fieldName],
      ["source", this.source],
      ["txn-index", this.txnIndex]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded DryrunSource: ${data}`);
    }
    return new _DryrunSource({
      appIndex: data.get("app-index"),
      fieldName: data.get("field-name"),
      source: data.get("source"),
      txnIndex: data.get("txn-index")
    });
  }
};
var DryrunState = class _DryrunState {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "line", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "pc", valueSchema: new Uint64Schema(), omitEmpty: true }, {
        key: "stack",
        valueSchema: new ArraySchema(TealValue2.encodingSchema),
        omitEmpty: true
      }, {
        key: "error",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "scratch",
        valueSchema: new OptionalSchema(new ArraySchema(TealValue2.encodingSchema)),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `DryrunState` object.
   * @param line - Line number
   * @param pc - Program counter
   * @param stack -
   * @param error - Evaluation error if any
   * @param scratch -
   */
  constructor({ line, pc, stack, error, scratch }) {
    this.line = ensureSafeInteger(line);
    this.pc = ensureSafeInteger(pc);
    this.stack = stack;
    this.error = error;
    this.scratch = scratch;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _DryrunState.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["line", this.line],
      ["pc", this.pc],
      ["stack", this.stack.map((v2) => v2.toEncodingData())],
      ["error", this.error],
      [
        "scratch",
        typeof this.scratch !== "undefined" ? this.scratch.map((v2) => v2.toEncodingData()) : void 0
      ]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded DryrunState: ${data}`);
    }
    return new _DryrunState({
      line: data.get("line"),
      pc: data.get("pc"),
      stack: (data.get("stack") ?? []).map((v2) => TealValue2.fromEncodingData(v2)),
      error: data.get("error"),
      scratch: typeof data.get("scratch") !== "undefined" ? data.get("scratch").map((v2) => TealValue2.fromEncodingData(v2)) : void 0
    });
  }
};
var DryrunTxnResult = class _DryrunTxnResult {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "disassembly",
        valueSchema: new ArraySchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "app-call-messages",
        valueSchema: new OptionalSchema(new ArraySchema(new StringSchema())),
        omitEmpty: true
      }, {
        key: "app-call-trace",
        valueSchema: new OptionalSchema(new ArraySchema(DryrunState.encodingSchema)),
        omitEmpty: true
      }, {
        key: "budget-added",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "budget-consumed",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "global-delta",
        valueSchema: new OptionalSchema(new ArraySchema(EvalDeltaKeyValue.encodingSchema)),
        omitEmpty: true
      }, {
        key: "local-deltas",
        valueSchema: new OptionalSchema(new ArraySchema(AccountStateDelta.encodingSchema)),
        omitEmpty: true
      }, {
        key: "logic-sig-disassembly",
        valueSchema: new OptionalSchema(new ArraySchema(new StringSchema())),
        omitEmpty: true
      }, {
        key: "logic-sig-messages",
        valueSchema: new OptionalSchema(new ArraySchema(new StringSchema())),
        omitEmpty: true
      }, {
        key: "logic-sig-trace",
        valueSchema: new OptionalSchema(new ArraySchema(DryrunState.encodingSchema)),
        omitEmpty: true
      }, {
        key: "logs",
        valueSchema: new OptionalSchema(new ArraySchema(new ByteArraySchema())),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `DryrunTxnResult` object.
   * @param disassembly - Disassembled program line by line.
   * @param appCallMessages -
   * @param appCallTrace -
   * @param budgetAdded - Budget added during execution of app call transaction.
   * @param budgetConsumed - Budget consumed during execution of app call transaction.
   * @param globalDelta - Application state delta.
   * @param localDeltas -
   * @param logicSigDisassembly - Disassembled lsig program line by line.
   * @param logicSigMessages -
   * @param logicSigTrace -
   * @param logs -
   */
  constructor({ disassembly, appCallMessages, appCallTrace, budgetAdded, budgetConsumed, globalDelta, localDeltas, logicSigDisassembly, logicSigMessages, logicSigTrace, logs }) {
    this.disassembly = disassembly;
    this.appCallMessages = appCallMessages;
    this.appCallTrace = appCallTrace;
    this.budgetAdded = typeof budgetAdded === "undefined" ? void 0 : ensureSafeInteger(budgetAdded);
    this.budgetConsumed = typeof budgetConsumed === "undefined" ? void 0 : ensureSafeInteger(budgetConsumed);
    this.globalDelta = globalDelta;
    this.localDeltas = localDeltas;
    this.logicSigDisassembly = logicSigDisassembly;
    this.logicSigMessages = logicSigMessages;
    this.logicSigTrace = logicSigTrace;
    this.logs = logs;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _DryrunTxnResult.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["disassembly", this.disassembly],
      ["app-call-messages", this.appCallMessages],
      [
        "app-call-trace",
        typeof this.appCallTrace !== "undefined" ? this.appCallTrace.map((v2) => v2.toEncodingData()) : void 0
      ],
      ["budget-added", this.budgetAdded],
      ["budget-consumed", this.budgetConsumed],
      [
        "global-delta",
        typeof this.globalDelta !== "undefined" ? this.globalDelta.map((v2) => v2.toEncodingData()) : void 0
      ],
      [
        "local-deltas",
        typeof this.localDeltas !== "undefined" ? this.localDeltas.map((v2) => v2.toEncodingData()) : void 0
      ],
      ["logic-sig-disassembly", this.logicSigDisassembly],
      ["logic-sig-messages", this.logicSigMessages],
      [
        "logic-sig-trace",
        typeof this.logicSigTrace !== "undefined" ? this.logicSigTrace.map((v2) => v2.toEncodingData()) : void 0
      ],
      ["logs", this.logs]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded DryrunTxnResult: ${data}`);
    }
    return new _DryrunTxnResult({
      disassembly: data.get("disassembly"),
      appCallMessages: data.get("app-call-messages"),
      appCallTrace: typeof data.get("app-call-trace") !== "undefined" ? data.get("app-call-trace").map((v2) => DryrunState.fromEncodingData(v2)) : void 0,
      budgetAdded: data.get("budget-added"),
      budgetConsumed: data.get("budget-consumed"),
      globalDelta: typeof data.get("global-delta") !== "undefined" ? data.get("global-delta").map((v2) => EvalDeltaKeyValue.fromEncodingData(v2)) : void 0,
      localDeltas: typeof data.get("local-deltas") !== "undefined" ? data.get("local-deltas").map((v2) => AccountStateDelta.fromEncodingData(v2)) : void 0,
      logicSigDisassembly: data.get("logic-sig-disassembly"),
      logicSigMessages: data.get("logic-sig-messages"),
      logicSigTrace: typeof data.get("logic-sig-trace") !== "undefined" ? data.get("logic-sig-trace").map((v2) => DryrunState.fromEncodingData(v2)) : void 0,
      logs: data.get("logs")
    });
  }
};
var ErrorResponse = class _ErrorResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "message", valueSchema: new StringSchema(), omitEmpty: true }, {
        key: "data",
        valueSchema: new OptionalSchema(UntypedValue.encodingSchema),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `ErrorResponse` object.
   * @param message -
   * @param data -
   */
  constructor({ message, data }) {
    this.message = message;
    this.data = data;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _ErrorResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["message", this.message],
      [
        "data",
        typeof this.data !== "undefined" ? this.data.toEncodingData() : void 0
      ]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded ErrorResponse: ${data}`);
    }
    return new _ErrorResponse({
      message: data.get("message"),
      data: typeof data.get("data") !== "undefined" ? UntypedValue.fromEncodingData(data.get("data")) : void 0
    });
  }
};
var EvalDelta2 = class _EvalDelta {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "action", valueSchema: new Uint64Schema(), omitEmpty: true }, {
        key: "bytes",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "uint",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `EvalDelta` object.
   * @param action - (at) delta action.
   * @param bytes - (bs) bytes value.
   * @param uint - (ui) uint value.
   */
  constructor({ action, bytes, uint }) {
    this.action = ensureSafeInteger(action);
    this.bytes = bytes;
    this.uint = typeof uint === "undefined" ? void 0 : ensureBigInt(uint);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _EvalDelta.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["action", this.action],
      ["bytes", this.bytes],
      ["uint", this.uint]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded EvalDelta: ${data}`);
    }
    return new _EvalDelta({
      action: data.get("action"),
      bytes: data.get("bytes"),
      uint: data.get("uint")
    });
  }
};
var EvalDeltaKeyValue = class _EvalDeltaKeyValue {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "key", valueSchema: new StringSchema(), omitEmpty: true }, { key: "value", valueSchema: EvalDelta2.encodingSchema, omitEmpty: true });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `EvalDeltaKeyValue` object.
   * @param key -
   * @param value - Represents a TEAL value delta.
   */
  constructor({ key, value }) {
    this.key = key;
    this.value = value;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _EvalDeltaKeyValue.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["key", this.key],
      ["value", this.value.toEncodingData()]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded EvalDeltaKeyValue: ${data}`);
    }
    return new _EvalDeltaKeyValue({
      key: data.get("key"),
      value: EvalDelta2.fromEncodingData(data.get("value") ?? /* @__PURE__ */ new Map())
    });
  }
};
var Genesis = class _Genesis {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "alloc",
        valueSchema: new ArraySchema(GenesisAllocation.encodingSchema),
        omitEmpty: true
      }, { key: "fees", valueSchema: new StringSchema(), omitEmpty: true }, { key: "id", valueSchema: new StringSchema(), omitEmpty: true }, { key: "network", valueSchema: new StringSchema(), omitEmpty: true }, { key: "proto", valueSchema: new StringSchema(), omitEmpty: true }, { key: "rwd", valueSchema: new StringSchema(), omitEmpty: true }, { key: "timestamp", valueSchema: new Uint64Schema(), omitEmpty: true }, {
        key: "comment",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "devmode",
        valueSchema: new OptionalSchema(new BooleanSchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `Genesis` object.
   * @param alloc -
   * @param fees -
   * @param id -
   * @param network -
   * @param proto -
   * @param rwd -
   * @param timestamp -
   * @param comment -
   * @param devmode -
   */
  constructor({ alloc, fees, id, network, proto, rwd, timestamp, comment, devmode }) {
    this.alloc = alloc;
    this.fees = fees;
    this.id = id;
    this.network = network;
    this.proto = proto;
    this.rwd = rwd;
    this.timestamp = ensureSafeInteger(timestamp);
    this.comment = comment;
    this.devmode = devmode;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _Genesis.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["alloc", this.alloc.map((v2) => v2.toEncodingData())],
      ["fees", this.fees],
      ["id", this.id],
      ["network", this.network],
      ["proto", this.proto],
      ["rwd", this.rwd],
      ["timestamp", this.timestamp],
      ["comment", this.comment],
      ["devmode", this.devmode]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded Genesis: ${data}`);
    }
    return new _Genesis({
      alloc: (data.get("alloc") ?? []).map((v2) => GenesisAllocation.fromEncodingData(v2)),
      fees: data.get("fees"),
      id: data.get("id"),
      network: data.get("network"),
      proto: data.get("proto"),
      rwd: data.get("rwd"),
      timestamp: data.get("timestamp"),
      comment: data.get("comment"),
      devmode: data.get("devmode")
    });
  }
};
var GenesisAllocation = class _GenesisAllocation {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "addr", valueSchema: new StringSchema(), omitEmpty: true }, { key: "comment", valueSchema: new StringSchema(), omitEmpty: true }, {
        key: "state",
        valueSchema: UntypedValue.encodingSchema,
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `GenesisAllocation` object.
   * @param addr -
   * @param comment -
   * @param state -
   */
  constructor({ addr, comment, state }) {
    this.addr = addr;
    this.comment = comment;
    this.state = state;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _GenesisAllocation.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["addr", this.addr],
      ["comment", this.comment],
      ["state", this.state.toEncodingData()]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded GenesisAllocation: ${data}`);
    }
    return new _GenesisAllocation({
      addr: data.get("addr"),
      comment: data.get("comment"),
      state: UntypedValue.fromEncodingData(data.get("state") ?? /* @__PURE__ */ new Map())
    });
  }
};
var GetBlockTimeStampOffsetResponse = class _GetBlockTimeStampOffsetResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "offset",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `GetBlockTimeStampOffsetResponse` object.
   * @param offset - Timestamp offset in seconds.
   */
  constructor({ offset }) {
    this.offset = ensureSafeInteger(offset);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _GetBlockTimeStampOffsetResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([["offset", this.offset]]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded GetBlockTimeStampOffsetResponse: ${data}`);
    }
    return new _GetBlockTimeStampOffsetResponse({
      offset: data.get("offset")
    });
  }
};
var GetSyncRoundResponse = class _GetSyncRoundResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "round",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `GetSyncRoundResponse` object.
   * @param round - The minimum sync round for the ledger.
   */
  constructor({ round }) {
    this.round = ensureBigInt(round);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _GetSyncRoundResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([["round", this.round]]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded GetSyncRoundResponse: ${data}`);
    }
    return new _GetSyncRoundResponse({
      round: data.get("round")
    });
  }
};
var LedgerStateDeltaForTransactionGroup = class _LedgerStateDeltaForTransactionGroup {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "Delta",
        valueSchema: LedgerStateDelta.encodingSchema,
        omitEmpty: true
      }, {
        key: "Ids",
        valueSchema: new ArraySchema(new StringSchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `LedgerStateDeltaForTransactionGroup` object.
   * @param delta - Ledger StateDelta object
   * @param ids -
   */
  constructor({ delta, ids }) {
    this.delta = delta;
    this.ids = ids;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _LedgerStateDeltaForTransactionGroup.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["Delta", this.delta.toEncodingData()],
      ["Ids", this.ids]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded LedgerStateDeltaForTransactionGroup: ${data}`);
    }
    return new _LedgerStateDeltaForTransactionGroup({
      delta: LedgerStateDelta.fromEncodingData(data.get("Delta") ?? /* @__PURE__ */ new Map()),
      ids: data.get("Ids")
    });
  }
};
var LightBlockHeaderProof = class _LightBlockHeaderProof {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "index", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "proof", valueSchema: new ByteArraySchema(), omitEmpty: true }, { key: "treedepth", valueSchema: new Uint64Schema(), omitEmpty: true });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `LightBlockHeaderProof` object.
   * @param index - The index of the light block header in the vector commitment tree
   * @param proof - The encoded proof.
   * @param treedepth - Represents the depth of the tree that is being proven, i.e. the number of edges
   * from a leaf to the root.
   */
  constructor({ index, proof, treedepth }) {
    this.index = ensureSafeInteger(index);
    this.proof = typeof proof === "string" ? base64ToBytes(proof) : proof;
    this.treedepth = ensureSafeInteger(treedepth);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _LightBlockHeaderProof.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["index", this.index],
      ["proof", this.proof],
      ["treedepth", this.treedepth]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded LightBlockHeaderProof: ${data}`);
    }
    return new _LightBlockHeaderProof({
      index: data.get("index"),
      proof: data.get("proof"),
      treedepth: data.get("treedepth")
    });
  }
};
var NodeStatusResponse = class _NodeStatusResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "catchup-time",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, { key: "last-round", valueSchema: new Uint64Schema(), omitEmpty: true }, {
        key: "last-version",
        valueSchema: new StringSchema(),
        omitEmpty: true
      }, {
        key: "next-version",
        valueSchema: new StringSchema(),
        omitEmpty: true
      }, {
        key: "next-version-round",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "next-version-supported",
        valueSchema: new BooleanSchema(),
        omitEmpty: true
      }, {
        key: "stopped-at-unsupported-round",
        valueSchema: new BooleanSchema(),
        omitEmpty: true
      }, {
        key: "time-since-last-round",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "catchpoint",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "catchpoint-acquired-blocks",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "catchpoint-processed-accounts",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "catchpoint-processed-kvs",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "catchpoint-total-accounts",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "catchpoint-total-blocks",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "catchpoint-total-kvs",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "catchpoint-verified-accounts",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "catchpoint-verified-kvs",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "last-catchpoint",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "upgrade-delay",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "upgrade-next-protocol-vote-before",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "upgrade-no-votes",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "upgrade-node-vote",
        valueSchema: new OptionalSchema(new BooleanSchema()),
        omitEmpty: true
      }, {
        key: "upgrade-vote-rounds",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "upgrade-votes",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "upgrade-votes-required",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "upgrade-yes-votes",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `NodeStatusResponse` object.
   * @param catchupTime - CatchupTime in nanoseconds
   * @param lastRound - LastRound indicates the last round seen
   * @param lastVersion - LastVersion indicates the last consensus version supported
   * @param nextVersion - NextVersion of consensus protocol to use
   * @param nextVersionRound - NextVersionRound is the round at which the next consensus version will apply
   * @param nextVersionSupported - NextVersionSupported indicates whether the next consensus version is supported
   * by this node
   * @param stoppedAtUnsupportedRound - StoppedAtUnsupportedRound indicates that the node does not support the new
   * rounds and has stopped making progress
   * @param timeSinceLastRound - TimeSinceLastRound in nanoseconds
   * @param catchpoint - The current catchpoint that is being caught up to
   * @param catchpointAcquiredBlocks - The number of blocks that have already been obtained by the node as part of the
   * catchup
   * @param catchpointProcessedAccounts - The number of accounts from the current catchpoint that have been processed so
   * far as part of the catchup
   * @param catchpointProcessedKvs - The number of key-values (KVs) from the current catchpoint that have been
   * processed so far as part of the catchup
   * @param catchpointTotalAccounts - The total number of accounts included in the current catchpoint
   * @param catchpointTotalBlocks - The total number of blocks that are required to complete the current catchpoint
   * catchup
   * @param catchpointTotalKvs - The total number of key-values (KVs) included in the current catchpoint
   * @param catchpointVerifiedAccounts - The number of accounts from the current catchpoint that have been verified so
   * far as part of the catchup
   * @param catchpointVerifiedKvs - The number of key-values (KVs) from the current catchpoint that have been
   * verified so far as part of the catchup
   * @param lastCatchpoint - The last catchpoint seen by the node
   * @param upgradeDelay - Upgrade delay
   * @param upgradeNextProtocolVoteBefore - Next protocol round
   * @param upgradeNoVotes - No votes cast for consensus upgrade
   * @param upgradeNodeVote - This node's upgrade vote
   * @param upgradeVoteRounds - Total voting rounds for current upgrade
   * @param upgradeVotes - Total votes cast for consensus upgrade
   * @param upgradeVotesRequired - Yes votes required for consensus upgrade
   * @param upgradeYesVotes - Yes votes cast for consensus upgrade
   */
  constructor({ catchupTime, lastRound, lastVersion, nextVersion, nextVersionRound, nextVersionSupported, stoppedAtUnsupportedRound, timeSinceLastRound, catchpoint, catchpointAcquiredBlocks, catchpointProcessedAccounts, catchpointProcessedKvs, catchpointTotalAccounts, catchpointTotalBlocks, catchpointTotalKvs, catchpointVerifiedAccounts, catchpointVerifiedKvs, lastCatchpoint, upgradeDelay, upgradeNextProtocolVoteBefore, upgradeNoVotes, upgradeNodeVote, upgradeVoteRounds, upgradeVotes, upgradeVotesRequired, upgradeYesVotes }) {
    this.catchupTime = ensureBigInt(catchupTime);
    this.lastRound = ensureBigInt(lastRound);
    this.lastVersion = lastVersion;
    this.nextVersion = nextVersion;
    this.nextVersionRound = ensureBigInt(nextVersionRound);
    this.nextVersionSupported = nextVersionSupported;
    this.stoppedAtUnsupportedRound = stoppedAtUnsupportedRound;
    this.timeSinceLastRound = ensureBigInt(timeSinceLastRound);
    this.catchpoint = catchpoint;
    this.catchpointAcquiredBlocks = typeof catchpointAcquiredBlocks === "undefined" ? void 0 : ensureSafeInteger(catchpointAcquiredBlocks);
    this.catchpointProcessedAccounts = typeof catchpointProcessedAccounts === "undefined" ? void 0 : ensureSafeInteger(catchpointProcessedAccounts);
    this.catchpointProcessedKvs = typeof catchpointProcessedKvs === "undefined" ? void 0 : ensureSafeInteger(catchpointProcessedKvs);
    this.catchpointTotalAccounts = typeof catchpointTotalAccounts === "undefined" ? void 0 : ensureSafeInteger(catchpointTotalAccounts);
    this.catchpointTotalBlocks = typeof catchpointTotalBlocks === "undefined" ? void 0 : ensureSafeInteger(catchpointTotalBlocks);
    this.catchpointTotalKvs = typeof catchpointTotalKvs === "undefined" ? void 0 : ensureSafeInteger(catchpointTotalKvs);
    this.catchpointVerifiedAccounts = typeof catchpointVerifiedAccounts === "undefined" ? void 0 : ensureSafeInteger(catchpointVerifiedAccounts);
    this.catchpointVerifiedKvs = typeof catchpointVerifiedKvs === "undefined" ? void 0 : ensureSafeInteger(catchpointVerifiedKvs);
    this.lastCatchpoint = lastCatchpoint;
    this.upgradeDelay = typeof upgradeDelay === "undefined" ? void 0 : ensureBigInt(upgradeDelay);
    this.upgradeNextProtocolVoteBefore = typeof upgradeNextProtocolVoteBefore === "undefined" ? void 0 : ensureBigInt(upgradeNextProtocolVoteBefore);
    this.upgradeNoVotes = typeof upgradeNoVotes === "undefined" ? void 0 : ensureSafeInteger(upgradeNoVotes);
    this.upgradeNodeVote = upgradeNodeVote;
    this.upgradeVoteRounds = typeof upgradeVoteRounds === "undefined" ? void 0 : ensureSafeInteger(upgradeVoteRounds);
    this.upgradeVotes = typeof upgradeVotes === "undefined" ? void 0 : ensureSafeInteger(upgradeVotes);
    this.upgradeVotesRequired = typeof upgradeVotesRequired === "undefined" ? void 0 : ensureSafeInteger(upgradeVotesRequired);
    this.upgradeYesVotes = typeof upgradeYesVotes === "undefined" ? void 0 : ensureSafeInteger(upgradeYesVotes);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _NodeStatusResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["catchup-time", this.catchupTime],
      ["last-round", this.lastRound],
      ["last-version", this.lastVersion],
      ["next-version", this.nextVersion],
      ["next-version-round", this.nextVersionRound],
      ["next-version-supported", this.nextVersionSupported],
      ["stopped-at-unsupported-round", this.stoppedAtUnsupportedRound],
      ["time-since-last-round", this.timeSinceLastRound],
      ["catchpoint", this.catchpoint],
      ["catchpoint-acquired-blocks", this.catchpointAcquiredBlocks],
      ["catchpoint-processed-accounts", this.catchpointProcessedAccounts],
      ["catchpoint-processed-kvs", this.catchpointProcessedKvs],
      ["catchpoint-total-accounts", this.catchpointTotalAccounts],
      ["catchpoint-total-blocks", this.catchpointTotalBlocks],
      ["catchpoint-total-kvs", this.catchpointTotalKvs],
      ["catchpoint-verified-accounts", this.catchpointVerifiedAccounts],
      ["catchpoint-verified-kvs", this.catchpointVerifiedKvs],
      ["last-catchpoint", this.lastCatchpoint],
      ["upgrade-delay", this.upgradeDelay],
      ["upgrade-next-protocol-vote-before", this.upgradeNextProtocolVoteBefore],
      ["upgrade-no-votes", this.upgradeNoVotes],
      ["upgrade-node-vote", this.upgradeNodeVote],
      ["upgrade-vote-rounds", this.upgradeVoteRounds],
      ["upgrade-votes", this.upgradeVotes],
      ["upgrade-votes-required", this.upgradeVotesRequired],
      ["upgrade-yes-votes", this.upgradeYesVotes]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded NodeStatusResponse: ${data}`);
    }
    return new _NodeStatusResponse({
      catchupTime: data.get("catchup-time"),
      lastRound: data.get("last-round"),
      lastVersion: data.get("last-version"),
      nextVersion: data.get("next-version"),
      nextVersionRound: data.get("next-version-round"),
      nextVersionSupported: data.get("next-version-supported"),
      stoppedAtUnsupportedRound: data.get("stopped-at-unsupported-round"),
      timeSinceLastRound: data.get("time-since-last-round"),
      catchpoint: data.get("catchpoint"),
      catchpointAcquiredBlocks: data.get("catchpoint-acquired-blocks"),
      catchpointProcessedAccounts: data.get("catchpoint-processed-accounts"),
      catchpointProcessedKvs: data.get("catchpoint-processed-kvs"),
      catchpointTotalAccounts: data.get("catchpoint-total-accounts"),
      catchpointTotalBlocks: data.get("catchpoint-total-blocks"),
      catchpointTotalKvs: data.get("catchpoint-total-kvs"),
      catchpointVerifiedAccounts: data.get("catchpoint-verified-accounts"),
      catchpointVerifiedKvs: data.get("catchpoint-verified-kvs"),
      lastCatchpoint: data.get("last-catchpoint"),
      upgradeDelay: data.get("upgrade-delay"),
      upgradeNextProtocolVoteBefore: data.get("upgrade-next-protocol-vote-before"),
      upgradeNoVotes: data.get("upgrade-no-votes"),
      upgradeNodeVote: data.get("upgrade-node-vote"),
      upgradeVoteRounds: data.get("upgrade-vote-rounds"),
      upgradeVotes: data.get("upgrade-votes"),
      upgradeVotesRequired: data.get("upgrade-votes-required"),
      upgradeYesVotes: data.get("upgrade-yes-votes")
    });
  }
};
var PendingTransactionResponse = class _PendingTransactionResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "pool-error", valueSchema: new StringSchema(), omitEmpty: true }, {
        key: "txn",
        valueSchema: SignedTransaction.encodingSchema,
        omitEmpty: true
      }, {
        key: "application-index",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "asset-closing-amount",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "asset-index",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "close-rewards",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "closing-amount",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "confirmed-round",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "global-state-delta",
        valueSchema: new OptionalSchema(new ArraySchema(EvalDeltaKeyValue.encodingSchema)),
        omitEmpty: true
      }, {
        key: "inner-txns",
        valueSchema: new OptionalSchema(new ArraySchema(_PendingTransactionResponse.encodingSchema)),
        omitEmpty: true
      }, {
        key: "local-state-delta",
        valueSchema: new OptionalSchema(new ArraySchema(AccountStateDelta.encodingSchema)),
        omitEmpty: true
      }, {
        key: "logs",
        valueSchema: new OptionalSchema(new ArraySchema(new ByteArraySchema())),
        omitEmpty: true
      }, {
        key: "receiver-rewards",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "sender-rewards",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `PendingTransactionResponse` object.
   * @param poolError - Indicates that the transaction was kicked out of this node's transaction pool
   * (and specifies why that happened). An empty string indicates the transaction
   * wasn't kicked out of this node's txpool due to an error.
   * @param txn - The raw signed transaction.
   * @param applicationIndex - The application index if the transaction was found and it created an
   * application.
   * @param assetClosingAmount - The number of the asset's unit that were transferred to the close-to address.
   * @param assetIndex - The asset index if the transaction was found and it created an asset.
   * @param closeRewards - Rewards in microalgos applied to the close remainder to account.
   * @param closingAmount - Closing amount for the transaction.
   * @param confirmedRound - The round where this transaction was confirmed, if present.
   * @param globalStateDelta - Global state key/value changes for the application being executed by this
   * transaction.
   * @param innerTxns - Inner transactions produced by application execution.
   * @param localStateDelta - Local state key/value changes for the application being executed by this
   * transaction.
   * @param logs - Logs for the application being executed by this transaction.
   * @param receiverRewards - Rewards in microalgos applied to the receiver account.
   * @param senderRewards - Rewards in microalgos applied to the sender account.
   */
  constructor({ poolError, txn, applicationIndex, assetClosingAmount, assetIndex, closeRewards, closingAmount, confirmedRound, globalStateDelta, innerTxns, localStateDelta, logs, receiverRewards, senderRewards }) {
    this.poolError = poolError;
    this.txn = txn;
    this.applicationIndex = typeof applicationIndex === "undefined" ? void 0 : ensureBigInt(applicationIndex);
    this.assetClosingAmount = typeof assetClosingAmount === "undefined" ? void 0 : ensureBigInt(assetClosingAmount);
    this.assetIndex = typeof assetIndex === "undefined" ? void 0 : ensureBigInt(assetIndex);
    this.closeRewards = typeof closeRewards === "undefined" ? void 0 : ensureBigInt(closeRewards);
    this.closingAmount = typeof closingAmount === "undefined" ? void 0 : ensureBigInt(closingAmount);
    this.confirmedRound = typeof confirmedRound === "undefined" ? void 0 : ensureBigInt(confirmedRound);
    this.globalStateDelta = globalStateDelta;
    this.innerTxns = innerTxns;
    this.localStateDelta = localStateDelta;
    this.logs = logs;
    this.receiverRewards = typeof receiverRewards === "undefined" ? void 0 : ensureBigInt(receiverRewards);
    this.senderRewards = typeof senderRewards === "undefined" ? void 0 : ensureBigInt(senderRewards);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _PendingTransactionResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["pool-error", this.poolError],
      ["txn", this.txn.toEncodingData()],
      ["application-index", this.applicationIndex],
      ["asset-closing-amount", this.assetClosingAmount],
      ["asset-index", this.assetIndex],
      ["close-rewards", this.closeRewards],
      ["closing-amount", this.closingAmount],
      ["confirmed-round", this.confirmedRound],
      [
        "global-state-delta",
        typeof this.globalStateDelta !== "undefined" ? this.globalStateDelta.map((v2) => v2.toEncodingData()) : void 0
      ],
      [
        "inner-txns",
        typeof this.innerTxns !== "undefined" ? this.innerTxns.map((v2) => v2.toEncodingData()) : void 0
      ],
      [
        "local-state-delta",
        typeof this.localStateDelta !== "undefined" ? this.localStateDelta.map((v2) => v2.toEncodingData()) : void 0
      ],
      ["logs", this.logs],
      ["receiver-rewards", this.receiverRewards],
      ["sender-rewards", this.senderRewards]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded PendingTransactionResponse: ${data}`);
    }
    return new _PendingTransactionResponse({
      poolError: data.get("pool-error"),
      txn: SignedTransaction.fromEncodingData(data.get("txn") ?? /* @__PURE__ */ new Map()),
      applicationIndex: data.get("application-index"),
      assetClosingAmount: data.get("asset-closing-amount"),
      assetIndex: data.get("asset-index"),
      closeRewards: data.get("close-rewards"),
      closingAmount: data.get("closing-amount"),
      confirmedRound: data.get("confirmed-round"),
      globalStateDelta: typeof data.get("global-state-delta") !== "undefined" ? data.get("global-state-delta").map((v2) => EvalDeltaKeyValue.fromEncodingData(v2)) : void 0,
      innerTxns: typeof data.get("inner-txns") !== "undefined" ? data.get("inner-txns").map((v2) => _PendingTransactionResponse.fromEncodingData(v2)) : void 0,
      localStateDelta: typeof data.get("local-state-delta") !== "undefined" ? data.get("local-state-delta").map((v2) => AccountStateDelta.fromEncodingData(v2)) : void 0,
      logs: data.get("logs"),
      receiverRewards: data.get("receiver-rewards"),
      senderRewards: data.get("sender-rewards")
    });
  }
};
var PendingTransactionsResponse = class _PendingTransactionsResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "top-transactions",
        valueSchema: new ArraySchema(SignedTransaction.encodingSchema),
        omitEmpty: true
      }, {
        key: "total-transactions",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `PendingTransactionsResponse` object.
   * @param topTransactions - An array of signed transaction objects.
   * @param totalTransactions - Total number of transactions in the pool.
   */
  constructor({ topTransactions, totalTransactions }) {
    this.topTransactions = topTransactions;
    this.totalTransactions = ensureSafeInteger(totalTransactions);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _PendingTransactionsResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["top-transactions", this.topTransactions.map((v2) => v2.toEncodingData())],
      ["total-transactions", this.totalTransactions]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded PendingTransactionsResponse: ${data}`);
    }
    return new _PendingTransactionsResponse({
      topTransactions: (data.get("top-transactions") ?? []).map((v2) => SignedTransaction.fromEncodingData(v2)),
      totalTransactions: data.get("total-transactions")
    });
  }
};
var PostTransactionsResponse = class _PostTransactionsResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "txId",
        valueSchema: new StringSchema(),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `PostTransactionsResponse` object.
   * @param txid - encoding of the transaction hash.
   */
  constructor({ txid }) {
    this.txid = txid;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _PostTransactionsResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([["txId", this.txid]]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded PostTransactionsResponse: ${data}`);
    }
    return new _PostTransactionsResponse({
      txid: data.get("txId")
    });
  }
};
var ScratchChange = class _ScratchChange {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "new-value",
        valueSchema: AvmValue.encodingSchema,
        omitEmpty: true
      }, { key: "slot", valueSchema: new Uint64Schema(), omitEmpty: true });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `ScratchChange` object.
   * @param newValue - Represents an AVM value.
   * @param slot - The scratch slot written.
   */
  constructor({ newValue, slot }) {
    this.newValue = newValue;
    this.slot = ensureSafeInteger(slot);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _ScratchChange.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["new-value", this.newValue.toEncodingData()],
      ["slot", this.slot]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded ScratchChange: ${data}`);
    }
    return new _ScratchChange({
      newValue: AvmValue.fromEncodingData(data.get("new-value") ?? /* @__PURE__ */ new Map()),
      slot: data.get("slot")
    });
  }
};
var SimulateInitialStates = class _SimulateInitialStates {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "app-initial-states",
        valueSchema: new OptionalSchema(new ArraySchema(ApplicationInitialStates.encodingSchema)),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `SimulateInitialStates` object.
   * @param appInitialStates - The initial states of accessed application before simulation. The order of this
   * array is arbitrary.
   */
  constructor({ appInitialStates }) {
    this.appInitialStates = appInitialStates;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _SimulateInitialStates.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      [
        "app-initial-states",
        typeof this.appInitialStates !== "undefined" ? this.appInitialStates.map((v2) => v2.toEncodingData()) : void 0
      ]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded SimulateInitialStates: ${data}`);
    }
    return new _SimulateInitialStates({
      appInitialStates: typeof data.get("app-initial-states") !== "undefined" ? data.get("app-initial-states").map((v2) => ApplicationInitialStates.fromEncodingData(v2)) : void 0
    });
  }
};
var SimulateRequest = class _SimulateRequest {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "txn-groups",
        valueSchema: new ArraySchema(SimulateRequestTransactionGroup.encodingSchema),
        omitEmpty: true
      }, {
        key: "allow-empty-signatures",
        valueSchema: new OptionalSchema(new BooleanSchema()),
        omitEmpty: true
      }, {
        key: "allow-more-logging",
        valueSchema: new OptionalSchema(new BooleanSchema()),
        omitEmpty: true
      }, {
        key: "allow-unnamed-resources",
        valueSchema: new OptionalSchema(new BooleanSchema()),
        omitEmpty: true
      }, {
        key: "exec-trace-config",
        valueSchema: new OptionalSchema(SimulateTraceConfig.encodingSchema),
        omitEmpty: true
      }, {
        key: "extra-opcode-budget",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "fix-signers",
        valueSchema: new OptionalSchema(new BooleanSchema()),
        omitEmpty: true
      }, {
        key: "round",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `SimulateRequest` object.
   * @param txnGroups - The transaction groups to simulate.
   * @param allowEmptySignatures - Allows transactions without signatures to be simulated as if they had correct
   * signatures.
   * @param allowMoreLogging - Lifts limits on log opcode usage during simulation.
   * @param allowUnnamedResources - Allows access to unnamed resources during simulation.
   * @param execTraceConfig - An object that configures simulation execution trace.
   * @param extraOpcodeBudget - Applies extra opcode budget during simulation for each transaction group.
   * @param fixSigners - If true, signers for transactions that are missing signatures will be fixed
   * during evaluation.
   * @param round - If provided, specifies the round preceding the simulation. State changes through
   * this round will be used to run this simulation. Usually only the 4 most recent
   * rounds will be available (controlled by the node config value MaxAcctLookback).
   * If not specified, defaults to the latest available round.
   */
  constructor({ txnGroups, allowEmptySignatures, allowMoreLogging, allowUnnamedResources, execTraceConfig, extraOpcodeBudget, fixSigners, round }) {
    this.txnGroups = txnGroups;
    this.allowEmptySignatures = allowEmptySignatures;
    this.allowMoreLogging = allowMoreLogging;
    this.allowUnnamedResources = allowUnnamedResources;
    this.execTraceConfig = execTraceConfig;
    this.extraOpcodeBudget = typeof extraOpcodeBudget === "undefined" ? void 0 : ensureSafeInteger(extraOpcodeBudget);
    this.fixSigners = fixSigners;
    this.round = typeof round === "undefined" ? void 0 : ensureBigInt(round);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _SimulateRequest.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["txn-groups", this.txnGroups.map((v2) => v2.toEncodingData())],
      ["allow-empty-signatures", this.allowEmptySignatures],
      ["allow-more-logging", this.allowMoreLogging],
      ["allow-unnamed-resources", this.allowUnnamedResources],
      [
        "exec-trace-config",
        typeof this.execTraceConfig !== "undefined" ? this.execTraceConfig.toEncodingData() : void 0
      ],
      ["extra-opcode-budget", this.extraOpcodeBudget],
      ["fix-signers", this.fixSigners],
      ["round", this.round]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded SimulateRequest: ${data}`);
    }
    return new _SimulateRequest({
      txnGroups: (data.get("txn-groups") ?? []).map((v2) => SimulateRequestTransactionGroup.fromEncodingData(v2)),
      allowEmptySignatures: data.get("allow-empty-signatures"),
      allowMoreLogging: data.get("allow-more-logging"),
      allowUnnamedResources: data.get("allow-unnamed-resources"),
      execTraceConfig: typeof data.get("exec-trace-config") !== "undefined" ? SimulateTraceConfig.fromEncodingData(data.get("exec-trace-config")) : void 0,
      extraOpcodeBudget: data.get("extra-opcode-budget"),
      fixSigners: data.get("fix-signers"),
      round: data.get("round")
    });
  }
};
var SimulateRequestTransactionGroup = class _SimulateRequestTransactionGroup {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "txns",
        valueSchema: new ArraySchema(SignedTransaction.encodingSchema),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `SimulateRequestTransactionGroup` object.
   * @param txns - An atomic transaction group.
   */
  constructor({ txns }) {
    this.txns = txns;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _SimulateRequestTransactionGroup.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["txns", this.txns.map((v2) => v2.toEncodingData())]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded SimulateRequestTransactionGroup: ${data}`);
    }
    return new _SimulateRequestTransactionGroup({
      txns: (data.get("txns") ?? []).map((v2) => SignedTransaction.fromEncodingData(v2))
    });
  }
};
var SimulateResponse = class _SimulateResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "last-round", valueSchema: new Uint64Schema(), omitEmpty: true }, {
        key: "txn-groups",
        valueSchema: new ArraySchema(SimulateTransactionGroupResult.encodingSchema),
        omitEmpty: true
      }, { key: "version", valueSchema: new Uint64Schema(), omitEmpty: true }, {
        key: "eval-overrides",
        valueSchema: new OptionalSchema(SimulationEvalOverrides.encodingSchema),
        omitEmpty: true
      }, {
        key: "exec-trace-config",
        valueSchema: new OptionalSchema(SimulateTraceConfig.encodingSchema),
        omitEmpty: true
      }, {
        key: "initial-states",
        valueSchema: new OptionalSchema(SimulateInitialStates.encodingSchema),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `SimulateResponse` object.
   * @param lastRound - The round immediately preceding this simulation. State changes through this
   * round were used to run this simulation.
   * @param txnGroups - A result object for each transaction group that was simulated.
   * @param version - The version of this response object.
   * @param evalOverrides - The set of parameters and limits override during simulation. If this set of
   * parameters is present, then evaluation parameters may differ from standard
   * evaluation in certain ways.
   * @param execTraceConfig - An object that configures simulation execution trace.
   * @param initialStates - Initial states of resources that were accessed during simulation.
   */
  constructor({ lastRound, txnGroups, version, evalOverrides, execTraceConfig, initialStates }) {
    this.lastRound = ensureBigInt(lastRound);
    this.txnGroups = txnGroups;
    this.version = ensureSafeInteger(version);
    this.evalOverrides = evalOverrides;
    this.execTraceConfig = execTraceConfig;
    this.initialStates = initialStates;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _SimulateResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["last-round", this.lastRound],
      ["txn-groups", this.txnGroups.map((v2) => v2.toEncodingData())],
      ["version", this.version],
      [
        "eval-overrides",
        typeof this.evalOverrides !== "undefined" ? this.evalOverrides.toEncodingData() : void 0
      ],
      [
        "exec-trace-config",
        typeof this.execTraceConfig !== "undefined" ? this.execTraceConfig.toEncodingData() : void 0
      ],
      [
        "initial-states",
        typeof this.initialStates !== "undefined" ? this.initialStates.toEncodingData() : void 0
      ]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded SimulateResponse: ${data}`);
    }
    return new _SimulateResponse({
      lastRound: data.get("last-round"),
      txnGroups: (data.get("txn-groups") ?? []).map((v2) => SimulateTransactionGroupResult.fromEncodingData(v2)),
      version: data.get("version"),
      evalOverrides: typeof data.get("eval-overrides") !== "undefined" ? SimulationEvalOverrides.fromEncodingData(data.get("eval-overrides")) : void 0,
      execTraceConfig: typeof data.get("exec-trace-config") !== "undefined" ? SimulateTraceConfig.fromEncodingData(data.get("exec-trace-config")) : void 0,
      initialStates: typeof data.get("initial-states") !== "undefined" ? SimulateInitialStates.fromEncodingData(data.get("initial-states")) : void 0
    });
  }
};
var SimulateTraceConfig = class _SimulateTraceConfig {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "enable",
        valueSchema: new OptionalSchema(new BooleanSchema()),
        omitEmpty: true
      }, {
        key: "scratch-change",
        valueSchema: new OptionalSchema(new BooleanSchema()),
        omitEmpty: true
      }, {
        key: "stack-change",
        valueSchema: new OptionalSchema(new BooleanSchema()),
        omitEmpty: true
      }, {
        key: "state-change",
        valueSchema: new OptionalSchema(new BooleanSchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `SimulateTraceConfig` object.
   * @param enable - A boolean option for opting in execution trace features simulation endpoint.
   * @param scratchChange - A boolean option enabling returning scratch slot changes together with execution
   * trace during simulation.
   * @param stackChange - A boolean option enabling returning stack changes together with execution trace
   * during simulation.
   * @param stateChange - A boolean option enabling returning application state changes (global, local,
   * and box changes) with the execution trace during simulation.
   */
  constructor({ enable, scratchChange, stackChange, stateChange }) {
    this.enable = enable;
    this.scratchChange = scratchChange;
    this.stackChange = stackChange;
    this.stateChange = stateChange;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _SimulateTraceConfig.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["enable", this.enable],
      ["scratch-change", this.scratchChange],
      ["stack-change", this.stackChange],
      ["state-change", this.stateChange]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded SimulateTraceConfig: ${data}`);
    }
    return new _SimulateTraceConfig({
      enable: data.get("enable"),
      scratchChange: data.get("scratch-change"),
      stackChange: data.get("stack-change"),
      stateChange: data.get("state-change")
    });
  }
};
var SimulateTransactionGroupResult = class _SimulateTransactionGroupResult {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "txn-results",
        valueSchema: new ArraySchema(SimulateTransactionResult.encodingSchema),
        omitEmpty: true
      }, {
        key: "app-budget-added",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "app-budget-consumed",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "failed-at",
        valueSchema: new OptionalSchema(new ArraySchema(new Uint64Schema())),
        omitEmpty: true
      }, {
        key: "failure-message",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "unnamed-resources-accessed",
        valueSchema: new OptionalSchema(SimulateUnnamedResourcesAccessed.encodingSchema),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `SimulateTransactionGroupResult` object.
   * @param txnResults - Simulation result for individual transactions
   * @param appBudgetAdded - Total budget added during execution of app calls in the transaction group.
   * @param appBudgetConsumed - Total budget consumed during execution of app calls in the transaction group.
   * @param failedAt - If present, indicates which transaction in this group caused the failure. This
   * array represents the path to the failing transaction. Indexes are zero based,
   * the first element indicates the top-level transaction, and successive elements
   * indicate deeper inner transactions.
   * @param failureMessage - If present, indicates that the transaction group failed and specifies why that
   * happened
   * @param unnamedResourcesAccessed - These are resources that were accessed by this group that would normally have
   * caused failure, but were allowed in simulation. Depending on where this object
   * is in the response, the unnamed resources it contains may or may not qualify for
   * group resource sharing. If this is a field in SimulateTransactionGroupResult,
   * the resources do qualify, but if this is a field in SimulateTransactionResult,
   * they do not qualify. In order to make this group valid for actual submission,
   * resources that qualify for group sharing can be made available by any
   * transaction of the group; otherwise, resources must be placed in the same
   * transaction which accessed them.
   */
  constructor({ txnResults, appBudgetAdded, appBudgetConsumed, failedAt, failureMessage, unnamedResourcesAccessed }) {
    this.txnResults = txnResults;
    this.appBudgetAdded = typeof appBudgetAdded === "undefined" ? void 0 : ensureSafeInteger(appBudgetAdded);
    this.appBudgetConsumed = typeof appBudgetConsumed === "undefined" ? void 0 : ensureSafeInteger(appBudgetConsumed);
    this.failedAt = typeof failedAt === "undefined" ? void 0 : failedAt.map(ensureSafeInteger);
    this.failureMessage = failureMessage;
    this.unnamedResourcesAccessed = unnamedResourcesAccessed;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _SimulateTransactionGroupResult.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["txn-results", this.txnResults.map((v2) => v2.toEncodingData())],
      ["app-budget-added", this.appBudgetAdded],
      ["app-budget-consumed", this.appBudgetConsumed],
      ["failed-at", this.failedAt],
      ["failure-message", this.failureMessage],
      [
        "unnamed-resources-accessed",
        typeof this.unnamedResourcesAccessed !== "undefined" ? this.unnamedResourcesAccessed.toEncodingData() : void 0
      ]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded SimulateTransactionGroupResult: ${data}`);
    }
    return new _SimulateTransactionGroupResult({
      txnResults: (data.get("txn-results") ?? []).map((v2) => SimulateTransactionResult.fromEncodingData(v2)),
      appBudgetAdded: data.get("app-budget-added"),
      appBudgetConsumed: data.get("app-budget-consumed"),
      failedAt: data.get("failed-at"),
      failureMessage: data.get("failure-message"),
      unnamedResourcesAccessed: typeof data.get("unnamed-resources-accessed") !== "undefined" ? SimulateUnnamedResourcesAccessed.fromEncodingData(data.get("unnamed-resources-accessed")) : void 0
    });
  }
};
var SimulateTransactionResult = class _SimulateTransactionResult {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "txn-result",
        valueSchema: PendingTransactionResponse.encodingSchema,
        omitEmpty: true
      }, {
        key: "app-budget-consumed",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "exec-trace",
        valueSchema: new OptionalSchema(SimulationTransactionExecTrace.encodingSchema),
        omitEmpty: true
      }, {
        key: "fixed-signer",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "logic-sig-budget-consumed",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "unnamed-resources-accessed",
        valueSchema: new OptionalSchema(SimulateUnnamedResourcesAccessed.encodingSchema),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `SimulateTransactionResult` object.
   * @param txnResult - Details about a pending transaction. If the transaction was recently confirmed,
   * includes confirmation details like the round and reward details.
   * @param appBudgetConsumed - Budget used during execution of an app call transaction. This value includes
   * budged used by inner app calls spawned by this transaction.
   * @param execTrace - The execution trace of calling an app or a logic sig, containing the inner app
   * call trace in a recursive way.
   * @param fixedSigner - The account that needed to sign this transaction when no signature was provided
   * and the provided signer was incorrect.
   * @param logicSigBudgetConsumed - Budget used during execution of a logic sig transaction.
   * @param unnamedResourcesAccessed - These are resources that were accessed by this group that would normally have
   * caused failure, but were allowed in simulation. Depending on where this object
   * is in the response, the unnamed resources it contains may or may not qualify for
   * group resource sharing. If this is a field in SimulateTransactionGroupResult,
   * the resources do qualify, but if this is a field in SimulateTransactionResult,
   * they do not qualify. In order to make this group valid for actual submission,
   * resources that qualify for group sharing can be made available by any
   * transaction of the group; otherwise, resources must be placed in the same
   * transaction which accessed them.
   */
  constructor({ txnResult, appBudgetConsumed, execTrace, fixedSigner, logicSigBudgetConsumed, unnamedResourcesAccessed }) {
    this.txnResult = txnResult;
    this.appBudgetConsumed = typeof appBudgetConsumed === "undefined" ? void 0 : ensureSafeInteger(appBudgetConsumed);
    this.execTrace = execTrace;
    this.fixedSigner = typeof fixedSigner === "string" ? Address.fromString(fixedSigner) : fixedSigner;
    this.logicSigBudgetConsumed = typeof logicSigBudgetConsumed === "undefined" ? void 0 : ensureSafeInteger(logicSigBudgetConsumed);
    this.unnamedResourcesAccessed = unnamedResourcesAccessed;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _SimulateTransactionResult.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["txn-result", this.txnResult.toEncodingData()],
      ["app-budget-consumed", this.appBudgetConsumed],
      [
        "exec-trace",
        typeof this.execTrace !== "undefined" ? this.execTrace.toEncodingData() : void 0
      ],
      [
        "fixed-signer",
        typeof this.fixedSigner !== "undefined" ? this.fixedSigner.toString() : void 0
      ],
      ["logic-sig-budget-consumed", this.logicSigBudgetConsumed],
      [
        "unnamed-resources-accessed",
        typeof this.unnamedResourcesAccessed !== "undefined" ? this.unnamedResourcesAccessed.toEncodingData() : void 0
      ]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded SimulateTransactionResult: ${data}`);
    }
    return new _SimulateTransactionResult({
      txnResult: PendingTransactionResponse.fromEncodingData(data.get("txn-result") ?? /* @__PURE__ */ new Map()),
      appBudgetConsumed: data.get("app-budget-consumed"),
      execTrace: typeof data.get("exec-trace") !== "undefined" ? SimulationTransactionExecTrace.fromEncodingData(data.get("exec-trace")) : void 0,
      fixedSigner: data.get("fixed-signer"),
      logicSigBudgetConsumed: data.get("logic-sig-budget-consumed"),
      unnamedResourcesAccessed: typeof data.get("unnamed-resources-accessed") !== "undefined" ? SimulateUnnamedResourcesAccessed.fromEncodingData(data.get("unnamed-resources-accessed")) : void 0
    });
  }
};
var SimulateUnnamedResourcesAccessed = class _SimulateUnnamedResourcesAccessed {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "accounts",
        valueSchema: new OptionalSchema(new ArraySchema(new StringSchema())),
        omitEmpty: true
      }, {
        key: "app-locals",
        valueSchema: new OptionalSchema(new ArraySchema(ApplicationLocalReference.encodingSchema)),
        omitEmpty: true
      }, {
        key: "apps",
        valueSchema: new OptionalSchema(new ArraySchema(new Uint64Schema())),
        omitEmpty: true
      }, {
        key: "asset-holdings",
        valueSchema: new OptionalSchema(new ArraySchema(AssetHoldingReference.encodingSchema)),
        omitEmpty: true
      }, {
        key: "assets",
        valueSchema: new OptionalSchema(new ArraySchema(new Uint64Schema())),
        omitEmpty: true
      }, {
        key: "boxes",
        valueSchema: new OptionalSchema(new ArraySchema(BoxReference.encodingSchema)),
        omitEmpty: true
      }, {
        key: "extra-box-refs",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `SimulateUnnamedResourcesAccessed` object.
   * @param accounts - The unnamed accounts that were referenced. The order of this array is arbitrary.
   * @param appLocals - The unnamed application local states that were referenced. The order of this
   * array is arbitrary.
   * @param apps - The unnamed applications that were referenced. The order of this array is
   * arbitrary.
   * @param assetHoldings - The unnamed asset holdings that were referenced. The order of this array is
   * arbitrary.
   * @param assets - The unnamed assets that were referenced. The order of this array is arbitrary.
   * @param boxes - The unnamed boxes that were referenced. The order of this array is arbitrary.
   * @param extraBoxRefs - The number of extra box references used to increase the IO budget. This is in
   * addition to the references defined in the input transaction group and any
   * referenced to unnamed boxes.
   */
  constructor({ accounts, appLocals, apps, assetHoldings, assets, boxes, extraBoxRefs }) {
    this.accounts = typeof accounts !== "undefined" ? accounts.map((addr) => typeof addr === "string" ? Address.fromString(addr) : addr) : void 0;
    this.appLocals = appLocals;
    this.apps = typeof apps === "undefined" ? void 0 : apps.map(ensureBigInt);
    this.assetHoldings = assetHoldings;
    this.assets = typeof assets === "undefined" ? void 0 : assets.map(ensureBigInt);
    this.boxes = boxes;
    this.extraBoxRefs = typeof extraBoxRefs === "undefined" ? void 0 : ensureSafeInteger(extraBoxRefs);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _SimulateUnnamedResourcesAccessed.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      [
        "accounts",
        typeof this.accounts !== "undefined" ? this.accounts.map((v2) => v2.toString()) : void 0
      ],
      [
        "app-locals",
        typeof this.appLocals !== "undefined" ? this.appLocals.map((v2) => v2.toEncodingData()) : void 0
      ],
      ["apps", this.apps],
      [
        "asset-holdings",
        typeof this.assetHoldings !== "undefined" ? this.assetHoldings.map((v2) => v2.toEncodingData()) : void 0
      ],
      ["assets", this.assets],
      [
        "boxes",
        typeof this.boxes !== "undefined" ? this.boxes.map((v2) => v2.toEncodingData()) : void 0
      ],
      ["extra-box-refs", this.extraBoxRefs]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded SimulateUnnamedResourcesAccessed: ${data}`);
    }
    return new _SimulateUnnamedResourcesAccessed({
      accounts: data.get("accounts"),
      appLocals: typeof data.get("app-locals") !== "undefined" ? data.get("app-locals").map((v2) => ApplicationLocalReference.fromEncodingData(v2)) : void 0,
      apps: data.get("apps"),
      assetHoldings: typeof data.get("asset-holdings") !== "undefined" ? data.get("asset-holdings").map((v2) => AssetHoldingReference.fromEncodingData(v2)) : void 0,
      assets: data.get("assets"),
      boxes: typeof data.get("boxes") !== "undefined" ? data.get("boxes").map((v2) => BoxReference.fromEncodingData(v2)) : void 0,
      extraBoxRefs: data.get("extra-box-refs")
    });
  }
};
var SimulationEvalOverrides = class _SimulationEvalOverrides {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "allow-empty-signatures",
        valueSchema: new OptionalSchema(new BooleanSchema()),
        omitEmpty: true
      }, {
        key: "allow-unnamed-resources",
        valueSchema: new OptionalSchema(new BooleanSchema()),
        omitEmpty: true
      }, {
        key: "extra-opcode-budget",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "fix-signers",
        valueSchema: new OptionalSchema(new BooleanSchema()),
        omitEmpty: true
      }, {
        key: "max-log-calls",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "max-log-size",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `SimulationEvalOverrides` object.
   * @param allowEmptySignatures - If true, transactions without signatures are allowed and simulated as if they
   * were properly signed.
   * @param allowUnnamedResources - If true, allows access to unnamed resources during simulation.
   * @param extraOpcodeBudget - The extra opcode budget added to each transaction group during simulation
   * @param fixSigners - If true, signers for transactions that are missing signatures will be fixed
   * during evaluation.
   * @param maxLogCalls - The maximum log calls one can make during simulation
   * @param maxLogSize - The maximum byte number to log during simulation
   */
  constructor({ allowEmptySignatures, allowUnnamedResources, extraOpcodeBudget, fixSigners, maxLogCalls, maxLogSize }) {
    this.allowEmptySignatures = allowEmptySignatures;
    this.allowUnnamedResources = allowUnnamedResources;
    this.extraOpcodeBudget = typeof extraOpcodeBudget === "undefined" ? void 0 : ensureSafeInteger(extraOpcodeBudget);
    this.fixSigners = fixSigners;
    this.maxLogCalls = typeof maxLogCalls === "undefined" ? void 0 : ensureSafeInteger(maxLogCalls);
    this.maxLogSize = typeof maxLogSize === "undefined" ? void 0 : ensureSafeInteger(maxLogSize);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _SimulationEvalOverrides.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["allow-empty-signatures", this.allowEmptySignatures],
      ["allow-unnamed-resources", this.allowUnnamedResources],
      ["extra-opcode-budget", this.extraOpcodeBudget],
      ["fix-signers", this.fixSigners],
      ["max-log-calls", this.maxLogCalls],
      ["max-log-size", this.maxLogSize]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded SimulationEvalOverrides: ${data}`);
    }
    return new _SimulationEvalOverrides({
      allowEmptySignatures: data.get("allow-empty-signatures"),
      allowUnnamedResources: data.get("allow-unnamed-resources"),
      extraOpcodeBudget: data.get("extra-opcode-budget"),
      fixSigners: data.get("fix-signers"),
      maxLogCalls: data.get("max-log-calls"),
      maxLogSize: data.get("max-log-size")
    });
  }
};
var SimulationOpcodeTraceUnit = class _SimulationOpcodeTraceUnit {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "pc", valueSchema: new Uint64Schema(), omitEmpty: true }, {
        key: "scratch-changes",
        valueSchema: new OptionalSchema(new ArraySchema(ScratchChange.encodingSchema)),
        omitEmpty: true
      }, {
        key: "spawned-inners",
        valueSchema: new OptionalSchema(new ArraySchema(new Uint64Schema())),
        omitEmpty: true
      }, {
        key: "stack-additions",
        valueSchema: new OptionalSchema(new ArraySchema(AvmValue.encodingSchema)),
        omitEmpty: true
      }, {
        key: "stack-pop-count",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "state-changes",
        valueSchema: new OptionalSchema(new ArraySchema(ApplicationStateOperation.encodingSchema)),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `SimulationOpcodeTraceUnit` object.
   * @param pc - The program counter of the current opcode being evaluated.
   * @param scratchChanges - The writes into scratch slots.
   * @param spawnedInners - The indexes of the traces for inner transactions spawned by this opcode, if any.
   * @param stackAdditions - The values added by this opcode to the stack.
   * @param stackPopCount - The number of deleted stack values by this opcode.
   * @param stateChanges - The operations against the current application's states.
   */
  constructor({ pc, scratchChanges, spawnedInners, stackAdditions, stackPopCount, stateChanges }) {
    this.pc = ensureSafeInteger(pc);
    this.scratchChanges = scratchChanges;
    this.spawnedInners = typeof spawnedInners === "undefined" ? void 0 : spawnedInners.map(ensureSafeInteger);
    this.stackAdditions = stackAdditions;
    this.stackPopCount = typeof stackPopCount === "undefined" ? void 0 : ensureSafeInteger(stackPopCount);
    this.stateChanges = stateChanges;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _SimulationOpcodeTraceUnit.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["pc", this.pc],
      [
        "scratch-changes",
        typeof this.scratchChanges !== "undefined" ? this.scratchChanges.map((v2) => v2.toEncodingData()) : void 0
      ],
      ["spawned-inners", this.spawnedInners],
      [
        "stack-additions",
        typeof this.stackAdditions !== "undefined" ? this.stackAdditions.map((v2) => v2.toEncodingData()) : void 0
      ],
      ["stack-pop-count", this.stackPopCount],
      [
        "state-changes",
        typeof this.stateChanges !== "undefined" ? this.stateChanges.map((v2) => v2.toEncodingData()) : void 0
      ]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded SimulationOpcodeTraceUnit: ${data}`);
    }
    return new _SimulationOpcodeTraceUnit({
      pc: data.get("pc"),
      scratchChanges: typeof data.get("scratch-changes") !== "undefined" ? data.get("scratch-changes").map((v2) => ScratchChange.fromEncodingData(v2)) : void 0,
      spawnedInners: data.get("spawned-inners"),
      stackAdditions: typeof data.get("stack-additions") !== "undefined" ? data.get("stack-additions").map((v2) => AvmValue.fromEncodingData(v2)) : void 0,
      stackPopCount: data.get("stack-pop-count"),
      stateChanges: typeof data.get("state-changes") !== "undefined" ? data.get("state-changes").map((v2) => ApplicationStateOperation.fromEncodingData(v2)) : void 0
    });
  }
};
var SimulationTransactionExecTrace = class _SimulationTransactionExecTrace {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "approval-program-hash",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      }, {
        key: "approval-program-trace",
        valueSchema: new OptionalSchema(new ArraySchema(SimulationOpcodeTraceUnit.encodingSchema)),
        omitEmpty: true
      }, {
        key: "clear-state-program-hash",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      }, {
        key: "clear-state-program-trace",
        valueSchema: new OptionalSchema(new ArraySchema(SimulationOpcodeTraceUnit.encodingSchema)),
        omitEmpty: true
      }, {
        key: "clear-state-rollback",
        valueSchema: new OptionalSchema(new BooleanSchema()),
        omitEmpty: true
      }, {
        key: "clear-state-rollback-error",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "inner-trace",
        valueSchema: new OptionalSchema(new ArraySchema(_SimulationTransactionExecTrace.encodingSchema)),
        omitEmpty: true
      }, {
        key: "logic-sig-hash",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      }, {
        key: "logic-sig-trace",
        valueSchema: new OptionalSchema(new ArraySchema(SimulationOpcodeTraceUnit.encodingSchema)),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `SimulationTransactionExecTrace` object.
   * @param approvalProgramHash - SHA512_256 hash digest of the approval program executed in transaction.
   * @param approvalProgramTrace - Program trace that contains a trace of opcode effects in an approval program.
   * @param clearStateProgramHash - SHA512_256 hash digest of the clear state program executed in transaction.
   * @param clearStateProgramTrace - Program trace that contains a trace of opcode effects in a clear state program.
   * @param clearStateRollback - If true, indicates that the clear state program failed and any persistent state
   * changes it produced should be reverted once the program exits.
   * @param clearStateRollbackError - The error message explaining why the clear state program failed. This field will
   * only be populated if clear-state-rollback is true and the failure was due to an
   * execution error.
   * @param innerTrace - An array of SimulationTransactionExecTrace representing the execution trace of
   * any inner transactions executed.
   * @param logicSigHash - SHA512_256 hash digest of the logic sig executed in transaction.
   * @param logicSigTrace - Program trace that contains a trace of opcode effects in a logic sig.
   */
  constructor({ approvalProgramHash, approvalProgramTrace, clearStateProgramHash, clearStateProgramTrace, clearStateRollback, clearStateRollbackError, innerTrace, logicSigHash, logicSigTrace }) {
    this.approvalProgramHash = typeof approvalProgramHash === "string" ? base64ToBytes(approvalProgramHash) : approvalProgramHash;
    this.approvalProgramTrace = approvalProgramTrace;
    this.clearStateProgramHash = typeof clearStateProgramHash === "string" ? base64ToBytes(clearStateProgramHash) : clearStateProgramHash;
    this.clearStateProgramTrace = clearStateProgramTrace;
    this.clearStateRollback = clearStateRollback;
    this.clearStateRollbackError = clearStateRollbackError;
    this.innerTrace = innerTrace;
    this.logicSigHash = typeof logicSigHash === "string" ? base64ToBytes(logicSigHash) : logicSigHash;
    this.logicSigTrace = logicSigTrace;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _SimulationTransactionExecTrace.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["approval-program-hash", this.approvalProgramHash],
      [
        "approval-program-trace",
        typeof this.approvalProgramTrace !== "undefined" ? this.approvalProgramTrace.map((v2) => v2.toEncodingData()) : void 0
      ],
      ["clear-state-program-hash", this.clearStateProgramHash],
      [
        "clear-state-program-trace",
        typeof this.clearStateProgramTrace !== "undefined" ? this.clearStateProgramTrace.map((v2) => v2.toEncodingData()) : void 0
      ],
      ["clear-state-rollback", this.clearStateRollback],
      ["clear-state-rollback-error", this.clearStateRollbackError],
      [
        "inner-trace",
        typeof this.innerTrace !== "undefined" ? this.innerTrace.map((v2) => v2.toEncodingData()) : void 0
      ],
      ["logic-sig-hash", this.logicSigHash],
      [
        "logic-sig-trace",
        typeof this.logicSigTrace !== "undefined" ? this.logicSigTrace.map((v2) => v2.toEncodingData()) : void 0
      ]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded SimulationTransactionExecTrace: ${data}`);
    }
    return new _SimulationTransactionExecTrace({
      approvalProgramHash: data.get("approval-program-hash"),
      approvalProgramTrace: typeof data.get("approval-program-trace") !== "undefined" ? data.get("approval-program-trace").map((v2) => SimulationOpcodeTraceUnit.fromEncodingData(v2)) : void 0,
      clearStateProgramHash: data.get("clear-state-program-hash"),
      clearStateProgramTrace: typeof data.get("clear-state-program-trace") !== "undefined" ? data.get("clear-state-program-trace").map((v2) => SimulationOpcodeTraceUnit.fromEncodingData(v2)) : void 0,
      clearStateRollback: data.get("clear-state-rollback"),
      clearStateRollbackError: data.get("clear-state-rollback-error"),
      innerTrace: typeof data.get("inner-trace") !== "undefined" ? data.get("inner-trace").map((v2) => _SimulationTransactionExecTrace.fromEncodingData(v2)) : void 0,
      logicSigHash: data.get("logic-sig-hash"),
      logicSigTrace: typeof data.get("logic-sig-trace") !== "undefined" ? data.get("logic-sig-trace").map((v2) => SimulationOpcodeTraceUnit.fromEncodingData(v2)) : void 0
    });
  }
};
var StateProof2 = class _StateProof {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "Message",
        valueSchema: StateProofMessage2.encodingSchema,
        omitEmpty: true
      }, {
        key: "StateProof",
        valueSchema: new ByteArraySchema(),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `StateProof` object.
   * @param message - Represents the message that the state proofs are attesting to.
   * @param stateproof - The encoded StateProof for the message.
   */
  constructor({ message, stateproof }) {
    this.message = message;
    this.stateproof = typeof stateproof === "string" ? base64ToBytes(stateproof) : stateproof;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _StateProof.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["Message", this.message.toEncodingData()],
      ["StateProof", this.stateproof]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded StateProof: ${data}`);
    }
    return new _StateProof({
      message: StateProofMessage2.fromEncodingData(data.get("Message") ?? /* @__PURE__ */ new Map()),
      stateproof: data.get("StateProof")
    });
  }
};
var StateProofMessage2 = class _StateProofMessage {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "BlockHeadersCommitment",
        valueSchema: new ByteArraySchema(),
        omitEmpty: true
      }, {
        key: "FirstAttestedRound",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "LastAttestedRound",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "LnProvenWeight",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "VotersCommitment",
        valueSchema: new ByteArraySchema(),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `StateProofMessage` object.
   * @param blockheaderscommitment - The vector commitment root on all light block headers within a state proof
   * interval.
   * @param firstattestedround - The first round the message attests to.
   * @param lastattestedround - The last round the message attests to.
   * @param lnprovenweight - An integer value representing the natural log of the proven weight with 16 bits
   * of precision. This value would be used to verify the next state proof.
   * @param voterscommitment - The vector commitment root of the top N accounts to sign the next StateProof.
   */
  constructor({ blockheaderscommitment, firstattestedround, lastattestedround, lnprovenweight, voterscommitment }) {
    this.blockheaderscommitment = typeof blockheaderscommitment === "string" ? base64ToBytes(blockheaderscommitment) : blockheaderscommitment;
    this.firstattestedround = ensureBigInt(firstattestedround);
    this.lastattestedround = ensureBigInt(lastattestedround);
    this.lnprovenweight = ensureBigInt(lnprovenweight);
    this.voterscommitment = typeof voterscommitment === "string" ? base64ToBytes(voterscommitment) : voterscommitment;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _StateProofMessage.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["BlockHeadersCommitment", this.blockheaderscommitment],
      ["FirstAttestedRound", this.firstattestedround],
      ["LastAttestedRound", this.lastattestedround],
      ["LnProvenWeight", this.lnprovenweight],
      ["VotersCommitment", this.voterscommitment]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded StateProofMessage: ${data}`);
    }
    return new _StateProofMessage({
      blockheaderscommitment: data.get("BlockHeadersCommitment"),
      firstattestedround: data.get("FirstAttestedRound"),
      lastattestedround: data.get("LastAttestedRound"),
      lnprovenweight: data.get("LnProvenWeight"),
      voterscommitment: data.get("VotersCommitment")
    });
  }
};
var SupplyResponse = class _SupplyResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "current_round",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "online-money",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, { key: "total-money", valueSchema: new Uint64Schema(), omitEmpty: true });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `SupplyResponse` object.
   * @param currentRound - Round
   * @param onlineMoney - OnlineMoney
   * @param totalMoney - TotalMoney
   */
  constructor({ currentRound, onlineMoney, totalMoney }) {
    this.currentRound = ensureBigInt(currentRound);
    this.onlineMoney = ensureBigInt(onlineMoney);
    this.totalMoney = ensureBigInt(totalMoney);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _SupplyResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["current_round", this.currentRound],
      ["online-money", this.onlineMoney],
      ["total-money", this.totalMoney]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded SupplyResponse: ${data}`);
    }
    return new _SupplyResponse({
      currentRound: data.get("current_round"),
      onlineMoney: data.get("online-money"),
      totalMoney: data.get("total-money")
    });
  }
};
var TealKeyValue = class _TealKeyValue {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "key", valueSchema: new ByteArraySchema(), omitEmpty: true }, { key: "value", valueSchema: TealValue2.encodingSchema, omitEmpty: true });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `TealKeyValue` object.
   * @param key -
   * @param value - Represents a TEAL value.
   */
  constructor({ key, value }) {
    this.key = typeof key === "string" ? base64ToBytes(key) : key;
    this.value = value;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _TealKeyValue.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["key", this.key],
      ["value", this.value.toEncodingData()]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded TealKeyValue: ${data}`);
    }
    return new _TealKeyValue({
      key: data.get("key"),
      value: TealValue2.fromEncodingData(data.get("value") ?? /* @__PURE__ */ new Map())
    });
  }
};
var TealValue2 = class _TealValue {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "bytes", valueSchema: new ByteArraySchema(), omitEmpty: true }, { key: "type", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "uint", valueSchema: new Uint64Schema(), omitEmpty: true });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `TealValue` object.
   * @param bytes - (tb) bytes value.
   * @param type - (tt) value type. Value `1` refers to **bytes**, value `2` refers to **uint**
   * @param uint - (ui) uint value.
   */
  constructor({ bytes, type, uint }) {
    this.bytes = typeof bytes === "string" ? base64ToBytes(bytes) : bytes;
    this.type = ensureSafeInteger(type);
    this.uint = ensureBigInt(uint);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _TealValue.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["bytes", this.bytes],
      ["type", this.type],
      ["uint", this.uint]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded TealValue: ${data}`);
    }
    return new _TealValue({
      bytes: data.get("bytes"),
      type: data.get("type"),
      uint: data.get("uint")
    });
  }
};
var TransactionGroupLedgerStateDeltasForRoundResponse = class _TransactionGroupLedgerStateDeltasForRoundResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "Deltas",
        valueSchema: new ArraySchema(LedgerStateDeltaForTransactionGroup.encodingSchema),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `TransactionGroupLedgerStateDeltasForRoundResponse` object.
   * @param deltas -
   */
  constructor({ deltas }) {
    this.deltas = deltas;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _TransactionGroupLedgerStateDeltasForRoundResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["Deltas", this.deltas.map((v2) => v2.toEncodingData())]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded TransactionGroupLedgerStateDeltasForRoundResponse: ${data}`);
    }
    return new _TransactionGroupLedgerStateDeltasForRoundResponse({
      deltas: (data.get("Deltas") ?? []).map((v2) => LedgerStateDeltaForTransactionGroup.fromEncodingData(v2))
    });
  }
};
var TransactionParametersResponse = class _TransactionParametersResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "consensus-version",
        valueSchema: new StringSchema(),
        omitEmpty: true
      }, { key: "fee", valueSchema: new Uint64Schema(), omitEmpty: true }, {
        key: "genesis-hash",
        valueSchema: new ByteArraySchema(),
        omitEmpty: true
      }, { key: "genesis-id", valueSchema: new StringSchema(), omitEmpty: true }, { key: "last-round", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "min-fee", valueSchema: new Uint64Schema(), omitEmpty: true });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `TransactionParametersResponse` object.
   * @param consensusVersion - ConsensusVersion indicates the consensus protocol version
   * as of LastRound.
   * @param fee - Fee is the suggested transaction fee
   * Fee is in units of micro-Algos per byte.
   * Fee may fall to zero but transactions must still have a fee of
   * at least MinTxnFee for the current network protocol.
   * @param genesisHash - GenesisHash is the hash of the genesis block.
   * @param genesisId - GenesisID is an ID listed in the genesis block.
   * @param lastRound - LastRound indicates the last round seen
   * @param minFee - The minimum transaction fee (not per byte) required for the
   * txn to validate for the current network protocol.
   */
  constructor({ consensusVersion, fee, genesisHash, genesisId, lastRound, minFee }) {
    this.consensusVersion = consensusVersion;
    this.fee = ensureBigInt(fee);
    this.genesisHash = typeof genesisHash === "string" ? base64ToBytes(genesisHash) : genesisHash;
    this.genesisId = genesisId;
    this.lastRound = ensureBigInt(lastRound);
    this.minFee = ensureBigInt(minFee);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _TransactionParametersResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["consensus-version", this.consensusVersion],
      ["fee", this.fee],
      ["genesis-hash", this.genesisHash],
      ["genesis-id", this.genesisId],
      ["last-round", this.lastRound],
      ["min-fee", this.minFee]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded TransactionParametersResponse: ${data}`);
    }
    return new _TransactionParametersResponse({
      consensusVersion: data.get("consensus-version"),
      fee: data.get("fee"),
      genesisHash: data.get("genesis-hash"),
      genesisId: data.get("genesis-id"),
      lastRound: data.get("last-round"),
      minFee: data.get("min-fee")
    });
  }
};
var TransactionProof = class _TransactionProof {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "idx", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "proof", valueSchema: new ByteArraySchema(), omitEmpty: true }, {
        key: "stibhash",
        valueSchema: new ByteArraySchema(),
        omitEmpty: true
      }, { key: "treedepth", valueSchema: new Uint64Schema(), omitEmpty: true }, {
        key: "hashtype",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `TransactionProof` object.
   * @param idx - Index of the transaction in the block's payset.
   * @param proof - Proof of transaction membership.
   * @param stibhash - Hash of SignedTxnInBlock for verifying proof.
   * @param treedepth - Represents the depth of the tree that is being proven, i.e. the number of edges
   * from a leaf to the root.
   * @param hashtype - The type of hash function used to create the proof, must be one of:
   * * sha512_256
   * * sha256
   */
  constructor({ idx, proof, stibhash, treedepth, hashtype }) {
    this.idx = ensureSafeInteger(idx);
    this.proof = typeof proof === "string" ? base64ToBytes(proof) : proof;
    this.stibhash = typeof stibhash === "string" ? base64ToBytes(stibhash) : stibhash;
    this.treedepth = ensureSafeInteger(treedepth);
    this.hashtype = hashtype;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _TransactionProof.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["idx", this.idx],
      ["proof", this.proof],
      ["stibhash", this.stibhash],
      ["treedepth", this.treedepth],
      ["hashtype", this.hashtype]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded TransactionProof: ${data}`);
    }
    return new _TransactionProof({
      idx: data.get("idx"),
      proof: data.get("proof"),
      stibhash: data.get("stibhash"),
      treedepth: data.get("treedepth"),
      hashtype: data.get("hashtype")
    });
  }
};
var Version = class _Version {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "build",
        valueSchema: BuildVersion.encodingSchema,
        omitEmpty: true
      }, {
        key: "genesis_hash_b64",
        valueSchema: new ByteArraySchema(),
        omitEmpty: true
      }, { key: "genesis_id", valueSchema: new StringSchema(), omitEmpty: true }, {
        key: "versions",
        valueSchema: new ArraySchema(new StringSchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `Version` object.
   * @param build -
   * @param genesisHashB64 -
   * @param genesisId -
   * @param versions -
   */
  constructor({ build, genesisHashB64, genesisId, versions }) {
    this.build = build;
    this.genesisHashB64 = typeof genesisHashB64 === "string" ? base64ToBytes(genesisHashB64) : genesisHashB64;
    this.genesisId = genesisId;
    this.versions = versions;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _Version.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["build", this.build.toEncodingData()],
      ["genesis_hash_b64", this.genesisHashB64],
      ["genesis_id", this.genesisId],
      ["versions", this.versions]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded Version: ${data}`);
    }
    return new _Version({
      build: BuildVersion.fromEncodingData(data.get("build") ?? /* @__PURE__ */ new Map()),
      genesisHashB64: data.get("genesis_hash_b64"),
      genesisId: data.get("genesis_id"),
      versions: data.get("versions")
    });
  }
};

// node_modules/algosdk/dist/esm/client/v2/jsonrequest.js
var JSONRequest = class {
  /**
   * @param client - HTTPClient object.
   */
  constructor(client) {
    this.c = client;
    this.query = {};
  }
  /**
   * Execute the request
   */
  executeRequest(headers, customOptions) {
    return this.c.get({
      relativePath: this.path(),
      query: this.query,
      requestHeaders: headers,
      customOptions
    });
  }
  /**
   * Execute the request and decode the response.
   * @param headers - Additional headers to send in the request. Optional.
   * @param customOptions - Additional options to pass to the underlying BaseHTTPClient. For
   *   {@link URLTokenBaseHTTPClient}, which is the default client, this will be treated as
   *   additional options to pass to the network `fetch` method.
   * @returns A promise which resolves to the parsed response object.
   * @category JSONRequest
   */
  async do(headers, customOptions) {
    const res = await this.executeRequest(headers, customOptions);
    return this.prepare(res);
  }
  /**
   * Execute the request, but do not process the response data in any way.
   * @param headers - Additional headers to send in the request. Optional.
   * @param customOptions - Additional options to pass to the underlying BaseHTTPClient. For
   *   {@link URLTokenBaseHTTPClient}, which is the default client, this will be treated as
   *   additional options to pass to the network `fetch` method.
   * @returns A promise which resolves to the raw response data, exactly as returned by the server.
   * @category JSONRequest
   */
  async doRaw(headers, customOptions) {
    const res = await this.executeRequest(headers, customOptions);
    return res.body;
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/accountInformation.js
var AccountInformation = class extends JSONRequest {
  constructor(c2, account) {
    super(c2);
    this.account = account.toString();
  }
  path() {
    return `/v2/accounts/${this.account}`;
  }
  /**
   * Exclude assets and application data from results
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountInfo = await algodClient.accountInformation(address)
   *        .exclude('all')
   *        .do();
   * ```
   *
   * @param round
   * @category query
   */
  exclude(exclude) {
    this.query.exclude = exclude;
    return this;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), Account);
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/accountAssetInformation.js
var AccountAssetInformation = class extends JSONRequest {
  constructor(c2, account, assetID) {
    super(c2);
    this.account = account.toString();
    this.assetID = BigInt(assetID);
  }
  path() {
    return `/v2/accounts/${this.account}/assets/${this.assetID}`;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), AccountAssetResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/accountApplicationInformation.js
var AccountApplicationInformation = class extends JSONRequest {
  constructor(c2, account, applicationID) {
    super(c2);
    this.account = account.toString();
    this.applicationID = BigInt(applicationID);
  }
  path() {
    return `/v2/accounts/${this.account}/applications/${this.applicationID}`;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), AccountApplicationResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/block.js
var Block2 = class extends JSONRequest {
  constructor(c2, roundNumber) {
    super(c2);
    this.round = BigInt(roundNumber);
    this.query = { format: "msgpack" };
  }
  path() {
    return `/v2/blocks/${this.round}`;
  }
  /**
   * If true, only the block header (exclusive of payset or certificate) may be included in response.
   *
   * #### Example
   * ```typescript
   *
   * const roundNumber = 41000000;
   *
   * const blockResponse = await algodClient
   *        .block(roundNumber)
   *        .headerOnly(true)
   *        .do();
   * ```
   *
   * @param headerOnly - the flag indicating whether exclusively return header in response
   * @category query
   */
  headerOnly(headerOnly) {
    this.query["header-only"] = headerOnly;
    return this;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeMsgpack(response.body, BlockResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/compile.js
function setHeaders(headers = {}) {
  let hdrs = headers;
  if (Object.keys(hdrs).every((key) => key.toLowerCase() !== "content-type")) {
    hdrs = { ...headers };
    hdrs["Content-Type"] = "text/plain";
  }
  return hdrs;
}
var Compile = class extends JSONRequest {
  constructor(c2, source) {
    super(c2);
    this.source = source;
  }
  // eslint-disable-next-line class-methods-use-this
  path() {
    return `/v2/teal/compile`;
  }
  sourcemap(map = true) {
    this.query.sourcemap = map;
    return this;
  }
  executeRequest(headers, customOptions) {
    const txHeaders = setHeaders(headers);
    return this.c.post({
      relativePath: this.path(),
      data: coerceToBytes(this.source),
      query: this.query,
      requestHeaders: txHeaders,
      customOptions
    });
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), CompileResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/dryrun.js
var Dryrun = class extends JSONRequest {
  constructor(c2, dr) {
    super(c2);
    this.blob = encodeMsgpack(dr);
  }
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/v2/teal/dryrun";
  }
  executeRequest(headers, customOptions) {
    const txHeaders = setHeaders(headers);
    return this.c.post({
      relativePath: this.path(),
      data: this.blob,
      requestHeaders: txHeaders,
      customOptions
    });
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), DryrunResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/genesis.js
var Genesis2 = class extends JSONRequest {
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/genesis";
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return response.getJSONText();
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/getAssetByID.js
var GetAssetByID = class extends JSONRequest {
  constructor(c2, index) {
    super(c2);
    this.index = BigInt(index);
  }
  path() {
    return `/v2/assets/${this.index}`;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), Asset);
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/getApplicationByID.js
var GetApplicationByID = class extends JSONRequest {
  constructor(c2, index) {
    super(c2);
    this.index = BigInt(index);
  }
  path() {
    return `/v2/applications/${this.index}`;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), Application);
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/getBlockHash.js
var GetBlockHash = class extends JSONRequest {
  constructor(c2, roundNumber) {
    super(c2);
    this.round = BigInt(roundNumber);
  }
  path() {
    return `/v2/blocks/${this.round}/hash`;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), BlockHashResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/getBlockTxids.js
var GetBlockTxids = class extends JSONRequest {
  constructor(c2, roundNumber) {
    super(c2);
    this.round = BigInt(roundNumber);
  }
  path() {
    return `/v2/blocks/${this.round}/txids`;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), BlockTxidsResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/getApplicationBoxByName.js
var GetApplicationBoxByName = class extends JSONRequest {
  constructor(c2, index, name) {
    super(c2);
    this.index = BigInt(index);
    const encodedName = bytesToBase64(name);
    this.query.name = encodeURI(`b64:${encodedName}`);
  }
  /**
   * @returns `/v2/applications/${index}/box`
   */
  path() {
    return `/v2/applications/${this.index}/box`;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), Box);
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/getApplicationBoxes.js
var GetApplicationBoxes = class extends JSONRequest {
  constructor(c2, index) {
    super(c2);
    this.index = BigInt(index);
    this.query.max = 0;
  }
  /**
   * @returns `/v2/applications/${index}/boxes`
   */
  path() {
    return `/v2/applications/${this.index}/boxes`;
  }
  /**
   * Limit results for pagination.
   *
   * #### Example
   * ```typescript
   * const maxResults = 20;
   * const boxesResult = await algodClient
   *        .GetApplicationBoxes(1234)
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit - maximum number of results to return.
   * @category query
   */
  max(max) {
    this.query.max = max;
    return this;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), BoxesResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/healthCheck.js
var HealthCheck = class extends JSONRequest {
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/health";
  }
  // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-unused-vars
  prepare(_response) {
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/pendingTransactionInformation.js
var PendingTransactionInformation = class extends JSONRequest {
  constructor(c2, txid) {
    super(c2);
    this.txid = txid;
    this.query.format = "msgpack";
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeMsgpack(response.body, PendingTransactionResponse);
  }
  path() {
    return `/v2/transactions/pending/${this.txid}`;
  }
  // max sets the maximum number of txs to return
  max(max) {
    this.query.max = max;
    return this;
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/pendingTransactions.js
var PendingTransactions = class extends JSONRequest {
  constructor(c2) {
    super(c2);
    this.query.format = "msgpack";
  }
  /* eslint-disable class-methods-use-this */
  path() {
    return "/v2/transactions/pending";
  }
  prepare(response) {
    return decodeMsgpack(response.body, PendingTransactionsResponse);
  }
  /* eslint-enable class-methods-use-this */
  // max sets the maximum number of txs to return
  max(max) {
    this.query.max = max;
    return this;
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/pendingTransactionsByAddress.js
var PendingTransactionsByAddress = class extends JSONRequest {
  constructor(c2, address) {
    super(c2);
    this.address = address.toString();
    this.query.format = "msgpack";
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeMsgpack(response.body, PendingTransactionsResponse);
  }
  path() {
    return `/v2/accounts/${this.address}/transactions/pending`;
  }
  // max sets the maximum number of txs to return
  max(max) {
    this.query.max = max;
    return this;
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/getTransactionProof.js
var GetTransactionProof = class extends JSONRequest {
  constructor(c2, round, txID) {
    super(c2);
    this.txID = txID;
    this.round = BigInt(round);
  }
  path() {
    return `/v2/blocks/${this.round}/transactions/${this.txID}/proof`;
  }
  /**
   * Exclude assets and application data from results
   * The type of hash function used to create the proof, must be one of: "sha512_256", "sha256"
   *
   * #### Example
   * ```typescript
   * const hashType = "sha256";
   * const round = 123456;
   * const txId = "abc123;
   * const txProof = await algodClient.getTransactionProof(round, txId)
   *        .hashType(hashType)
   *        .do();
   * ```
   *
   * @param hashType
   * @category query
   */
  hashType(hashType) {
    this.query.hashtype = hashType;
    return this;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), TransactionProof);
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/sendRawTransaction.js
function setSendTransactionHeaders(headers = {}) {
  let hdrs = headers;
  if (Object.keys(hdrs).every((key) => key.toLowerCase() !== "content-type")) {
    hdrs = { ...headers };
    hdrs["Content-Type"] = "application/x-binary";
  }
  return hdrs;
}
function isByteArray(array) {
  return array && array.byteLength !== void 0;
}
var SendRawTransaction = class extends JSONRequest {
  constructor(c2, stxOrStxs) {
    super(c2);
    let forPosting = stxOrStxs;
    if (Array.isArray(stxOrStxs)) {
      if (!stxOrStxs.every(isByteArray)) {
        throw new TypeError("Array elements must be byte arrays");
      }
      forPosting = concatArrays2(...stxOrStxs);
    } else if (!isByteArray(forPosting)) {
      throw new TypeError("Argument must be byte array");
    }
    this.txnBytesToPost = forPosting;
  }
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/v2/transactions";
  }
  executeRequest(headers, customOptions) {
    const txHeaders = setSendTransactionHeaders(headers);
    return this.c.post({
      relativePath: this.path(),
      data: this.txnBytesToPost,
      requestHeaders: txHeaders,
      customOptions
    });
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), PostTransactionsResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/status.js
var Status = class extends JSONRequest {
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/v2/status";
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), NodeStatusResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/statusAfterBlock.js
var StatusAfterBlock = class extends JSONRequest {
  constructor(c2, round) {
    super(c2);
    this.round = BigInt(round);
  }
  path() {
    return `/v2/status/wait-for-block-after/${this.round}`;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), NodeStatusResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/suggestedParams.js
var SuggestedParamsRequest = class extends JSONRequest {
  /* eslint-disable class-methods-use-this */
  path() {
    return "/v2/transactions/params";
  }
  prepare(response) {
    const params = decodeJSON(response.getJSONText(), TransactionParametersResponse);
    return {
      flatFee: false,
      fee: params.fee,
      firstValid: params.lastRound,
      lastValid: params.lastRound + BigInt(1e3),
      genesisID: params.genesisId,
      genesisHash: params.genesisHash,
      minFee: params.minFee,
      consensusVersion: params.consensusVersion
    };
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/supply.js
var Supply = class extends JSONRequest {
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/v2/ledger/supply";
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), SupplyResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/versions.js
var Versions = class extends JSONRequest {
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/versions";
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), Version);
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/lightBlockHeaderProof.js
var LightBlockHeaderProof2 = class extends JSONRequest {
  constructor(c2, round) {
    super(c2);
    this.round = BigInt(round);
  }
  path() {
    return `/v2/blocks/${this.round}/lightheader/proof`;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), LightBlockHeaderProof);
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/stateproof.js
var StateProof3 = class extends JSONRequest {
  constructor(c2, round) {
    super(c2);
    this.round = BigInt(round);
  }
  path() {
    return `/v2/stateproofs/${this.round}`;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), StateProof2);
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/setSyncRound.js
var SetSyncRound = class extends JSONRequest {
  constructor(c2, round) {
    super(c2);
    this.round = BigInt(round);
  }
  path() {
    return `/v2/ledger/sync/${this.round}`;
  }
  executeRequest(headers, customOptions) {
    return this.c.post({
      relativePath: this.path(),
      data: null,
      requestHeaders: headers,
      customOptions
    });
  }
  // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-unused-vars
  prepare(_response) {
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/getSyncRound.js
var GetSyncRound = class extends JSONRequest {
  // eslint-disable-next-line class-methods-use-this
  path() {
    return `/v2/ledger/sync`;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), GetSyncRoundResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/setBlockOffsetTimestamp.js
var SetBlockOffsetTimestamp = class extends JSONRequest {
  constructor(c2, offset) {
    super(c2);
    this.offset = BigInt(offset);
  }
  path() {
    return `/v2/devmode/blocks/offset/${this.offset}`;
  }
  executeRequest(headers, customOptions) {
    return this.c.post({
      relativePath: this.path(),
      data: null,
      requestHeaders: headers,
      customOptions
    });
  }
  // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-unused-vars
  prepare(_response) {
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/getBlockOffsetTimestamp.js
var GetBlockOffsetTimestamp = class extends JSONRequest {
  // eslint-disable-next-line class-methods-use-this
  path() {
    return `/v2/devmode/blocks/offset`;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), GetBlockTimeStampOffsetResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/disassemble.js
function setHeaders2(headers = {}) {
  let hdrs = headers;
  if (Object.keys(hdrs).every((key) => key.toLowerCase() !== "content-type")) {
    hdrs = { ...headers };
    hdrs["Content-Type"] = "text/plain";
  }
  return hdrs;
}
var Disassemble = class extends JSONRequest {
  constructor(c2, source) {
    super(c2);
    this.source = source;
  }
  // eslint-disable-next-line class-methods-use-this
  path() {
    return `/v2/teal/disassemble`;
  }
  executeRequest(headers, customOptions) {
    const txHeaders = setHeaders2(headers);
    return this.c.post({
      relativePath: this.path(),
      data: coerceToBytes(this.source),
      query: this.query,
      requestHeaders: txHeaders,
      customOptions
    });
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), DisassembleResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/simulateTransaction.js
function setSimulateTransactionsHeaders(headers = {}) {
  let hdrs = headers;
  if (Object.keys(hdrs).every((key) => key.toLowerCase() !== "content-type")) {
    hdrs = { ...headers };
    hdrs["Content-Type"] = "application/msgpack";
  }
  return hdrs;
}
var SimulateRawTransactions = class extends JSONRequest {
  constructor(c2, request) {
    super(c2);
    this.query.format = "msgpack";
    this.requestBytes = encodeMsgpack(request);
  }
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/v2/transactions/simulate";
  }
  executeRequest(headers, customOptions) {
    const txHeaders = setSimulateTransactionsHeaders(headers);
    return this.c.post({
      relativePath: this.path(),
      data: this.requestBytes,
      query: this.query,
      requestHeaders: txHeaders,
      customOptions
    });
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeMsgpack(response.body, SimulateResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/ready.js
var Ready = class extends JSONRequest {
  // eslint-disable-next-line class-methods-use-this
  path() {
    return `/ready`;
  }
  // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-unused-vars
  prepare(_response) {
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/unsetSyncRound.js
var UnsetSyncRound = class extends JSONRequest {
  // eslint-disable-next-line class-methods-use-this
  path() {
    return `/v2/ledger/sync`;
  }
  executeRequest(headers, customOptions) {
    return this.c.delete({
      relativePath: this.path(),
      data: void 0,
      requestHeaders: headers,
      customOptions
    });
  }
  // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-unused-vars
  prepare(_response) {
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/getLedgerStateDeltaForTransactionGroup.js
var GetLedgerStateDeltaForTransactionGroup = class extends JSONRequest {
  constructor(c2, id) {
    super(c2);
    this.id = id;
    this.query = { format: "msgpack" };
  }
  // eslint-disable-next-line class-methods-use-this
  path() {
    return `/v2/deltas/txn/group/${this.id}`;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeMsgpack(response.body, LedgerStateDelta);
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/getLedgerStateDelta.js
var GetLedgerStateDelta = class extends JSONRequest {
  constructor(c2, round) {
    super(c2);
    this.round = BigInt(round);
    this.query = { format: "msgpack" };
  }
  // eslint-disable-next-line class-methods-use-this
  path() {
    return `/v2/deltas/${this.round}`;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeMsgpack(response.body, LedgerStateDelta);
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/getTransactionGroupLedgerStateDeltasForRound.js
var GetTransactionGroupLedgerStateDeltasForRound = class extends JSONRequest {
  constructor(c2, round) {
    super(c2);
    this.round = BigInt(round);
    this.query = { format: "msgpack" };
  }
  // eslint-disable-next-line class-methods-use-this
  path() {
    return `/v2/deltas/${this.round}/txn/group`;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeMsgpack(response.body, TransactionGroupLedgerStateDeltasForRoundResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/algod/algod.js
var AlgodClient = class extends ServiceClient {
  /**
   * Create an AlgodClient from
   * * either a token, baseServer, port, and optional headers
   * * or a base client server for interoperability with external dApp wallets
   *
   * #### Example
   * ```typescript
   * const token  = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa";
   * const server = "http://localhost";
   * const port   = 4001;
   * const algodClient = new algosdk.Algodv2(token, server, port);
   * ```
   * @remarks
   * The above configuration is for a sandbox private network.
   * For applications on production, you are encouraged to run your own node, or use an Algorand REST API provider with a dedicated API key.
   *
   * @param tokenOrBaseClient - The algod token from the Algorand node you are interacting with
   * @param baseServer - REST endpoint
   * @param port - Port number if specifically configured by the server
   * @param headers - Optional headers
   */
  constructor(tokenOrBaseClient, baseServer, port, headers = {}) {
    super("X-Algo-API-Token", tokenOrBaseClient, baseServer, port, headers);
  }
  /**
   * Returns OK if healthy.
   *
   * #### Example
   * ```typescript
   * await algodClient.healthCheck().do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-health)
   * @category GET
   */
  healthCheck() {
    return new HealthCheck(this.c);
  }
  /**
   * Retrieves the supported API versions, binary build versions, and genesis information.
   *
   * #### Example
   * ```typescript
   * const versionsDetails = await algodClient.versionsCheck().do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-versions)
   * @category GET
   */
  versionsCheck() {
    return new Versions(this.c);
  }
  /**
   * Broadcasts a raw transaction to the network.
   *
   * #### Example
   * ```typescript
   * const { txid } = await algodClient.sendRawTransaction(signedTxns).do();
   * const result = await waitForConfirmation(algodClient, txid, 3);
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#post-v2transactions)
   *
   * @remarks
   * Often used with {@linkcode waitForConfirmation}
   * @param stxOrStxs - Signed transactions
   * @category POST
   */
  sendRawTransaction(stxOrStxs) {
    return new SendRawTransaction(this.c, stxOrStxs);
  }
  /**
   * Returns the given account's status, balance and spendable amounts.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountInfo = await algodClient.accountInformation(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2accountsaddress)
   * @param account - The address of the account to look up.
   * @category GET
   */
  accountInformation(account) {
    return new AccountInformation(this.c, account);
  }
  /**
   * Returns the given account's asset information for a specific asset.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const index = 60553466;
   * const accountAssetInfo = await algodClient.accountAssetInformation(address, index).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2accountsaddress)
   * @param account - The address of the account to look up.
   * @param index - The asset ID to look up.
   * @category GET
   */
  accountAssetInformation(account, index) {
    return new AccountAssetInformation(this.c, account, index);
  }
  /**
   * Returns the given account's application information for a specific application.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const index = 60553466;
   * const accountInfo = await algodClient.accountApplicationInformation(address, index).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2accountsaddress)
   * @param account - The address of the account to look up.
   * @param index - The application ID to look up.
   * @category GET
   */
  accountApplicationInformation(account, index) {
    return new AccountApplicationInformation(this.c, account, index);
  }
  /**
   * Gets the block info for the given round.
   *
   * #### Example
   * ```typescript
   * const roundNumber = 18038133;
   * const block = await algodClient.block(roundNumber).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2blocksround)
   * @param roundNumber - The round number of the block to get.
   * @category GET
   */
  block(roundNumber) {
    return new Block2(this.c, roundNumber);
  }
  /**
   * Get the block hash for the block on the given round.
   *
   * #### Example
   * ```typescript
   * const roundNumber = 18038133;
   * const block = await algodClient.getBlockHash(roundNumber).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2blocksroundhash)
   * @param roundNumber - The round number of the block to get.
   * @category GET
   */
  getBlockHash(roundNumber) {
    return new GetBlockHash(this.c, roundNumber);
  }
  /**
   * Get the top level transaction IDs for the block on the given round.
   *
   * #### Example
   * ```typescript
   * const roundNumber = 18038133;
   * const block = await algodClient.getBlockTxids(roundNumber).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2blocksroundtxids)
   * @param roundNumber - The round number of the block to get.
   * @category GET
   */
  getBlockTxids(roundNumber) {
    return new GetBlockTxids(this.c, roundNumber);
  }
  /**
   * Returns the transaction information for a specific pending transaction.
   *
   * #### Example
   * ```typescript
   * const txId = "DRJS6R745A7GFVMXEXWP4TGVDGKW7VILFTA7HC2BR2GRLHNY5CTA";
   * const pending = await algodClient.pendingTransactionInformation(txId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2transactionspendingtxid)
   *
   * @remarks
   * <br><br>
   * There are several cases when this might succeed:
   * - transaction committed (committed round > 0)
   * - transaction still in the pool (committed round = 0, pool error = "")
   * - transaction removed from pool due to error (committed round = 0, pool error != "")
   *
   * Or the transaction may have happened sufficiently long ago that the node no longer remembers it, and this will return an error.
   *
   * @param txid - The TxID string of the pending transaction to look up.
   * @category GET
   */
  pendingTransactionInformation(txid) {
    return new PendingTransactionInformation(this.c, txid);
  }
  /**
   * Returns the list of pending transactions in the pool, sorted by priority, in decreasing order, truncated at the end at MAX.
   * If MAX = 0, returns all pending transactions.
   *
   * #### Example 1
   * ```typescript
   * const pendingTxns = await algodClient.pendingTransactionsInformation().do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const maxTxns = 5;
   * const pendingTxns = await algodClient
   *     .pendingTransactionsInformation()
   *     .max(maxTxns)
   *     .do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2transactionspending)
   * @category GET
   */
  pendingTransactionsInformation() {
    return new PendingTransactions(this.c);
  }
  /**
   * Returns the list of pending transactions sent by the address, sorted by priority, in decreasing order, truncated at the end at MAX.
   * If MAX = 0, returns all pending transactions.
   *
   * #### Example 1
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const pendingTxnsByAddr = await algodClient.pendingTransactionByAddress(address).do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const maxTxns = 5;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const pendingTxns = await algodClient
   *     .pendingTransactionByAddress(address)
   *     .max(maxTxns)
   *     .do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2accountsaddresstransactionspending)
   * @param address - The address of the sender.
   * @category GET
   */
  pendingTransactionByAddress(address) {
    return new PendingTransactionsByAddress(this.c, address);
  }
  /**
   * Retrieves the StatusResponse from the running node.
   *
   * #### Example
   * ```typescript
   * const status = await algodClient.status().do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2status)
   * @category GET
   */
  status() {
    return new Status(this.c);
  }
  /**
   * Waits for a specific round to occur then returns the `StatusResponse` for that round.
   *
   * #### Example
   * ```typescript
   * const round = 18038133;
   * const statusAfterBlock = await algodClient.statusAfterBlock(round).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2statuswait-for-block-afterround)
   * @param round - The number of the round to wait for.
   * @category GET
   */
  statusAfterBlock(round) {
    return new StatusAfterBlock(this.c, round);
  }
  /**
   * Returns the common needed parameters for a new transaction.
   *
   * #### Example
   * ```typescript
   * const suggestedParams = await algodClient.getTransactionParams().do();
   * const amountInMicroAlgos = algosdk.algosToMicroalgos(2); // 2 Algos
   * const unsignedTxn = algosdk.makePaymentTxnWithSuggestedParamsFromObject({
   *   sender: senderAddress,
   *   receiver: receiverAddress,
   *   amount: amountInMicroAlgos,
   *   suggestedParams: suggestedParams,
   * });
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2transactionsparams)
   *
   * @remarks
   * Often used with
   * {@linkcode makePaymentTxnWithSuggestedParamsFromObject}, {@linkcode algosToMicroalgos}
   * @category GET
   */
  getTransactionParams() {
    return new SuggestedParamsRequest(this.c);
  }
  /**
   * Returns the supply details for the specified node's ledger.
   *
   * #### Example
   * ```typescript
   * const supplyDetails = await algodClient.supply().do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2ledgersupply)
   * @category GET
   */
  supply() {
    return new Supply(this.c);
  }
  /**
   * Compiles TEAL source code to binary, returns base64 encoded program bytes and base32 SHA512_256 hash of program bytes (Address style).
   *
   * #### Example
   * ```typescript
   * const source = "TEAL SOURCE CODE";
   * const compiledSmartContract = await algodClient.compile(source).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#post-v2tealcompile)
   * @remarks
   * This endpoint is only enabled when a node's configuration file sets `EnableDeveloperAPI` to true.
   * @param source
   * @category POST
   */
  compile(source) {
    return new Compile(this.c, source);
  }
  /**
   * Given the program bytes, return the TEAL source code in plain text.
   *
   * #### Example
   * ```typescript
   * const bytecode = "TEAL bytecode";
   * const disassembledSource = await algodClient.disassemble(bytecode).do();
   * ```
   *
   * @remarks This endpoint is only enabled when a node's configuration file sets EnableDeveloperAPI to true.
   * @param source
   */
  disassemble(source) {
    return new Disassemble(this.c, source);
  }
  /**
   * Provides debugging information for a transaction (or group).
   *
   * Executes TEAL program(s) in context and returns debugging information about the execution. This endpoint is only enabled when a node's configureation file sets `EnableDeveloperAPI` to true.
   *
   * #### Example
   * ```typescript
   * const dryRunResult = await algodClient.dryrun(dr).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#post-v2tealdryrun)
   * @param dr
   * @category POST
   */
  dryrun(dr) {
    return new Dryrun(this.c, dr);
  }
  /**
   * Given an asset ID, return asset information including creator, name, total supply and
   * special addresses.
   *
   * #### Example
   * ```typescript
   * const asset_id = 163650;
   * const asset = await algodClient.getAssetByID(asset_id).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2assetsasset-id)
   * @param index - The asset ID to look up.
   * @category GET
   */
  getAssetByID(index) {
    return new GetAssetByID(this.c, index);
  }
  /**
   * Given an application ID, return the application information including creator, approval
   * and clear programs, global and local schemas, and global state.
   *
   * #### Example
   * ```typescript
   * const index = 60553466;
   * const app = await algodClient.getApplicationByID(index).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2applicationsapplication-id)
   * @param index - The application ID to look up.
   * @category GET
   */
  getApplicationByID(index) {
    return new GetApplicationByID(this.c, index);
  }
  /**
   * Given an application ID and the box name (key), return the value stored in the box.
   *
   * #### Example
   * ```typescript
   * const index = 60553466;
   * const boxName = Buffer.from("foo");
   * const boxResponse = await algodClient.getApplicationBoxByName(index, boxName).do();
   * const boxValue = boxResponse.value;
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2applicationsapplication-idbox)
   * @param index - The application ID to look up.
   * @category GET
   */
  getApplicationBoxByName(index, boxName) {
    return new GetApplicationBoxByName(this.c, index, boxName);
  }
  /**
   * Given an application ID, return all the box names associated with the app.
   *
   * #### Example
   * ```typescript
   * const index = 60553466;
   * const boxesResponse = await algodClient.getApplicationBoxes(index).max(3).do();
   * const boxNames = boxesResponse.boxes.map(box => box.name);
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2applicationsapplication-idboxes)
   * @param index - The application ID to look up.
   * @category GET
   */
  getApplicationBoxes(index) {
    return new GetApplicationBoxes(this.c, index);
  }
  /**
   * Returns the entire genesis file.
   *
   * #### Example
   * ```typescript
   * const genesis = await algodClient.genesis().do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-genesis)
   * @category GET
   */
  genesis() {
    return new Genesis2(this.c);
  }
  /**
   * Returns a Merkle proof for a given transaction in a block.
   *
   * #### Example
   * ```typescript
   * const round = 18038133;
   * const txId = "MEUOC4RQJB23CQZRFRKYEI6WBO73VTTPST5A7B3S5OKBUY6LFUDA";
   * const proof = await algodClient.getTransactionProof(round, txId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2blocksroundtransactionstxidproof)
   * @param round - The round in which the transaction appears.
   * @param txID - The transaction ID for which to generate a proof.
   * @category GET
   */
  getTransactionProof(round, txID) {
    return new GetTransactionProof(this.c, round, txID);
  }
  /**
   * Gets a proof for a given light block header inside a state proof commitment.
   *
   * #### Example
   * ```typescript
   * const round = 11111111;
   * const lightBlockHeaderProof = await algodClient.getLightBlockHeaderProof(round).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/v2#get-v2blocksroundlightheaderproof)
   * @param round
   */
  getLightBlockHeaderProof(round) {
    return new LightBlockHeaderProof2(this.c, round);
  }
  /**
   * Gets a state proof that covers a given round.
   *
   * #### Example
   * ```typescript
   * const round = 11111111;
   * const stateProof = await algodClient.getStateProof(round).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/v2#get-v2stateproofsround)
   * @param round
   */
  getStateProof(round) {
    return new StateProof3(this.c, round);
  }
  /**
   * Simulate a list of a signed transaction objects being sent to the network.
   *
   * #### Example
   * ```typescript
   * const txn1 = algosdk.makePaymentTxnWithSuggestedParamsFromObject(txn1Params);
   * const txn2 = algosdk.makePaymentTxnWithSuggestedParamsFromObject(txn2Params);
   * const txgroup = algosdk.assignGroupID([txn1, txn2]);
   *
   * // Actually sign the first transaction
   * const signedTxn1 = txgroup[0].signTxn(senderSk).blob;
   * // Simulate does not require signed transactions -- use this method to encode an unsigned transaction
   * const signedTxn2 = algosdk.encodeUnsignedSimulateTransaction(txgroup[1]);
   *
   * const resp = await client.simulateRawTransactions([signedTxn1, signedTxn2]).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#post-v2transactionssimulate)
   * @param stxOrStxs
   * @category POST
   */
  simulateRawTransactions(stxOrStxs) {
    const txnObjects = [];
    if (Array.isArray(stxOrStxs)) {
      for (const stxn of stxOrStxs) {
        txnObjects.push(decodeMsgpack(stxn, SignedTransaction));
      }
    } else {
      txnObjects.push(decodeMsgpack(stxOrStxs, SignedTransaction));
    }
    const request = new SimulateRequest({
      txnGroups: [
        new SimulateRequestTransactionGroup({
          txns: txnObjects
        })
      ]
    });
    return this.simulateTransactions(request);
  }
  /**
   * Simulate transactions being sent to the network.
   *
   * #### Example
   * ```typescript
   * const txn1 = algosdk.makePaymentTxnWithSuggestedParamsFromObject(txn1Params);
   * const txn2 = algosdk.makePaymentTxnWithSuggestedParamsFromObject(txn2Params);
   * const txgroup = algosdk.assignGroupID([txn1, txn2]);
   *
   * // Actually sign the first transaction
   * const signedTxn1 = txgroup[0].signTxn(senderSk).blob;
   * // Simulate does not require signed transactions -- use this method to encode an unsigned transaction
   * const signedTxn2 = algosdk.encodeUnsignedSimulateTransaction(txgroup[1]);
   *
   * const request = new modelsv2.SimulateRequest({
   *  txnGroups: [
   *    new modelsv2.SimulateRequestTransactionGroup({
   *       // Must decode the signed txn bytes into an object
   *       txns: [algosdk.decodeObj(signedTxn1), algosdk.decodeObj(signedTxn2)]
   *     }),
   *   ],
   * });
   * const resp = await client.simulateRawTransactions(request).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#post-v2transactionssimulate)
   * @param request
   * @category POST
   */
  simulateTransactions(request) {
    return new SimulateRawTransactions(this.c, request);
  }
  /**
   * Set the offset (in seconds) applied to the block timestamp when creating new blocks in devmode.
   *
   *  #### Example
   *  ```typesecript
   *  const offset = 60
   *  await client.setBlockOffsetTimestamp(offset).do();
   *  ```
   *
   [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#post-v2devmodeblocksoffsetoffset)
   * @param offset
   * @category POST
   */
  setBlockOffsetTimestamp(offset) {
    return new SetBlockOffsetTimestamp(this.c, offset);
  }
  /**
   * Get the offset (in seconds) applied to the block timestamp when creating new blocks in devmode.
   *
   *  #### Example
   *  ```typesecript
   *  const currentOffset = await client.getBlockOffsetTimestamp().do();
   *  ```
   *
   [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2devmodeblocksoffset)
   * @category GET
   */
  getBlockOffsetTimestamp() {
    return new GetBlockOffsetTimestamp(this.c);
  }
  /**
   * Set the sync round on the ledger (algod must have EnableFollowMode: true), restricting catchup.
   *
   *  #### Example
   *  ```typesecript
   *  const round = 10000
   *  await client.setSyncRound(round).do();
   *  ```
   *
   [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#post-v2ledgersyncround)
   * @param round
   * @category POST
   */
  setSyncRound(round) {
    return new SetSyncRound(this.c, round);
  }
  /**
   * Un-Set the sync round on the ledger (algod must have EnableFollowMode: true), removing the restriction on catchup.
   *
   *  #### Example
   *  ```typesecript
   *  await client.unsetSyncRound().do();
   *  ```
   *
   [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#delete-v2ledgersync)
   * @category DELETE
   */
  unsetSyncRound() {
    return new UnsetSyncRound(this.c);
  }
  /**
   * Get the current sync round on the ledger (algod must have EnableFollowMode: true).
   *
   *  #### Example
   *  ```typesecript
   *  const currentSyncRound = await client.getSyncRound().do();
   *  ```
   *
   [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2ledgersync)
   * @category GET
   */
  getSyncRound() {
    return new GetSyncRound(this.c);
  }
  /**
   * Ready check which returns 200 OK if algod is healthy and caught up
   *
   *  #### Example
   *  ```typesecript
   *  await client.ready().do();
   *  ```
   *
   [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-ready)
   * @category GET
   */
  ready() {
    return new Ready(this.c);
  }
  /**
   * GetLedgerStateDeltaForTransactionGroup returns the ledger delta for the txn group identified by id
   *
   * #### Example
   * ```typescript
   * const id = "ABC123";
   * await client.getLedgerStateDeltaForTransactionGroup(id).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2deltastxngroupid)
   * @param id txn ID or group ID to be searched for
   * @category GET
   */
  getLedgerStateDeltaForTransactionGroup(id) {
    return new GetLedgerStateDeltaForTransactionGroup(this.c, id);
  }
  /**
   * GetLedgerStateDelta returns the ledger delta for the entire round
   *
   * #### Example
   * ```typescript
   * const round = 12345;
   * await client.getLedgerStateDelta(round).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2deltasround)
   * @param round the round number to be searched for
   * @category GET
   */
  getLedgerStateDelta(round) {
    return new GetLedgerStateDelta(this.c, round);
  }
  /**
   * GetTransactionGroupLedgerStateDeltasForRound returns all ledger deltas for txn groups in the provided round
   *
   * #### Example
   * ```typescript
   * const round = 12345;
   * await client.getTransactionGroupLedgerStateDeltasForRound(round).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/algod/#get-v2deltasroundtxngroup)
   * @param round the round number to be searched for
   * @category GET
   */
  getTransactionGroupLedgerStateDeltasForRound(round) {
    return new GetTransactionGroupLedgerStateDeltasForRound(this.c, round);
  }
};

// node_modules/algosdk/dist/esm/client/kmd.js
var KmdClient = class extends ServiceClient {
  constructor(token, baseServer = "http://127.0.0.1", port = 7833, headers = {}) {
    super("X-KMD-API-Token", token, baseServer, port, headers);
  }
  async get(relativePath) {
    const res = await this.c.get({
      relativePath
    });
    return res.parseBodyAsJSON({
      // Using SAFE for all KMD endpoints because no integers in responses should ever be too big
      intDecoding: intDecoding_default.SAFE
    });
  }
  async delete(relativePath, data) {
    const res = await this.c.delete({
      relativePath,
      data
    });
    return res.parseBodyAsJSON({
      // Using SAFE for all KMD endpoints because no integers in responses should ever be too big
      intDecoding: intDecoding_default.SAFE
    });
  }
  async post(relativePath, data) {
    const res = await this.c.post({
      relativePath,
      data
    });
    return res.parseBodyAsJSON({
      // Using SAFE for all KMD endpoints because no integers in responses should ever be too big
      intDecoding: intDecoding_default.SAFE
    });
  }
  /**
   * version returns a VersionResponse containing a list of kmd API versions supported by this running kmd instance.
   */
  async versions() {
    return this.get("/versions");
  }
  /**
   * listWallets returns a ListWalletsResponse containing the list of wallets known to kmd. Using a wallet ID
   * returned from this endpoint, you can initialize a wallet handle with client.InitWalletHandle
   */
  async listWallets() {
    return this.get("/v1/wallets");
  }
  /**
   * createWallet creates a wallet with the specified name, password, driver,
   * and master derivation key. If the master derivation key is blank, one is
   * generated internally to kmd. CreateWallet returns a CreateWalletResponse
   * containing information about the new wallet.
   * @param walletName
   * @param walletPassword
   * @param walletDriverName
   * @param walletMDK
   */
  async createWallet(walletName, walletPassword, walletMDK = new Uint8Array(), walletDriverName = "sqlite") {
    const req = {
      wallet_name: walletName,
      wallet_driver_name: walletDriverName,
      wallet_password: walletPassword,
      master_derivation_key: bytesToBase64(walletMDK)
    };
    return this.post("/v1/wallet", req);
  }
  /**
   * initWalletHandle accepts a wallet ID and a wallet password, and returns an
   * initWalletHandleResponse containing a wallet handle token. This wallet
   * handle token can be used for subsequent operations on this wallet, like key
   * generation, transaction signing, etc.. WalletHandleTokens expire after a
   * configurable number of seconds, and must be renewed periodically with
   * RenewWalletHandle. It is good practice to call ReleaseWalletHandle when
   * you're done interacting with this wallet.
   * @param walletID
   * @param walletPassword
   */
  async initWalletHandle(walletID, walletPassword) {
    const req = {
      wallet_id: walletID,
      wallet_password: walletPassword
    };
    return this.post("/v1/wallet/init", req);
  }
  /**
   * releaseWalletHandle invalidates the passed wallet handle token, making
   * it unusuable for subsequent wallet operations.
   * @param walletHandle
   */
  async releaseWalletHandle(walletHandle) {
    const req = {
      wallet_handle_token: walletHandle
    };
    return this.post("/v1/wallet/release", req);
  }
  /**
   * renewWalletHandle accepts a wallet handle and attempts to renew it, moving
   * the expiration time to some number of seconds in the future. It returns a
   * RenewWalletHandleResponse containing the walletHandle and the number of
   * seconds until expiration
   * @param walletHandle
   */
  async renewWalletHandle(walletHandle) {
    const req = {
      wallet_handle_token: walletHandle
    };
    return this.post("/v1/wallet/renew", req);
  }
  /**
   * renameWallet accepts a wallet ID, wallet password, and a new wallet name,
   * and renames the underlying wallet.
   * @param walletID
   * @param walletPassword
   * @param newWalletName
   */
  async renameWallet(walletID, walletPassword, newWalletName) {
    const req = {
      wallet_id: walletID,
      wallet_password: walletPassword,
      wallet_name: newWalletName
    };
    return this.post("/v1/wallet/rename", req);
  }
  /**
   * getWallet accepts a wallet handle and returns high level information about
   * this wallet in a GetWalletResponse.
   * @param walletHandle
   */
  async getWallet(walletHandle) {
    const req = {
      wallet_handle_token: walletHandle
    };
    return this.post("/v1/wallet/info", req);
  }
  /**
   * exportMasterDerivationKey accepts a wallet handle and a wallet password, and
   * returns an ExportMasterDerivationKeyResponse containing the master
   * derivation key. This key can be used as an argument to CreateWallet in
   * order to recover the keys generated by this wallet. The master derivation
   * key can be encoded as a sequence of words using the mnemonic library, and
   * @param walletHandle
   * @param walletPassword
   */
  async exportMasterDerivationKey(walletHandle, walletPassword) {
    const req = {
      wallet_handle_token: walletHandle,
      wallet_password: walletPassword
    };
    const res = await this.post("/v1/master-key/export", req);
    return {
      master_derivation_key: base64ToBytes(res.master_derivation_key)
    };
  }
  /**
   * importKey accepts a wallet handle and an ed25519 private key, and imports
   * the key into the wallet. It returns an ImportKeyResponse containing the
   * address corresponding to this private key.
   * @param walletHandle
   * @param secretKey
   */
  async importKey(walletHandle, secretKey) {
    const req = {
      wallet_handle_token: walletHandle,
      private_key: bytesToBase64(secretKey)
    };
    return this.post("/v1/key/import", req);
  }
  /**
   * exportKey accepts a wallet handle, wallet password, and address, and returns
   * an ExportKeyResponse containing the ed25519 private key corresponding to the
   * address stored in the wallet.
   * @param walletHandle
   * @param walletPassword
   * @param addr
   */
  async exportKey(walletHandle, walletPassword, addr) {
    const req = {
      wallet_handle_token: walletHandle,
      address: addr,
      wallet_password: walletPassword
    };
    const res = await this.post("/v1/key/export", req);
    return { private_key: base64ToBytes(res.private_key) };
  }
  /**
   * generateKey accepts a wallet handle, and then generates the next key in the
   * wallet using its internal master derivation key. Two wallets with the same
   * master derivation key will generate the same sequence of keys.
   * @param walletHandle
   */
  async generateKey(walletHandle) {
    const req = {
      wallet_handle_token: walletHandle,
      display_mnemonic: false
    };
    return this.post("/v1/key", req);
  }
  /**
   * deleteKey accepts a wallet handle, wallet password, and address, and deletes
   * the information about this address from the wallet (including address and
   * secret key). If DeleteKey is called on a key generated using GenerateKey,
   * the same key will not be generated again. However, if a wallet is recovered
   * using the master derivation key, a key generated in this way can be
   * recovered.
   * @param walletHandle
   * @param walletPassword
   * @param addr
   */
  async deleteKey(walletHandle, walletPassword, addr) {
    const req = {
      wallet_handle_token: walletHandle,
      address: addr,
      wallet_password: walletPassword
    };
    return this.delete("/v1/key", req);
  }
  /**
   * ListKeys accepts a wallet handle and returns a ListKeysResponse containing
   * all of the addresses for which this wallet contains secret keys.
   * @param walletHandle
   */
  async listKeys(walletHandle) {
    const req = {
      wallet_handle_token: walletHandle
    };
    return this.post("/v1/key/list", req);
  }
  /**
   * signTransaction accepts a wallet handle, wallet password, and a transaction,
   * and returns and SignTransactionResponse containing an encoded, signed
   * transaction. The transaction is signed using the key corresponding to the
   * Sender field.
   * @param walletHandle
   * @param walletPassword
   * @param transaction
   */
  async signTransaction(walletHandle, walletPassword, transaction) {
    const req = {
      wallet_handle_token: walletHandle,
      wallet_password: walletPassword,
      transaction: bytesToBase64(transaction.toByte())
    };
    const res = await this.post("/v1/transaction/sign", req);
    return base64ToBytes(res.signed_transaction);
  }
  /**
   * signTransactionWithSpecificPublicKey accepts a wallet handle, wallet password, a transaction, and a public key,
   * and returns and SignTransactionResponse containing an encoded, signed
   * transaction. The transaction is signed using the key corresponding to the
   * publicKey arg.
   * @param walletHandle
   * @param walletPassword
   * @param transaction
   * @param publicKey - sign the txn with the key corresponding to publicKey (used for working with a rekeyed addr)
   */
  async signTransactionWithSpecificPublicKey(walletHandle, walletPassword, transaction, publicKey) {
    const pk = coerceToBytes(publicKey);
    const req = {
      wallet_handle_token: walletHandle,
      wallet_password: walletPassword,
      transaction: bytesToBase64(transaction.toByte()),
      public_key: bytesToBase64(pk)
    };
    const res = await this.post("/v1/transaction/sign", req);
    return base64ToBytes(res.signed_transaction);
  }
  /**
   * listMultisig accepts a wallet handle and returns a ListMultisigResponse
   * containing the multisig addresses whose preimages are stored in this wallet.
   * A preimage is the information needed to reconstruct this multisig address,
   * including multisig version information, threshold information, and a list
   * of public keys.
   * @param walletHandle
   */
  async listMultisig(walletHandle) {
    const req = {
      wallet_handle_token: walletHandle
    };
    return this.post("/v1/multisig/list", req);
  }
  /**
   * importMultisig accepts a wallet handle and the information required to
   * generate a multisig address. It derives this address, and stores all of the
   * information within the wallet. It returns a ImportMultisigResponse with the
   * derived address.
   * @param walletHandle
   * @param version
   * @param threshold
   * @param pks
   */
  async importMultisig(walletHandle, version, threshold, pks) {
    const req = {
      wallet_handle_token: walletHandle,
      multisig_version: version,
      threshold,
      pks
    };
    return this.post("/v1/multisig/import", req);
  }
  /**
   * exportMultisig accepts a wallet handle, wallet password, and multisig
   * address, and returns an ExportMultisigResponse containing the stored
   * multisig preimage. The preimage contains all of the information necessary
   * to derive the multisig address, including version, threshold, and a list of
   * public keys.
   * @param walletHandle
   * @param walletPassword
   * @param addr
   */
  async exportMultisig(walletHandle, addr) {
    const req = {
      wallet_handle_token: walletHandle,
      address: addr
    };
    return this.post("/v1/multisig/export", req);
  }
  /**
   * signMultisigTransaction accepts a wallet handle, wallet password,
   * transaction, public key (*not* an address), and an optional partial
   * MultisigSig. It looks up the secret key corresponding to the public key, and
   * returns a SignMultisigTransactionResponse containing a MultisigSig with a
   * signature by the secret key included.
   * @param walletHandle
   * @param pw
   * @param tx
   * @param pk
   * @param partial
   */
  async signMultisigTransaction(walletHandle, pw, transaction, pk, partial) {
    const pubkey = coerceToBytes(pk);
    const req = {
      wallet_handle_token: walletHandle,
      transaction: bytesToBase64(transaction.toByte()),
      public_key: bytesToBase64(pubkey),
      partial_multisig: partial,
      wallet_password: pw
    };
    return this.post("/v1/multisig/sign", req);
  }
  /**
   * deleteMultisig accepts a wallet handle, wallet password, and multisig
   * address, and deletes the information about this multisig address from the
   * wallet (including address and secret key).
   * @param walletHandle
   * @param walletPassword
   * @param addr
   */
  async deleteMultisig(walletHandle, walletPassword, addr) {
    const req = {
      wallet_handle_token: walletHandle,
      address: addr,
      wallet_password: walletPassword
    };
    return this.delete("/v1/multisig", req);
  }
};

// node_modules/algosdk/dist/esm/client/v2/indexer/models/types.js
var types_exports2 = {};
__export(types_exports2, {
  Account: () => Account2,
  AccountParticipation: () => AccountParticipation2,
  AccountResponse: () => AccountResponse,
  AccountStateDelta: () => AccountStateDelta2,
  AccountsResponse: () => AccountsResponse,
  Application: () => Application2,
  ApplicationLocalState: () => ApplicationLocalState2,
  ApplicationLocalStatesResponse: () => ApplicationLocalStatesResponse,
  ApplicationLogData: () => ApplicationLogData,
  ApplicationLogsResponse: () => ApplicationLogsResponse,
  ApplicationParams: () => ApplicationParams2,
  ApplicationResponse: () => ApplicationResponse,
  ApplicationStateSchema: () => ApplicationStateSchema2,
  ApplicationsResponse: () => ApplicationsResponse,
  Asset: () => Asset2,
  AssetBalancesResponse: () => AssetBalancesResponse,
  AssetHolding: () => AssetHolding3,
  AssetHoldingsResponse: () => AssetHoldingsResponse,
  AssetParams: () => AssetParams3,
  AssetResponse: () => AssetResponse,
  AssetsResponse: () => AssetsResponse,
  Block: () => Block3,
  BlockHeadersResponse: () => BlockHeadersResponse,
  BlockRewards: () => BlockRewards,
  BlockUpgradeState: () => BlockUpgradeState,
  BlockUpgradeVote: () => BlockUpgradeVote,
  Box: () => Box2,
  BoxDescriptor: () => BoxDescriptor2,
  BoxReference: () => BoxReference2,
  BoxesResponse: () => BoxesResponse2,
  ErrorResponse: () => ErrorResponse2,
  EvalDelta: () => EvalDelta3,
  EvalDeltaKeyValue: () => EvalDeltaKeyValue2,
  HashFactory: () => HashFactory2,
  HbProofFields: () => HbProofFields,
  HealthCheck: () => HealthCheck2,
  HoldingRef: () => HoldingRef,
  IndexerStateProofMessage: () => IndexerStateProofMessage,
  LocalsRef: () => LocalsRef,
  MerkleArrayProof: () => MerkleArrayProof2,
  MiniAssetHolding: () => MiniAssetHolding,
  ParticipationUpdates: () => ParticipationUpdates2,
  ResourceRef: () => ResourceRef,
  StateProofFields: () => StateProofFields,
  StateProofParticipant: () => StateProofParticipant,
  StateProofReveal: () => StateProofReveal,
  StateProofSigSlot: () => StateProofSigSlot,
  StateProofSignature: () => StateProofSignature,
  StateProofTracking: () => StateProofTracking,
  StateProofVerifier: () => StateProofVerifier,
  StateSchema: () => StateSchema2,
  TealKeyValue: () => TealKeyValue2,
  TealValue: () => TealValue3,
  Transaction: () => Transaction2,
  TransactionApplication: () => TransactionApplication,
  TransactionAssetConfig: () => TransactionAssetConfig,
  TransactionAssetFreeze: () => TransactionAssetFreeze,
  TransactionAssetTransfer: () => TransactionAssetTransfer,
  TransactionHeartbeat: () => TransactionHeartbeat,
  TransactionKeyreg: () => TransactionKeyreg,
  TransactionPayment: () => TransactionPayment,
  TransactionResponse: () => TransactionResponse,
  TransactionSignature: () => TransactionSignature,
  TransactionSignatureLogicsig: () => TransactionSignatureLogicsig,
  TransactionSignatureMultisig: () => TransactionSignatureMultisig,
  TransactionSignatureMultisigSubsignature: () => TransactionSignatureMultisigSubsignature,
  TransactionStateProof: () => TransactionStateProof,
  TransactionsResponse: () => TransactionsResponse
});
var Account2 = class _Account {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "address", valueSchema: new StringSchema(), omitEmpty: true }, { key: "amount", valueSchema: new Uint64Schema(), omitEmpty: true }, {
        key: "amount-without-pending-rewards",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "min-balance",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "pending-rewards",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, { key: "rewards", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "round", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "status", valueSchema: new StringSchema(), omitEmpty: true }, {
        key: "total-apps-opted-in",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "total-assets-opted-in",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "total-box-bytes",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "total-boxes",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "total-created-apps",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "total-created-assets",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "apps-local-state",
        valueSchema: new OptionalSchema(new ArraySchema(ApplicationLocalState2.encodingSchema)),
        omitEmpty: true
      }, {
        key: "apps-total-extra-pages",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "apps-total-schema",
        valueSchema: new OptionalSchema(ApplicationStateSchema2.encodingSchema),
        omitEmpty: true
      }, {
        key: "assets",
        valueSchema: new OptionalSchema(new ArraySchema(AssetHolding3.encodingSchema)),
        omitEmpty: true
      }, {
        key: "auth-addr",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "closed-at-round",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "created-apps",
        valueSchema: new OptionalSchema(new ArraySchema(Application2.encodingSchema)),
        omitEmpty: true
      }, {
        key: "created-assets",
        valueSchema: new OptionalSchema(new ArraySchema(Asset2.encodingSchema)),
        omitEmpty: true
      }, {
        key: "created-at-round",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "deleted",
        valueSchema: new OptionalSchema(new BooleanSchema()),
        omitEmpty: true
      }, {
        key: "incentive-eligible",
        valueSchema: new OptionalSchema(new BooleanSchema()),
        omitEmpty: true
      }, {
        key: "last-heartbeat",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "last-proposed",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "participation",
        valueSchema: new OptionalSchema(AccountParticipation2.encodingSchema),
        omitEmpty: true
      }, {
        key: "reward-base",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "sig-type",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `Account` object.
   * @param address - the account public key
   * @param amount - total number of MicroAlgos in the account
   * @param amountWithoutPendingRewards - specifies the amount of MicroAlgos in the account, without the pending rewards.
   * @param minBalance - MicroAlgo balance required by the account.
   * The requirement grows based on asset and application usage.
   * @param pendingRewards - amount of MicroAlgos of pending rewards in this account.
   * @param rewards - total rewards of MicroAlgos the account has received, including pending rewards.
   * @param round - The round for which this information is relevant.
   * @param status - voting status of the account's MicroAlgos
   * * Offline - indicates that the associated account is delegated.
   * * Online - indicates that the associated account used as part of the delegation
   * pool.
   * * NotParticipating - indicates that the associated account is neither a
   * delegator nor a delegate.
   * @param totalAppsOptedIn - The count of all applications that have been opted in, equivalent to the count
   * of application local data (AppLocalState objects) stored in this account.
   * @param totalAssetsOptedIn - The count of all assets that have been opted in, equivalent to the count of
   * AssetHolding objects held by this account.
   * @param totalBoxBytes - For app-accounts only. The total number of bytes allocated for the keys and
   * values of boxes which belong to the associated application.
   * @param totalBoxes - For app-accounts only. The total number of boxes which belong to the associated
   * application.
   * @param totalCreatedApps - The count of all apps (AppParams objects) created by this account.
   * @param totalCreatedAssets - The count of all assets (AssetParams objects) created by this account.
   * @param appsLocalState - application local data stored in this account.
   * Note the raw object uses `map[int] -> AppLocalState` for this type.
   * @param appsTotalExtraPages - the sum of all extra application program pages for this account.
   * @param appsTotalSchema - the sum of all of the local schemas and global schemas in this account.
   * Note: the raw account uses `StateSchema` for this type.
   * @param assets - assets held by this account.
   * Note the raw object uses `map[int] -> AssetHolding` for this type.
   * @param authAddr - The address against which signing should be checked. If empty, the address of
   * the current account is used. This field can be updated in any transaction by
   * setting the RekeyTo field.
   * @param closedAtRound - Round during which this account was most recently closed.
   * @param createdApps - parameters of applications created by this account including app global data.
   * Note: the raw account uses `map[int] -> AppParams` for this type.
   * @param createdAssets - parameters of assets created by this account.
   * Note: the raw account uses `map[int] -> Asset` for this type.
   * @param createdAtRound - Round during which this account first appeared in a transaction.
   * @param deleted - Whether or not this account is currently closed.
   * @param incentiveEligible - can the account receive block incentives if its balance is in range at proposal
   * time.
   * @param lastHeartbeat - The round in which this account last went online, or explicitly renewed their
   * online status.
   * @param lastProposed - The round in which this account last proposed the block.
   * @param participation - AccountParticipation describes the parameters used by this account in consensus
   * protocol.
   * @param rewardBase - used as part of the rewards computation. Only applicable to accounts which are
   * participating.
   * @param sigType - the type of signature used by this account, must be one of:
   * * sig
   * * msig
   * * lsig
   * * or null if unknown
   */
  constructor({ address, amount, amountWithoutPendingRewards, minBalance, pendingRewards, rewards, round, status, totalAppsOptedIn, totalAssetsOptedIn, totalBoxBytes, totalBoxes, totalCreatedApps, totalCreatedAssets, appsLocalState, appsTotalExtraPages, appsTotalSchema, assets, authAddr, closedAtRound, createdApps, createdAssets, createdAtRound, deleted, incentiveEligible, lastHeartbeat, lastProposed, participation, rewardBase, sigType }) {
    this.address = address;
    this.amount = ensureBigInt(amount);
    this.amountWithoutPendingRewards = ensureBigInt(amountWithoutPendingRewards);
    this.minBalance = ensureSafeInteger(minBalance);
    this.pendingRewards = ensureBigInt(pendingRewards);
    this.rewards = ensureBigInt(rewards);
    this.round = ensureBigInt(round);
    this.status = status;
    this.totalAppsOptedIn = ensureSafeInteger(totalAppsOptedIn);
    this.totalAssetsOptedIn = ensureSafeInteger(totalAssetsOptedIn);
    this.totalBoxBytes = ensureSafeInteger(totalBoxBytes);
    this.totalBoxes = ensureSafeInteger(totalBoxes);
    this.totalCreatedApps = ensureSafeInteger(totalCreatedApps);
    this.totalCreatedAssets = ensureSafeInteger(totalCreatedAssets);
    this.appsLocalState = appsLocalState;
    this.appsTotalExtraPages = typeof appsTotalExtraPages === "undefined" ? void 0 : ensureSafeInteger(appsTotalExtraPages);
    this.appsTotalSchema = appsTotalSchema;
    this.assets = assets;
    this.authAddr = typeof authAddr === "string" ? Address.fromString(authAddr) : authAddr;
    this.closedAtRound = typeof closedAtRound === "undefined" ? void 0 : ensureBigInt(closedAtRound);
    this.createdApps = createdApps;
    this.createdAssets = createdAssets;
    this.createdAtRound = typeof createdAtRound === "undefined" ? void 0 : ensureBigInt(createdAtRound);
    this.deleted = deleted;
    this.incentiveEligible = incentiveEligible;
    this.lastHeartbeat = typeof lastHeartbeat === "undefined" ? void 0 : ensureSafeInteger(lastHeartbeat);
    this.lastProposed = typeof lastProposed === "undefined" ? void 0 : ensureSafeInteger(lastProposed);
    this.participation = participation;
    this.rewardBase = typeof rewardBase === "undefined" ? void 0 : ensureBigInt(rewardBase);
    this.sigType = sigType;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _Account.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["address", this.address],
      ["amount", this.amount],
      ["amount-without-pending-rewards", this.amountWithoutPendingRewards],
      ["min-balance", this.minBalance],
      ["pending-rewards", this.pendingRewards],
      ["rewards", this.rewards],
      ["round", this.round],
      ["status", this.status],
      ["total-apps-opted-in", this.totalAppsOptedIn],
      ["total-assets-opted-in", this.totalAssetsOptedIn],
      ["total-box-bytes", this.totalBoxBytes],
      ["total-boxes", this.totalBoxes],
      ["total-created-apps", this.totalCreatedApps],
      ["total-created-assets", this.totalCreatedAssets],
      [
        "apps-local-state",
        typeof this.appsLocalState !== "undefined" ? this.appsLocalState.map((v2) => v2.toEncodingData()) : void 0
      ],
      ["apps-total-extra-pages", this.appsTotalExtraPages],
      [
        "apps-total-schema",
        typeof this.appsTotalSchema !== "undefined" ? this.appsTotalSchema.toEncodingData() : void 0
      ],
      [
        "assets",
        typeof this.assets !== "undefined" ? this.assets.map((v2) => v2.toEncodingData()) : void 0
      ],
      [
        "auth-addr",
        typeof this.authAddr !== "undefined" ? this.authAddr.toString() : void 0
      ],
      ["closed-at-round", this.closedAtRound],
      [
        "created-apps",
        typeof this.createdApps !== "undefined" ? this.createdApps.map((v2) => v2.toEncodingData()) : void 0
      ],
      [
        "created-assets",
        typeof this.createdAssets !== "undefined" ? this.createdAssets.map((v2) => v2.toEncodingData()) : void 0
      ],
      ["created-at-round", this.createdAtRound],
      ["deleted", this.deleted],
      ["incentive-eligible", this.incentiveEligible],
      ["last-heartbeat", this.lastHeartbeat],
      ["last-proposed", this.lastProposed],
      [
        "participation",
        typeof this.participation !== "undefined" ? this.participation.toEncodingData() : void 0
      ],
      ["reward-base", this.rewardBase],
      ["sig-type", this.sigType]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded Account: ${data}`);
    }
    return new _Account({
      address: data.get("address"),
      amount: data.get("amount"),
      amountWithoutPendingRewards: data.get("amount-without-pending-rewards"),
      minBalance: data.get("min-balance"),
      pendingRewards: data.get("pending-rewards"),
      rewards: data.get("rewards"),
      round: data.get("round"),
      status: data.get("status"),
      totalAppsOptedIn: data.get("total-apps-opted-in"),
      totalAssetsOptedIn: data.get("total-assets-opted-in"),
      totalBoxBytes: data.get("total-box-bytes"),
      totalBoxes: data.get("total-boxes"),
      totalCreatedApps: data.get("total-created-apps"),
      totalCreatedAssets: data.get("total-created-assets"),
      appsLocalState: typeof data.get("apps-local-state") !== "undefined" ? data.get("apps-local-state").map((v2) => ApplicationLocalState2.fromEncodingData(v2)) : void 0,
      appsTotalExtraPages: data.get("apps-total-extra-pages"),
      appsTotalSchema: typeof data.get("apps-total-schema") !== "undefined" ? ApplicationStateSchema2.fromEncodingData(data.get("apps-total-schema")) : void 0,
      assets: typeof data.get("assets") !== "undefined" ? data.get("assets").map((v2) => AssetHolding3.fromEncodingData(v2)) : void 0,
      authAddr: data.get("auth-addr"),
      closedAtRound: data.get("closed-at-round"),
      createdApps: typeof data.get("created-apps") !== "undefined" ? data.get("created-apps").map((v2) => Application2.fromEncodingData(v2)) : void 0,
      createdAssets: typeof data.get("created-assets") !== "undefined" ? data.get("created-assets").map((v2) => Asset2.fromEncodingData(v2)) : void 0,
      createdAtRound: data.get("created-at-round"),
      deleted: data.get("deleted"),
      incentiveEligible: data.get("incentive-eligible"),
      lastHeartbeat: data.get("last-heartbeat"),
      lastProposed: data.get("last-proposed"),
      participation: typeof data.get("participation") !== "undefined" ? AccountParticipation2.fromEncodingData(data.get("participation")) : void 0,
      rewardBase: data.get("reward-base"),
      sigType: data.get("sig-type")
    });
  }
};
var AccountParticipation2 = class _AccountParticipation {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "selection-participation-key",
        valueSchema: new ByteArraySchema(),
        omitEmpty: true
      }, {
        key: "vote-first-valid",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "vote-key-dilution",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "vote-last-valid",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "vote-participation-key",
        valueSchema: new ByteArraySchema(),
        omitEmpty: true
      }, {
        key: "state-proof-key",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `AccountParticipation` object.
   * @param selectionParticipationKey - Selection public key (if any) currently registered for this round.
   * @param voteFirstValid - First round for which this participation is valid.
   * @param voteKeyDilution - Number of subkeys in each batch of participation keys.
   * @param voteLastValid - Last round for which this participation is valid.
   * @param voteParticipationKey - root participation public key (if any) currently registered for this round.
   * @param stateProofKey - Root of the state proof key (if any)
   */
  constructor({ selectionParticipationKey, voteFirstValid, voteKeyDilution, voteLastValid, voteParticipationKey, stateProofKey }) {
    this.selectionParticipationKey = typeof selectionParticipationKey === "string" ? base64ToBytes(selectionParticipationKey) : selectionParticipationKey;
    this.voteFirstValid = ensureBigInt(voteFirstValid);
    this.voteKeyDilution = ensureBigInt(voteKeyDilution);
    this.voteLastValid = ensureBigInt(voteLastValid);
    this.voteParticipationKey = typeof voteParticipationKey === "string" ? base64ToBytes(voteParticipationKey) : voteParticipationKey;
    this.stateProofKey = typeof stateProofKey === "string" ? base64ToBytes(stateProofKey) : stateProofKey;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AccountParticipation.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["selection-participation-key", this.selectionParticipationKey],
      ["vote-first-valid", this.voteFirstValid],
      ["vote-key-dilution", this.voteKeyDilution],
      ["vote-last-valid", this.voteLastValid],
      ["vote-participation-key", this.voteParticipationKey],
      ["state-proof-key", this.stateProofKey]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AccountParticipation: ${data}`);
    }
    return new _AccountParticipation({
      selectionParticipationKey: data.get("selection-participation-key"),
      voteFirstValid: data.get("vote-first-valid"),
      voteKeyDilution: data.get("vote-key-dilution"),
      voteLastValid: data.get("vote-last-valid"),
      voteParticipationKey: data.get("vote-participation-key"),
      stateProofKey: data.get("state-proof-key")
    });
  }
};
var AccountResponse = class _AccountResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "account",
        valueSchema: Account2.encodingSchema,
        omitEmpty: true
      }, {
        key: "current-round",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `AccountResponse` object.
   * @param account - Account information at a given round.
   * Definition:
   * data/basics/userBalance.go : AccountData
   * @param currentRound - Round at which the results were computed.
   */
  constructor({ account, currentRound }) {
    this.account = account;
    this.currentRound = ensureBigInt(currentRound);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AccountResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["account", this.account.toEncodingData()],
      ["current-round", this.currentRound]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AccountResponse: ${data}`);
    }
    return new _AccountResponse({
      account: Account2.fromEncodingData(data.get("account") ?? /* @__PURE__ */ new Map()),
      currentRound: data.get("current-round")
    });
  }
};
var AccountStateDelta2 = class _AccountStateDelta {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "address", valueSchema: new StringSchema(), omitEmpty: true }, {
        key: "delta",
        valueSchema: new ArraySchema(EvalDeltaKeyValue2.encodingSchema),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `AccountStateDelta` object.
   * @param address -
   * @param delta - Application state delta.
   */
  constructor({ address, delta }) {
    this.address = address;
    this.delta = delta;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AccountStateDelta.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["address", this.address],
      ["delta", this.delta.map((v2) => v2.toEncodingData())]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AccountStateDelta: ${data}`);
    }
    return new _AccountStateDelta({
      address: data.get("address"),
      delta: (data.get("delta") ?? []).map((v2) => EvalDeltaKeyValue2.fromEncodingData(v2))
    });
  }
};
var AccountsResponse = class _AccountsResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "accounts",
        valueSchema: new ArraySchema(Account2.encodingSchema),
        omitEmpty: true
      }, {
        key: "current-round",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "next-token",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `AccountsResponse` object.
   * @param accounts -
   * @param currentRound - Round at which the results were computed.
   * @param nextToken - Used for pagination, when making another request provide this token with the
   * next parameter.
   */
  constructor({ accounts, currentRound, nextToken }) {
    this.accounts = accounts;
    this.currentRound = ensureBigInt(currentRound);
    this.nextToken = nextToken;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AccountsResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["accounts", this.accounts.map((v2) => v2.toEncodingData())],
      ["current-round", this.currentRound],
      ["next-token", this.nextToken]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AccountsResponse: ${data}`);
    }
    return new _AccountsResponse({
      accounts: (data.get("accounts") ?? []).map((v2) => Account2.fromEncodingData(v2)),
      currentRound: data.get("current-round"),
      nextToken: data.get("next-token")
    });
  }
};
var Application2 = class _Application {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "id", valueSchema: new Uint64Schema(), omitEmpty: true }, {
        key: "params",
        valueSchema: ApplicationParams2.encodingSchema,
        omitEmpty: true
      }, {
        key: "created-at-round",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "deleted",
        valueSchema: new OptionalSchema(new BooleanSchema()),
        omitEmpty: true
      }, {
        key: "deleted-at-round",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `Application` object.
   * @param id - application index.
   * @param params - application parameters.
   * @param createdAtRound - Round when this application was created.
   * @param deleted - Whether or not this application is currently deleted.
   * @param deletedAtRound - Round when this application was deleted.
   */
  constructor({ id, params, createdAtRound, deleted, deletedAtRound }) {
    this.id = ensureBigInt(id);
    this.params = params;
    this.createdAtRound = typeof createdAtRound === "undefined" ? void 0 : ensureBigInt(createdAtRound);
    this.deleted = deleted;
    this.deletedAtRound = typeof deletedAtRound === "undefined" ? void 0 : ensureBigInt(deletedAtRound);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _Application.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["id", this.id],
      ["params", this.params.toEncodingData()],
      ["created-at-round", this.createdAtRound],
      ["deleted", this.deleted],
      ["deleted-at-round", this.deletedAtRound]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded Application: ${data}`);
    }
    return new _Application({
      id: data.get("id"),
      params: ApplicationParams2.fromEncodingData(data.get("params") ?? /* @__PURE__ */ new Map()),
      createdAtRound: data.get("created-at-round"),
      deleted: data.get("deleted"),
      deletedAtRound: data.get("deleted-at-round")
    });
  }
};
var ApplicationLocalState2 = class _ApplicationLocalState {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "id", valueSchema: new Uint64Schema(), omitEmpty: true }, {
        key: "schema",
        valueSchema: ApplicationStateSchema2.encodingSchema,
        omitEmpty: true
      }, {
        key: "closed-out-at-round",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "deleted",
        valueSchema: new OptionalSchema(new BooleanSchema()),
        omitEmpty: true
      }, {
        key: "key-value",
        valueSchema: new OptionalSchema(new ArraySchema(TealKeyValue2.encodingSchema)),
        omitEmpty: true
      }, {
        key: "opted-in-at-round",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `ApplicationLocalState` object.
   * @param id - The application which this local state is for.
   * @param schema - schema.
   * @param closedOutAtRound - Round when account closed out of the application.
   * @param deleted - Whether or not the application local state is currently deleted from its
   * account.
   * @param keyValue - storage.
   * @param optedInAtRound - Round when the account opted into the application.
   */
  constructor({ id, schema, closedOutAtRound, deleted, keyValue, optedInAtRound }) {
    this.id = ensureBigInt(id);
    this.schema = schema;
    this.closedOutAtRound = typeof closedOutAtRound === "undefined" ? void 0 : ensureBigInt(closedOutAtRound);
    this.deleted = deleted;
    this.keyValue = keyValue;
    this.optedInAtRound = typeof optedInAtRound === "undefined" ? void 0 : ensureBigInt(optedInAtRound);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _ApplicationLocalState.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["id", this.id],
      ["schema", this.schema.toEncodingData()],
      ["closed-out-at-round", this.closedOutAtRound],
      ["deleted", this.deleted],
      [
        "key-value",
        typeof this.keyValue !== "undefined" ? this.keyValue.map((v2) => v2.toEncodingData()) : void 0
      ],
      ["opted-in-at-round", this.optedInAtRound]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded ApplicationLocalState: ${data}`);
    }
    return new _ApplicationLocalState({
      id: data.get("id"),
      schema: ApplicationStateSchema2.fromEncodingData(data.get("schema") ?? /* @__PURE__ */ new Map()),
      closedOutAtRound: data.get("closed-out-at-round"),
      deleted: data.get("deleted"),
      keyValue: typeof data.get("key-value") !== "undefined" ? data.get("key-value").map((v2) => TealKeyValue2.fromEncodingData(v2)) : void 0,
      optedInAtRound: data.get("opted-in-at-round")
    });
  }
};
var ApplicationLocalStatesResponse = class _ApplicationLocalStatesResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "apps-local-states",
        valueSchema: new ArraySchema(ApplicationLocalState2.encodingSchema),
        omitEmpty: true
      }, {
        key: "current-round",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "next-token",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `ApplicationLocalStatesResponse` object.
   * @param appsLocalStates -
   * @param currentRound - Round at which the results were computed.
   * @param nextToken - Used for pagination, when making another request provide this token with the
   * next parameter.
   */
  constructor({ appsLocalStates, currentRound, nextToken }) {
    this.appsLocalStates = appsLocalStates;
    this.currentRound = ensureBigInt(currentRound);
    this.nextToken = nextToken;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _ApplicationLocalStatesResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      [
        "apps-local-states",
        this.appsLocalStates.map((v2) => v2.toEncodingData())
      ],
      ["current-round", this.currentRound],
      ["next-token", this.nextToken]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded ApplicationLocalStatesResponse: ${data}`);
    }
    return new _ApplicationLocalStatesResponse({
      appsLocalStates: (data.get("apps-local-states") ?? []).map((v2) => ApplicationLocalState2.fromEncodingData(v2)),
      currentRound: data.get("current-round"),
      nextToken: data.get("next-token")
    });
  }
};
var ApplicationLogData = class _ApplicationLogData {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "logs",
        valueSchema: new ArraySchema(new ByteArraySchema()),
        omitEmpty: true
      }, { key: "txid", valueSchema: new StringSchema(), omitEmpty: true });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `ApplicationLogData` object.
   * @param logs - Logs for the application being executed by the transaction.
   * @param txid - Transaction ID
   */
  constructor({ logs, txid }) {
    this.logs = logs;
    this.txid = txid;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _ApplicationLogData.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["logs", this.logs],
      ["txid", this.txid]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded ApplicationLogData: ${data}`);
    }
    return new _ApplicationLogData({
      logs: data.get("logs"),
      txid: data.get("txid")
    });
  }
};
var ApplicationLogsResponse = class _ApplicationLogsResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "application-id",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "current-round",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "log-data",
        valueSchema: new OptionalSchema(new ArraySchema(ApplicationLogData.encodingSchema)),
        omitEmpty: true
      }, {
        key: "next-token",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `ApplicationLogsResponse` object.
   * @param applicationId - (appidx) application index.
   * @param currentRound - Round at which the results were computed.
   * @param logData -
   * @param nextToken - Used for pagination, when making another request provide this token with the
   * next parameter.
   */
  constructor({ applicationId, currentRound, logData, nextToken }) {
    this.applicationId = ensureBigInt(applicationId);
    this.currentRound = ensureBigInt(currentRound);
    this.logData = logData;
    this.nextToken = nextToken;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _ApplicationLogsResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["application-id", this.applicationId],
      ["current-round", this.currentRound],
      [
        "log-data",
        typeof this.logData !== "undefined" ? this.logData.map((v2) => v2.toEncodingData()) : void 0
      ],
      ["next-token", this.nextToken]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded ApplicationLogsResponse: ${data}`);
    }
    return new _ApplicationLogsResponse({
      applicationId: data.get("application-id"),
      currentRound: data.get("current-round"),
      logData: typeof data.get("log-data") !== "undefined" ? data.get("log-data").map((v2) => ApplicationLogData.fromEncodingData(v2)) : void 0,
      nextToken: data.get("next-token")
    });
  }
};
var ApplicationParams2 = class _ApplicationParams {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "approval-program",
        valueSchema: new ByteArraySchema(),
        omitEmpty: true
      }, {
        key: "clear-state-program",
        valueSchema: new ByteArraySchema(),
        omitEmpty: true
      }, {
        key: "creator",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "extra-program-pages",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "global-state",
        valueSchema: new OptionalSchema(new ArraySchema(TealKeyValue2.encodingSchema)),
        omitEmpty: true
      }, {
        key: "global-state-schema",
        valueSchema: new OptionalSchema(ApplicationStateSchema2.encodingSchema),
        omitEmpty: true
      }, {
        key: "local-state-schema",
        valueSchema: new OptionalSchema(ApplicationStateSchema2.encodingSchema),
        omitEmpty: true
      }, {
        key: "version",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `ApplicationParams` object.
   * @param approvalProgram - approval program.
   * @param clearStateProgram - clear state program.
   * @param creator - The address that created this application. This is the address where the
   * parameters and global state for this application can be found.
   * @param extraProgramPages - the number of extra program pages available to this app.
   * @param globalState - global state
   * @param globalStateSchema - global schema
   * @param localStateSchema - local schema
   * @param version - the number of updates to the application programs
   */
  constructor({ approvalProgram, clearStateProgram, creator, extraProgramPages, globalState, globalStateSchema, localStateSchema, version }) {
    this.approvalProgram = typeof approvalProgram === "string" ? base64ToBytes(approvalProgram) : approvalProgram;
    this.clearStateProgram = typeof clearStateProgram === "string" ? base64ToBytes(clearStateProgram) : clearStateProgram;
    this.creator = typeof creator === "string" ? Address.fromString(creator) : creator;
    this.extraProgramPages = typeof extraProgramPages === "undefined" ? void 0 : ensureSafeInteger(extraProgramPages);
    this.globalState = globalState;
    this.globalStateSchema = globalStateSchema;
    this.localStateSchema = localStateSchema;
    this.version = typeof version === "undefined" ? void 0 : ensureSafeInteger(version);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _ApplicationParams.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["approval-program", this.approvalProgram],
      ["clear-state-program", this.clearStateProgram],
      [
        "creator",
        typeof this.creator !== "undefined" ? this.creator.toString() : void 0
      ],
      ["extra-program-pages", this.extraProgramPages],
      [
        "global-state",
        typeof this.globalState !== "undefined" ? this.globalState.map((v2) => v2.toEncodingData()) : void 0
      ],
      [
        "global-state-schema",
        typeof this.globalStateSchema !== "undefined" ? this.globalStateSchema.toEncodingData() : void 0
      ],
      [
        "local-state-schema",
        typeof this.localStateSchema !== "undefined" ? this.localStateSchema.toEncodingData() : void 0
      ],
      ["version", this.version]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded ApplicationParams: ${data}`);
    }
    return new _ApplicationParams({
      approvalProgram: data.get("approval-program"),
      clearStateProgram: data.get("clear-state-program"),
      creator: data.get("creator"),
      extraProgramPages: data.get("extra-program-pages"),
      globalState: typeof data.get("global-state") !== "undefined" ? data.get("global-state").map((v2) => TealKeyValue2.fromEncodingData(v2)) : void 0,
      globalStateSchema: typeof data.get("global-state-schema") !== "undefined" ? ApplicationStateSchema2.fromEncodingData(data.get("global-state-schema")) : void 0,
      localStateSchema: typeof data.get("local-state-schema") !== "undefined" ? ApplicationStateSchema2.fromEncodingData(data.get("local-state-schema")) : void 0,
      version: data.get("version")
    });
  }
};
var ApplicationResponse = class _ApplicationResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "current-round",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "application",
        valueSchema: new OptionalSchema(Application2.encodingSchema),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `ApplicationResponse` object.
   * @param currentRound - Round at which the results were computed.
   * @param application - Application index and its parameters
   */
  constructor({ currentRound, application }) {
    this.currentRound = ensureBigInt(currentRound);
    this.application = application;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _ApplicationResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["current-round", this.currentRound],
      [
        "application",
        typeof this.application !== "undefined" ? this.application.toEncodingData() : void 0
      ]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded ApplicationResponse: ${data}`);
    }
    return new _ApplicationResponse({
      currentRound: data.get("current-round"),
      application: typeof data.get("application") !== "undefined" ? Application2.fromEncodingData(data.get("application")) : void 0
    });
  }
};
var ApplicationStateSchema2 = class _ApplicationStateSchema {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "num-byte-slice",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, { key: "num-uint", valueSchema: new Uint64Schema(), omitEmpty: true });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `ApplicationStateSchema` object.
   * @param numByteSlice - number of byte slices.
   * @param numUint - number of uints.
   */
  constructor({ numByteSlice, numUint }) {
    this.numByteSlice = ensureSafeInteger(numByteSlice);
    this.numUint = ensureSafeInteger(numUint);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _ApplicationStateSchema.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["num-byte-slice", this.numByteSlice],
      ["num-uint", this.numUint]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded ApplicationStateSchema: ${data}`);
    }
    return new _ApplicationStateSchema({
      numByteSlice: data.get("num-byte-slice"),
      numUint: data.get("num-uint")
    });
  }
};
var ApplicationsResponse = class _ApplicationsResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "applications",
        valueSchema: new ArraySchema(Application2.encodingSchema),
        omitEmpty: true
      }, {
        key: "current-round",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "next-token",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `ApplicationsResponse` object.
   * @param applications -
   * @param currentRound - Round at which the results were computed.
   * @param nextToken - Used for pagination, when making another request provide this token with the
   * next parameter.
   */
  constructor({ applications, currentRound, nextToken }) {
    this.applications = applications;
    this.currentRound = ensureBigInt(currentRound);
    this.nextToken = nextToken;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _ApplicationsResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["applications", this.applications.map((v2) => v2.toEncodingData())],
      ["current-round", this.currentRound],
      ["next-token", this.nextToken]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded ApplicationsResponse: ${data}`);
    }
    return new _ApplicationsResponse({
      applications: (data.get("applications") ?? []).map((v2) => Application2.fromEncodingData(v2)),
      currentRound: data.get("current-round"),
      nextToken: data.get("next-token")
    });
  }
};
var Asset2 = class _Asset {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "index", valueSchema: new Uint64Schema(), omitEmpty: true }, {
        key: "params",
        valueSchema: AssetParams3.encodingSchema,
        omitEmpty: true
      }, {
        key: "created-at-round",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "deleted",
        valueSchema: new OptionalSchema(new BooleanSchema()),
        omitEmpty: true
      }, {
        key: "destroyed-at-round",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `Asset` object.
   * @param index - unique asset identifier
   * @param params - AssetParams specifies the parameters for an asset.
   * (apar) when part of an AssetConfig transaction.
   * Definition:
   * data/transactions/asset.go : AssetParams
   * @param createdAtRound - Round during which this asset was created.
   * @param deleted - Whether or not this asset is currently deleted.
   * @param destroyedAtRound - Round during which this asset was destroyed.
   */
  constructor({ index, params, createdAtRound, deleted, destroyedAtRound }) {
    this.index = ensureBigInt(index);
    this.params = params;
    this.createdAtRound = typeof createdAtRound === "undefined" ? void 0 : ensureBigInt(createdAtRound);
    this.deleted = deleted;
    this.destroyedAtRound = typeof destroyedAtRound === "undefined" ? void 0 : ensureBigInt(destroyedAtRound);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _Asset.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["index", this.index],
      ["params", this.params.toEncodingData()],
      ["created-at-round", this.createdAtRound],
      ["deleted", this.deleted],
      ["destroyed-at-round", this.destroyedAtRound]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded Asset: ${data}`);
    }
    return new _Asset({
      index: data.get("index"),
      params: AssetParams3.fromEncodingData(data.get("params") ?? /* @__PURE__ */ new Map()),
      createdAtRound: data.get("created-at-round"),
      deleted: data.get("deleted"),
      destroyedAtRound: data.get("destroyed-at-round")
    });
  }
};
var AssetBalancesResponse = class _AssetBalancesResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "balances",
        valueSchema: new ArraySchema(MiniAssetHolding.encodingSchema),
        omitEmpty: true
      }, {
        key: "current-round",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "next-token",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `AssetBalancesResponse` object.
   * @param balances -
   * @param currentRound - Round at which the results were computed.
   * @param nextToken - Used for pagination, when making another request provide this token with the
   * next parameter.
   */
  constructor({ balances, currentRound, nextToken }) {
    this.balances = balances;
    this.currentRound = ensureBigInt(currentRound);
    this.nextToken = nextToken;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AssetBalancesResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["balances", this.balances.map((v2) => v2.toEncodingData())],
      ["current-round", this.currentRound],
      ["next-token", this.nextToken]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AssetBalancesResponse: ${data}`);
    }
    return new _AssetBalancesResponse({
      balances: (data.get("balances") ?? []).map((v2) => MiniAssetHolding.fromEncodingData(v2)),
      currentRound: data.get("current-round"),
      nextToken: data.get("next-token")
    });
  }
};
var AssetHolding3 = class _AssetHolding {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "amount", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "asset-id", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "is-frozen", valueSchema: new BooleanSchema(), omitEmpty: true }, {
        key: "deleted",
        valueSchema: new OptionalSchema(new BooleanSchema()),
        omitEmpty: true
      }, {
        key: "opted-in-at-round",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "opted-out-at-round",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `AssetHolding` object.
   * @param amount - number of units held.
   * @param assetId - Asset ID of the holding.
   * @param isFrozen - whether or not the holding is frozen.
   * @param deleted - Whether or not the asset holding is currently deleted from its account.
   * @param optedInAtRound - Round during which the account opted into this asset holding.
   * @param optedOutAtRound - Round during which the account opted out of this asset holding.
   */
  constructor({ amount, assetId, isFrozen, deleted, optedInAtRound, optedOutAtRound }) {
    this.amount = ensureBigInt(amount);
    this.assetId = ensureBigInt(assetId);
    this.isFrozen = isFrozen;
    this.deleted = deleted;
    this.optedInAtRound = typeof optedInAtRound === "undefined" ? void 0 : ensureBigInt(optedInAtRound);
    this.optedOutAtRound = typeof optedOutAtRound === "undefined" ? void 0 : ensureBigInt(optedOutAtRound);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AssetHolding.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["amount", this.amount],
      ["asset-id", this.assetId],
      ["is-frozen", this.isFrozen],
      ["deleted", this.deleted],
      ["opted-in-at-round", this.optedInAtRound],
      ["opted-out-at-round", this.optedOutAtRound]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AssetHolding: ${data}`);
    }
    return new _AssetHolding({
      amount: data.get("amount"),
      assetId: data.get("asset-id"),
      isFrozen: data.get("is-frozen"),
      deleted: data.get("deleted"),
      optedInAtRound: data.get("opted-in-at-round"),
      optedOutAtRound: data.get("opted-out-at-round")
    });
  }
};
var AssetHoldingsResponse = class _AssetHoldingsResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "assets",
        valueSchema: new ArraySchema(AssetHolding3.encodingSchema),
        omitEmpty: true
      }, {
        key: "current-round",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "next-token",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `AssetHoldingsResponse` object.
   * @param assets -
   * @param currentRound - Round at which the results were computed.
   * @param nextToken - Used for pagination, when making another request provide this token with the
   * next parameter.
   */
  constructor({ assets, currentRound, nextToken }) {
    this.assets = assets;
    this.currentRound = ensureBigInt(currentRound);
    this.nextToken = nextToken;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AssetHoldingsResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["assets", this.assets.map((v2) => v2.toEncodingData())],
      ["current-round", this.currentRound],
      ["next-token", this.nextToken]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AssetHoldingsResponse: ${data}`);
    }
    return new _AssetHoldingsResponse({
      assets: (data.get("assets") ?? []).map((v2) => AssetHolding3.fromEncodingData(v2)),
      currentRound: data.get("current-round"),
      nextToken: data.get("next-token")
    });
  }
};
var AssetParams3 = class _AssetParams {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "creator", valueSchema: new StringSchema(), omitEmpty: true }, { key: "decimals", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "total", valueSchema: new Uint64Schema(), omitEmpty: true }, {
        key: "clawback",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "default-frozen",
        valueSchema: new OptionalSchema(new BooleanSchema()),
        omitEmpty: true
      }, {
        key: "freeze",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "manager",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "metadata-hash",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      }, {
        key: "name",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "name-b64",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      }, {
        key: "reserve",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "unit-name",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "unit-name-b64",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      }, {
        key: "url",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "url-b64",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `AssetParams` object.
   * @param creator - The address that created this asset. This is the address where the parameters
   * for this asset can be found, and also the address where unwanted asset units can
   * be sent in the worst case.
   * @param decimals - The number of digits to use after the decimal point when displaying this asset.
   * If 0, the asset is not divisible. If 1, the base unit of the asset is in tenths.
   * If 2, the base unit of the asset is in hundredths, and so on. This value must be
   * between 0 and 19 (inclusive).
   * @param total - The total number of units of this asset.
   * @param clawback - Address of account used to clawback holdings of this asset. If empty, clawback
   * is not permitted.
   * @param defaultFrozen - Whether holdings of this asset are frozen by default.
   * @param freeze - Address of account used to freeze holdings of this asset. If empty, freezing is
   * not permitted.
   * @param manager - Address of account used to manage the keys of this asset and to destroy it.
   * @param metadataHash - A commitment to some unspecified asset metadata. The format of this metadata is
   * up to the application.
   * @param name - Name of this asset, as supplied by the creator. Included only when the asset
   * name is composed of printable utf-8 characters.
   * @param nameB64 - Base64 encoded name of this asset, as supplied by the creator.
   * @param reserve - Address of account holding reserve (non-minted) units of this asset.
   * @param unitName - Name of a unit of this asset, as supplied by the creator. Included only when the
   * name of a unit of this asset is composed of printable utf-8 characters.
   * @param unitNameB64 - Base64 encoded name of a unit of this asset, as supplied by the creator.
   * @param url - URL where more information about the asset can be retrieved. Included only when
   * the URL is composed of printable utf-8 characters.
   * @param urlB64 - Base64 encoded URL where more information about the asset can be retrieved.
   */
  constructor({ creator, decimals, total, clawback, defaultFrozen, freeze, manager, metadataHash, name, nameB64, reserve, unitName, unitNameB64, url, urlB64 }) {
    this.creator = creator;
    this.decimals = ensureSafeInteger(decimals);
    this.total = ensureBigInt(total);
    this.clawback = clawback;
    this.defaultFrozen = defaultFrozen;
    this.freeze = freeze;
    this.manager = manager;
    this.metadataHash = typeof metadataHash === "string" ? base64ToBytes(metadataHash) : metadataHash;
    this.name = name;
    this.nameB64 = typeof nameB64 === "string" ? base64ToBytes(nameB64) : nameB64;
    this.reserve = reserve;
    this.unitName = unitName;
    this.unitNameB64 = typeof unitNameB64 === "string" ? base64ToBytes(unitNameB64) : unitNameB64;
    this.url = url;
    this.urlB64 = typeof urlB64 === "string" ? base64ToBytes(urlB64) : urlB64;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AssetParams.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["creator", this.creator],
      ["decimals", this.decimals],
      ["total", this.total],
      ["clawback", this.clawback],
      ["default-frozen", this.defaultFrozen],
      ["freeze", this.freeze],
      ["manager", this.manager],
      ["metadata-hash", this.metadataHash],
      ["name", this.name],
      ["name-b64", this.nameB64],
      ["reserve", this.reserve],
      ["unit-name", this.unitName],
      ["unit-name-b64", this.unitNameB64],
      ["url", this.url],
      ["url-b64", this.urlB64]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AssetParams: ${data}`);
    }
    return new _AssetParams({
      creator: data.get("creator"),
      decimals: data.get("decimals"),
      total: data.get("total"),
      clawback: data.get("clawback"),
      defaultFrozen: data.get("default-frozen"),
      freeze: data.get("freeze"),
      manager: data.get("manager"),
      metadataHash: data.get("metadata-hash"),
      name: data.get("name"),
      nameB64: data.get("name-b64"),
      reserve: data.get("reserve"),
      unitName: data.get("unit-name"),
      unitNameB64: data.get("unit-name-b64"),
      url: data.get("url"),
      urlB64: data.get("url-b64")
    });
  }
};
var AssetResponse = class _AssetResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "asset", valueSchema: Asset2.encodingSchema, omitEmpty: true }, {
        key: "current-round",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `AssetResponse` object.
   * @param asset - Specifies both the unique identifier and the parameters for an asset
   * @param currentRound - Round at which the results were computed.
   */
  constructor({ asset, currentRound }) {
    this.asset = asset;
    this.currentRound = ensureBigInt(currentRound);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AssetResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["asset", this.asset.toEncodingData()],
      ["current-round", this.currentRound]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AssetResponse: ${data}`);
    }
    return new _AssetResponse({
      asset: Asset2.fromEncodingData(data.get("asset") ?? /* @__PURE__ */ new Map()),
      currentRound: data.get("current-round")
    });
  }
};
var AssetsResponse = class _AssetsResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "assets",
        valueSchema: new ArraySchema(Asset2.encodingSchema),
        omitEmpty: true
      }, {
        key: "current-round",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "next-token",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `AssetsResponse` object.
   * @param assets -
   * @param currentRound - Round at which the results were computed.
   * @param nextToken - Used for pagination, when making another request provide this token with the
   * next parameter.
   */
  constructor({ assets, currentRound, nextToken }) {
    this.assets = assets;
    this.currentRound = ensureBigInt(currentRound);
    this.nextToken = nextToken;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _AssetsResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["assets", this.assets.map((v2) => v2.toEncodingData())],
      ["current-round", this.currentRound],
      ["next-token", this.nextToken]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded AssetsResponse: ${data}`);
    }
    return new _AssetsResponse({
      assets: (data.get("assets") ?? []).map((v2) => Asset2.fromEncodingData(v2)),
      currentRound: data.get("current-round"),
      nextToken: data.get("next-token")
    });
  }
};
var Block3 = class _Block {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "genesis-hash",
        valueSchema: new ByteArraySchema(),
        omitEmpty: true
      }, { key: "genesis-id", valueSchema: new StringSchema(), omitEmpty: true }, {
        key: "previous-block-hash",
        valueSchema: new ByteArraySchema(),
        omitEmpty: true
      }, { key: "round", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "seed", valueSchema: new ByteArraySchema(), omitEmpty: true }, { key: "timestamp", valueSchema: new Uint64Schema(), omitEmpty: true }, {
        key: "transactions-root",
        valueSchema: new ByteArraySchema(),
        omitEmpty: true
      }, {
        key: "transactions-root-sha256",
        valueSchema: new ByteArraySchema(),
        omitEmpty: true
      }, {
        key: "bonus",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "fees-collected",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "participation-updates",
        valueSchema: new OptionalSchema(ParticipationUpdates2.encodingSchema),
        omitEmpty: true
      }, {
        key: "previous-block-hash-512",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      }, {
        key: "proposer",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "proposer-payout",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "rewards",
        valueSchema: new OptionalSchema(BlockRewards.encodingSchema),
        omitEmpty: true
      }, {
        key: "state-proof-tracking",
        valueSchema: new OptionalSchema(new ArraySchema(StateProofTracking.encodingSchema)),
        omitEmpty: true
      }, {
        key: "transactions",
        valueSchema: new OptionalSchema(new ArraySchema(Transaction2.encodingSchema)),
        omitEmpty: true
      }, {
        key: "transactions-root-sha512",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      }, {
        key: "txn-counter",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "upgrade-state",
        valueSchema: new OptionalSchema(BlockUpgradeState.encodingSchema),
        omitEmpty: true
      }, {
        key: "upgrade-vote",
        valueSchema: new OptionalSchema(BlockUpgradeVote.encodingSchema),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `Block` object.
   * @param genesisHash - (gh) hash to which this block belongs.
   * @param genesisId - (gen) ID to which this block belongs.
   * @param previousBlockHash - (prev) Previous block hash.
   * @param round - (rnd) Current round on which this block was appended to the chain.
   * @param seed - (seed) Sortition seed.
   * @param timestamp - (ts) Block creation timestamp in seconds since eposh
   * @param transactionsRoot - (txn) TransactionsRoot authenticates the set of transactions appearing in the
   * block. More specifically, it's the root of a merkle tree whose leaves are the
   * block's Txids, in lexicographic order. For the empty block, it's 0. Note that
   * the TxnRoot does not authenticate the signatures on the transactions, only the
   * transactions themselves. Two blocks with the same transactions but in a
   * different order and with different signatures will have the same TxnRoot.
   * @param transactionsRootSha256 - (txn256) TransactionsRootSHA256 is an auxiliary TransactionRoot, built using a
   * vector commitment instead of a merkle tree, and SHA256 hash function instead of
   * the default SHA512_256. This commitment can be used on environments where only
   * the SHA256 function exists.
   * @param bonus - the potential bonus payout for this block.
   * @param feesCollected - the sum of all fees paid by transactions in this block.
   * @param participationUpdates - Participation account data that needs to be checked/acted on by the network.
   * @param previousBlockHash512 - (prev512) Previous block hash, using SHA-512.
   * @param proposer - the proposer of this block.
   * @param proposerPayout - the actual amount transferred to the proposer from the fee sink.
   * @param rewards - Fields relating to rewards,
   * @param stateProofTracking - Tracks the status of state proofs.
   * @param transactions - (txns) list of transactions corresponding to a given round.
   * @param transactionsRootSha512 - (txn512) TransactionsRootSHA512 is an auxiliary TransactionRoot, built using a
   * vector commitment instead of a merkle tree, and SHA512 hash function instead of
   * the default SHA512_256.
   * @param txnCounter - (tc) TxnCounter counts the number of transactions committed in the ledger, from
   * the time at which support for this feature was introduced.
   * Specifically, TxnCounter is the number of the next transaction that will be
   * committed after this block. It is 0 when no transactions have ever been
   * committed (since TxnCounter started being supported).
   * @param upgradeState - Fields relating to a protocol upgrade.
   * @param upgradeVote - Fields relating to voting for a protocol upgrade.
   */
  constructor({ genesisHash, genesisId, previousBlockHash, round, seed, timestamp, transactionsRoot, transactionsRootSha256, bonus, feesCollected, participationUpdates, previousBlockHash512, proposer, proposerPayout, rewards, stateProofTracking, transactions, transactionsRootSha512, txnCounter, upgradeState, upgradeVote }) {
    this.genesisHash = typeof genesisHash === "string" ? base64ToBytes(genesisHash) : genesisHash;
    this.genesisId = genesisId;
    this.previousBlockHash = typeof previousBlockHash === "string" ? base64ToBytes(previousBlockHash) : previousBlockHash;
    this.round = ensureBigInt(round);
    this.seed = typeof seed === "string" ? base64ToBytes(seed) : seed;
    this.timestamp = ensureSafeInteger(timestamp);
    this.transactionsRoot = typeof transactionsRoot === "string" ? base64ToBytes(transactionsRoot) : transactionsRoot;
    this.transactionsRootSha256 = typeof transactionsRootSha256 === "string" ? base64ToBytes(transactionsRootSha256) : transactionsRootSha256;
    this.bonus = typeof bonus === "undefined" ? void 0 : ensureSafeInteger(bonus);
    this.feesCollected = typeof feesCollected === "undefined" ? void 0 : ensureSafeInteger(feesCollected);
    this.participationUpdates = participationUpdates;
    this.previousBlockHash512 = typeof previousBlockHash512 === "string" ? base64ToBytes(previousBlockHash512) : previousBlockHash512;
    this.proposer = typeof proposer === "string" ? Address.fromString(proposer) : proposer;
    this.proposerPayout = typeof proposerPayout === "undefined" ? void 0 : ensureSafeInteger(proposerPayout);
    this.rewards = rewards;
    this.stateProofTracking = stateProofTracking;
    this.transactions = transactions;
    this.transactionsRootSha512 = typeof transactionsRootSha512 === "string" ? base64ToBytes(transactionsRootSha512) : transactionsRootSha512;
    this.txnCounter = typeof txnCounter === "undefined" ? void 0 : ensureSafeInteger(txnCounter);
    this.upgradeState = upgradeState;
    this.upgradeVote = upgradeVote;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _Block.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["genesis-hash", this.genesisHash],
      ["genesis-id", this.genesisId],
      ["previous-block-hash", this.previousBlockHash],
      ["round", this.round],
      ["seed", this.seed],
      ["timestamp", this.timestamp],
      ["transactions-root", this.transactionsRoot],
      ["transactions-root-sha256", this.transactionsRootSha256],
      ["bonus", this.bonus],
      ["fees-collected", this.feesCollected],
      [
        "participation-updates",
        typeof this.participationUpdates !== "undefined" ? this.participationUpdates.toEncodingData() : void 0
      ],
      ["previous-block-hash-512", this.previousBlockHash512],
      [
        "proposer",
        typeof this.proposer !== "undefined" ? this.proposer.toString() : void 0
      ],
      ["proposer-payout", this.proposerPayout],
      [
        "rewards",
        typeof this.rewards !== "undefined" ? this.rewards.toEncodingData() : void 0
      ],
      [
        "state-proof-tracking",
        typeof this.stateProofTracking !== "undefined" ? this.stateProofTracking.map((v2) => v2.toEncodingData()) : void 0
      ],
      [
        "transactions",
        typeof this.transactions !== "undefined" ? this.transactions.map((v2) => v2.toEncodingData()) : void 0
      ],
      ["transactions-root-sha512", this.transactionsRootSha512],
      ["txn-counter", this.txnCounter],
      [
        "upgrade-state",
        typeof this.upgradeState !== "undefined" ? this.upgradeState.toEncodingData() : void 0
      ],
      [
        "upgrade-vote",
        typeof this.upgradeVote !== "undefined" ? this.upgradeVote.toEncodingData() : void 0
      ]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded Block: ${data}`);
    }
    return new _Block({
      genesisHash: data.get("genesis-hash"),
      genesisId: data.get("genesis-id"),
      previousBlockHash: data.get("previous-block-hash"),
      round: data.get("round"),
      seed: data.get("seed"),
      timestamp: data.get("timestamp"),
      transactionsRoot: data.get("transactions-root"),
      transactionsRootSha256: data.get("transactions-root-sha256"),
      bonus: data.get("bonus"),
      feesCollected: data.get("fees-collected"),
      participationUpdates: typeof data.get("participation-updates") !== "undefined" ? ParticipationUpdates2.fromEncodingData(data.get("participation-updates")) : void 0,
      previousBlockHash512: data.get("previous-block-hash-512"),
      proposer: data.get("proposer"),
      proposerPayout: data.get("proposer-payout"),
      rewards: typeof data.get("rewards") !== "undefined" ? BlockRewards.fromEncodingData(data.get("rewards")) : void 0,
      stateProofTracking: typeof data.get("state-proof-tracking") !== "undefined" ? data.get("state-proof-tracking").map((v2) => StateProofTracking.fromEncodingData(v2)) : void 0,
      transactions: typeof data.get("transactions") !== "undefined" ? data.get("transactions").map((v2) => Transaction2.fromEncodingData(v2)) : void 0,
      transactionsRootSha512: data.get("transactions-root-sha512"),
      txnCounter: data.get("txn-counter"),
      upgradeState: typeof data.get("upgrade-state") !== "undefined" ? BlockUpgradeState.fromEncodingData(data.get("upgrade-state")) : void 0,
      upgradeVote: typeof data.get("upgrade-vote") !== "undefined" ? BlockUpgradeVote.fromEncodingData(data.get("upgrade-vote")) : void 0
    });
  }
};
var BlockHeadersResponse = class _BlockHeadersResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "blocks",
        valueSchema: new ArraySchema(Block3.encodingSchema),
        omitEmpty: true
      }, {
        key: "current-round",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "next-token",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `BlockHeadersResponse` object.
   * @param blocks -
   * @param currentRound - Round at which the results were computed.
   * @param nextToken - Used for pagination, when making another request provide this token with the
   * next parameter.
   */
  constructor({ blocks, currentRound, nextToken }) {
    this.blocks = blocks;
    this.currentRound = ensureBigInt(currentRound);
    this.nextToken = nextToken;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _BlockHeadersResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["blocks", this.blocks.map((v2) => v2.toEncodingData())],
      ["current-round", this.currentRound],
      ["next-token", this.nextToken]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded BlockHeadersResponse: ${data}`);
    }
    return new _BlockHeadersResponse({
      blocks: (data.get("blocks") ?? []).map((v2) => Block3.fromEncodingData(v2)),
      currentRound: data.get("current-round"),
      nextToken: data.get("next-token")
    });
  }
};
var BlockRewards = class _BlockRewards {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "fee-sink", valueSchema: new StringSchema(), omitEmpty: true }, {
        key: "rewards-calculation-round",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "rewards-level",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "rewards-pool",
        valueSchema: new StringSchema(),
        omitEmpty: true
      }, {
        key: "rewards-rate",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "rewards-residue",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `BlockRewards` object.
   * @param feeSink - (fees) accepts transaction fees, it can only spend to the incentive pool.
   * @param rewardsCalculationRound - (rwcalr) number of leftover MicroAlgos after the distribution of rewards-rate
   * MicroAlgos for every reward unit in the next round.
   * @param rewardsLevel - (earn) How many rewards, in MicroAlgos, have been distributed to each RewardUnit
   * of MicroAlgos since genesis.
   * @param rewardsPool - (rwd) accepts periodic injections from the fee-sink and continually
   * redistributes them as rewards.
   * @param rewardsRate - (rate) Number of new MicroAlgos added to the participation stake from rewards at
   * the next round.
   * @param rewardsResidue - (frac) Number of leftover MicroAlgos after the distribution of
   * RewardsRate/rewardUnits MicroAlgos for every reward unit in the next round.
   */
  constructor({ feeSink, rewardsCalculationRound, rewardsLevel, rewardsPool, rewardsRate, rewardsResidue }) {
    this.feeSink = feeSink;
    this.rewardsCalculationRound = ensureBigInt(rewardsCalculationRound);
    this.rewardsLevel = ensureBigInt(rewardsLevel);
    this.rewardsPool = rewardsPool;
    this.rewardsRate = ensureBigInt(rewardsRate);
    this.rewardsResidue = ensureBigInt(rewardsResidue);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _BlockRewards.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["fee-sink", this.feeSink],
      ["rewards-calculation-round", this.rewardsCalculationRound],
      ["rewards-level", this.rewardsLevel],
      ["rewards-pool", this.rewardsPool],
      ["rewards-rate", this.rewardsRate],
      ["rewards-residue", this.rewardsResidue]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded BlockRewards: ${data}`);
    }
    return new _BlockRewards({
      feeSink: data.get("fee-sink"),
      rewardsCalculationRound: data.get("rewards-calculation-round"),
      rewardsLevel: data.get("rewards-level"),
      rewardsPool: data.get("rewards-pool"),
      rewardsRate: data.get("rewards-rate"),
      rewardsResidue: data.get("rewards-residue")
    });
  }
};
var BlockUpgradeState = class _BlockUpgradeState {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "current-protocol",
        valueSchema: new StringSchema(),
        omitEmpty: true
      }, {
        key: "next-protocol",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "next-protocol-approvals",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "next-protocol-switch-on",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "next-protocol-vote-before",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `BlockUpgradeState` object.
   * @param currentProtocol - (proto) The current protocol version.
   * @param nextProtocol - (nextproto) The next proposed protocol version.
   * @param nextProtocolApprovals - (nextyes) Number of blocks which approved the protocol upgrade.
   * @param nextProtocolSwitchOn - (nextswitch) Round on which the protocol upgrade will take effect.
   * @param nextProtocolVoteBefore - (nextbefore) Deadline round for this protocol upgrade (No votes will be consider
   * after this round).
   */
  constructor({ currentProtocol, nextProtocol, nextProtocolApprovals, nextProtocolSwitchOn, nextProtocolVoteBefore }) {
    this.currentProtocol = currentProtocol;
    this.nextProtocol = nextProtocol;
    this.nextProtocolApprovals = typeof nextProtocolApprovals === "undefined" ? void 0 : ensureSafeInteger(nextProtocolApprovals);
    this.nextProtocolSwitchOn = typeof nextProtocolSwitchOn === "undefined" ? void 0 : ensureBigInt(nextProtocolSwitchOn);
    this.nextProtocolVoteBefore = typeof nextProtocolVoteBefore === "undefined" ? void 0 : ensureBigInt(nextProtocolVoteBefore);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _BlockUpgradeState.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["current-protocol", this.currentProtocol],
      ["next-protocol", this.nextProtocol],
      ["next-protocol-approvals", this.nextProtocolApprovals],
      ["next-protocol-switch-on", this.nextProtocolSwitchOn],
      ["next-protocol-vote-before", this.nextProtocolVoteBefore]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded BlockUpgradeState: ${data}`);
    }
    return new _BlockUpgradeState({
      currentProtocol: data.get("current-protocol"),
      nextProtocol: data.get("next-protocol"),
      nextProtocolApprovals: data.get("next-protocol-approvals"),
      nextProtocolSwitchOn: data.get("next-protocol-switch-on"),
      nextProtocolVoteBefore: data.get("next-protocol-vote-before")
    });
  }
};
var BlockUpgradeVote = class _BlockUpgradeVote {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "upgrade-approve",
        valueSchema: new OptionalSchema(new BooleanSchema()),
        omitEmpty: true
      }, {
        key: "upgrade-delay",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "upgrade-propose",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `BlockUpgradeVote` object.
   * @param upgradeApprove - (upgradeyes) Indicates a yes vote for the current proposal.
   * @param upgradeDelay - (upgradedelay) Indicates the time between acceptance and execution.
   * @param upgradePropose - (upgradeprop) Indicates a proposed upgrade.
   */
  constructor({ upgradeApprove, upgradeDelay, upgradePropose }) {
    this.upgradeApprove = upgradeApprove;
    this.upgradeDelay = typeof upgradeDelay === "undefined" ? void 0 : ensureBigInt(upgradeDelay);
    this.upgradePropose = upgradePropose;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _BlockUpgradeVote.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["upgrade-approve", this.upgradeApprove],
      ["upgrade-delay", this.upgradeDelay],
      ["upgrade-propose", this.upgradePropose]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded BlockUpgradeVote: ${data}`);
    }
    return new _BlockUpgradeVote({
      upgradeApprove: data.get("upgrade-approve"),
      upgradeDelay: data.get("upgrade-delay"),
      upgradePropose: data.get("upgrade-propose")
    });
  }
};
var Box2 = class _Box {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "name", valueSchema: new ByteArraySchema(), omitEmpty: true }, { key: "round", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "value", valueSchema: new ByteArraySchema(), omitEmpty: true });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `Box` object.
   * @param name - (name) box name, base64 encoded
   * @param round - The round for which this information is relevant
   * @param value - (value) box value, base64 encoded.
   */
  constructor({ name, round, value }) {
    this.name = typeof name === "string" ? base64ToBytes(name) : name;
    this.round = ensureBigInt(round);
    this.value = typeof value === "string" ? base64ToBytes(value) : value;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _Box.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["name", this.name],
      ["round", this.round],
      ["value", this.value]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded Box: ${data}`);
    }
    return new _Box({
      name: data.get("name"),
      round: data.get("round"),
      value: data.get("value")
    });
  }
};
var BoxDescriptor2 = class _BoxDescriptor {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "name",
        valueSchema: new ByteArraySchema(),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `BoxDescriptor` object.
   * @param name - Base64 encoded box name
   */
  constructor({ name }) {
    this.name = typeof name === "string" ? base64ToBytes(name) : name;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _BoxDescriptor.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([["name", this.name]]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded BoxDescriptor: ${data}`);
    }
    return new _BoxDescriptor({
      name: data.get("name")
    });
  }
};
var BoxReference2 = class _BoxReference {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "app", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "name", valueSchema: new ByteArraySchema(), omitEmpty: true });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `BoxReference` object.
   * @param app - Application ID to which the box belongs, or zero if referring to the called
   * application.
   * @param name - Base64 encoded box name
   */
  constructor({ app, name }) {
    this.app = ensureSafeInteger(app);
    this.name = typeof name === "string" ? base64ToBytes(name) : name;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _BoxReference.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["app", this.app],
      ["name", this.name]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded BoxReference: ${data}`);
    }
    return new _BoxReference({
      app: data.get("app"),
      name: data.get("name")
    });
  }
};
var BoxesResponse2 = class _BoxesResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "application-id",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "boxes",
        valueSchema: new ArraySchema(BoxDescriptor2.encodingSchema),
        omitEmpty: true
      }, {
        key: "next-token",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `BoxesResponse` object.
   * @param applicationId - (appidx) application index.
   * @param boxes -
   * @param nextToken - Used for pagination, when making another request provide this token with the
   * next parameter.
   */
  constructor({ applicationId, boxes, nextToken }) {
    this.applicationId = ensureBigInt(applicationId);
    this.boxes = boxes;
    this.nextToken = nextToken;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _BoxesResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["application-id", this.applicationId],
      ["boxes", this.boxes.map((v2) => v2.toEncodingData())],
      ["next-token", this.nextToken]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded BoxesResponse: ${data}`);
    }
    return new _BoxesResponse({
      applicationId: data.get("application-id"),
      boxes: (data.get("boxes") ?? []).map((v2) => BoxDescriptor2.fromEncodingData(v2)),
      nextToken: data.get("next-token")
    });
  }
};
var ErrorResponse2 = class _ErrorResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "message", valueSchema: new StringSchema(), omitEmpty: true }, {
        key: "data",
        valueSchema: new OptionalSchema(UntypedValue.encodingSchema),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `ErrorResponse` object.
   * @param message -
   * @param data -
   */
  constructor({ message, data }) {
    this.message = message;
    this.data = data;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _ErrorResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["message", this.message],
      [
        "data",
        typeof this.data !== "undefined" ? this.data.toEncodingData() : void 0
      ]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded ErrorResponse: ${data}`);
    }
    return new _ErrorResponse({
      message: data.get("message"),
      data: typeof data.get("data") !== "undefined" ? UntypedValue.fromEncodingData(data.get("data")) : void 0
    });
  }
};
var EvalDelta3 = class _EvalDelta {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "action", valueSchema: new Uint64Schema(), omitEmpty: true }, {
        key: "bytes",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "uint",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `EvalDelta` object.
   * @param action - (at) delta action.
   * @param bytes - (bs) bytes value.
   * @param uint - (ui) uint value.
   */
  constructor({ action, bytes, uint }) {
    this.action = ensureSafeInteger(action);
    this.bytes = bytes;
    this.uint = typeof uint === "undefined" ? void 0 : ensureBigInt(uint);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _EvalDelta.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["action", this.action],
      ["bytes", this.bytes],
      ["uint", this.uint]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded EvalDelta: ${data}`);
    }
    return new _EvalDelta({
      action: data.get("action"),
      bytes: data.get("bytes"),
      uint: data.get("uint")
    });
  }
};
var EvalDeltaKeyValue2 = class _EvalDeltaKeyValue {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "key", valueSchema: new StringSchema(), omitEmpty: true }, { key: "value", valueSchema: EvalDelta3.encodingSchema, omitEmpty: true });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `EvalDeltaKeyValue` object.
   * @param key -
   * @param value - Represents a TEAL value delta.
   */
  constructor({ key, value }) {
    this.key = key;
    this.value = value;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _EvalDeltaKeyValue.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["key", this.key],
      ["value", this.value.toEncodingData()]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded EvalDeltaKeyValue: ${data}`);
    }
    return new _EvalDeltaKeyValue({
      key: data.get("key"),
      value: EvalDelta3.fromEncodingData(data.get("value") ?? /* @__PURE__ */ new Map())
    });
  }
};
var HashFactory2 = class _HashFactory {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "hash-type",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `HashFactory` object.
   * @param hashType - (t)
   */
  constructor({ hashType }) {
    this.hashType = typeof hashType === "undefined" ? void 0 : ensureSafeInteger(hashType);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _HashFactory.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([["hash-type", this.hashType]]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded HashFactory: ${data}`);
    }
    return new _HashFactory({
      hashType: data.get("hash-type")
    });
  }
};
var HbProofFields = class _HbProofFields {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "hb-pk",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      }, {
        key: "hb-pk1sig",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      }, {
        key: "hb-pk2",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      }, {
        key: "hb-pk2sig",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      }, {
        key: "hb-sig",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `HbProofFields` object.
   * @param hbPk - (p) Public key of the heartbeat message.
   * @param hbPk1sig - (p1s) Signature of OneTimeSignatureSubkeyOffsetID(PK, Batch, Offset) under the
   * key PK2.
   * @param hbPk2 - (p2) Key for new-style two-level ephemeral signature.
   * @param hbPk2sig - (p2s) Signature of OneTimeSignatureSubkeyBatchID(PK2, Batch) under the master
   * key (OneTimeSignatureVerifier).
   * @param hbSig - (s) Signature of the heartbeat message.
   */
  constructor({ hbPk, hbPk1sig, hbPk2, hbPk2sig, hbSig }) {
    this.hbPk = typeof hbPk === "string" ? base64ToBytes(hbPk) : hbPk;
    this.hbPk1sig = typeof hbPk1sig === "string" ? base64ToBytes(hbPk1sig) : hbPk1sig;
    this.hbPk2 = typeof hbPk2 === "string" ? base64ToBytes(hbPk2) : hbPk2;
    this.hbPk2sig = typeof hbPk2sig === "string" ? base64ToBytes(hbPk2sig) : hbPk2sig;
    this.hbSig = typeof hbSig === "string" ? base64ToBytes(hbSig) : hbSig;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _HbProofFields.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["hb-pk", this.hbPk],
      ["hb-pk1sig", this.hbPk1sig],
      ["hb-pk2", this.hbPk2],
      ["hb-pk2sig", this.hbPk2sig],
      ["hb-sig", this.hbSig]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded HbProofFields: ${data}`);
    }
    return new _HbProofFields({
      hbPk: data.get("hb-pk"),
      hbPk1sig: data.get("hb-pk1sig"),
      hbPk2: data.get("hb-pk2"),
      hbPk2sig: data.get("hb-pk2sig"),
      hbSig: data.get("hb-sig")
    });
  }
};
var HealthCheck2 = class _HealthCheck {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "db-available",
        valueSchema: new BooleanSchema(),
        omitEmpty: true
      }, {
        key: "is-migrating",
        valueSchema: new BooleanSchema(),
        omitEmpty: true
      }, { key: "message", valueSchema: new StringSchema(), omitEmpty: true }, { key: "round", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "version", valueSchema: new StringSchema(), omitEmpty: true }, {
        key: "data",
        valueSchema: new OptionalSchema(UntypedValue.encodingSchema),
        omitEmpty: true
      }, {
        key: "errors",
        valueSchema: new OptionalSchema(new ArraySchema(new StringSchema())),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `HealthCheck` object.
   * @param dbAvailable -
   * @param isMigrating -
   * @param message -
   * @param round -
   * @param version - Current version.
   * @param data -
   * @param errors -
   */
  constructor({ dbAvailable, isMigrating, message, round, version, data, errors }) {
    this.dbAvailable = dbAvailable;
    this.isMigrating = isMigrating;
    this.message = message;
    this.round = ensureBigInt(round);
    this.version = version;
    this.data = data;
    this.errors = errors;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _HealthCheck.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["db-available", this.dbAvailable],
      ["is-migrating", this.isMigrating],
      ["message", this.message],
      ["round", this.round],
      ["version", this.version],
      [
        "data",
        typeof this.data !== "undefined" ? this.data.toEncodingData() : void 0
      ],
      ["errors", this.errors]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded HealthCheck: ${data}`);
    }
    return new _HealthCheck({
      dbAvailable: data.get("db-available"),
      isMigrating: data.get("is-migrating"),
      message: data.get("message"),
      round: data.get("round"),
      version: data.get("version"),
      data: typeof data.get("data") !== "undefined" ? UntypedValue.fromEncodingData(data.get("data")) : void 0,
      errors: data.get("errors")
    });
  }
};
var HoldingRef = class _HoldingRef {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "address", valueSchema: new StringSchema(), omitEmpty: true }, { key: "asset", valueSchema: new Uint64Schema(), omitEmpty: true });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `HoldingRef` object.
   * @param address - (d) Address in access list, or the sender of the transaction.
   * @param asset - (s) Asset ID for asset in access list.
   */
  constructor({ address, asset }) {
    this.address = typeof address === "string" ? Address.fromString(address) : address;
    this.asset = ensureSafeInteger(asset);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _HoldingRef.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["address", this.address.toString()],
      ["asset", this.asset]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded HoldingRef: ${data}`);
    }
    return new _HoldingRef({
      address: data.get("address"),
      asset: data.get("asset")
    });
  }
};
var IndexerStateProofMessage = class _IndexerStateProofMessage {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "block-headers-commitment",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      }, {
        key: "first-attested-round",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "latest-attested-round",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "ln-proven-weight",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "voters-commitment",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `IndexerStateProofMessage` object.
   * @param blockHeadersCommitment - (b)
   * @param firstAttestedRound - (f)
   * @param latestAttestedRound - (l)
   * @param lnProvenWeight - (P)
   * @param votersCommitment - (v)
   */
  constructor({ blockHeadersCommitment, firstAttestedRound, latestAttestedRound, lnProvenWeight, votersCommitment }) {
    this.blockHeadersCommitment = typeof blockHeadersCommitment === "string" ? base64ToBytes(blockHeadersCommitment) : blockHeadersCommitment;
    this.firstAttestedRound = typeof firstAttestedRound === "undefined" ? void 0 : ensureBigInt(firstAttestedRound);
    this.latestAttestedRound = typeof latestAttestedRound === "undefined" ? void 0 : ensureBigInt(latestAttestedRound);
    this.lnProvenWeight = typeof lnProvenWeight === "undefined" ? void 0 : ensureBigInt(lnProvenWeight);
    this.votersCommitment = typeof votersCommitment === "string" ? base64ToBytes(votersCommitment) : votersCommitment;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _IndexerStateProofMessage.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["block-headers-commitment", this.blockHeadersCommitment],
      ["first-attested-round", this.firstAttestedRound],
      ["latest-attested-round", this.latestAttestedRound],
      ["ln-proven-weight", this.lnProvenWeight],
      ["voters-commitment", this.votersCommitment]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded IndexerStateProofMessage: ${data}`);
    }
    return new _IndexerStateProofMessage({
      blockHeadersCommitment: data.get("block-headers-commitment"),
      firstAttestedRound: data.get("first-attested-round"),
      latestAttestedRound: data.get("latest-attested-round"),
      lnProvenWeight: data.get("ln-proven-weight"),
      votersCommitment: data.get("voters-commitment")
    });
  }
};
var LocalsRef = class _LocalsRef {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "address", valueSchema: new StringSchema(), omitEmpty: true }, { key: "app", valueSchema: new Uint64Schema(), omitEmpty: true });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `LocalsRef` object.
   * @param address - (d) Address in access list, or the sender of the transaction.
   * @param app - (p) Application ID for app in access list, or zero if referring to the called
   * application.
   */
  constructor({ address, app }) {
    this.address = typeof address === "string" ? Address.fromString(address) : address;
    this.app = ensureSafeInteger(app);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _LocalsRef.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["address", this.address.toString()],
      ["app", this.app]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded LocalsRef: ${data}`);
    }
    return new _LocalsRef({
      address: data.get("address"),
      app: data.get("app")
    });
  }
};
var MerkleArrayProof2 = class _MerkleArrayProof {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "hash-factory",
        valueSchema: new OptionalSchema(HashFactory2.encodingSchema),
        omitEmpty: true
      }, {
        key: "path",
        valueSchema: new OptionalSchema(new ArraySchema(new ByteArraySchema())),
        omitEmpty: true
      }, {
        key: "tree-depth",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `MerkleArrayProof` object.
   * @param hashFactory -
   * @param path - (pth)
   * @param treeDepth - (td)
   */
  constructor({ hashFactory, path, treeDepth }) {
    this.hashFactory = hashFactory;
    this.path = path;
    this.treeDepth = typeof treeDepth === "undefined" ? void 0 : ensureSafeInteger(treeDepth);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _MerkleArrayProof.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      [
        "hash-factory",
        typeof this.hashFactory !== "undefined" ? this.hashFactory.toEncodingData() : void 0
      ],
      ["path", this.path],
      ["tree-depth", this.treeDepth]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded MerkleArrayProof: ${data}`);
    }
    return new _MerkleArrayProof({
      hashFactory: typeof data.get("hash-factory") !== "undefined" ? HashFactory2.fromEncodingData(data.get("hash-factory")) : void 0,
      path: data.get("path"),
      treeDepth: data.get("tree-depth")
    });
  }
};
var MiniAssetHolding = class _MiniAssetHolding {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "address", valueSchema: new StringSchema(), omitEmpty: true }, { key: "amount", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "is-frozen", valueSchema: new BooleanSchema(), omitEmpty: true }, {
        key: "deleted",
        valueSchema: new OptionalSchema(new BooleanSchema()),
        omitEmpty: true
      }, {
        key: "opted-in-at-round",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "opted-out-at-round",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `MiniAssetHolding` object.
   * @param address -
   * @param amount -
   * @param isFrozen -
   * @param deleted - Whether or not this asset holding is currently deleted from its account.
   * @param optedInAtRound - Round during which the account opted into the asset.
   * @param optedOutAtRound - Round during which the account opted out of the asset.
   */
  constructor({ address, amount, isFrozen, deleted, optedInAtRound, optedOutAtRound }) {
    this.address = address;
    this.amount = ensureBigInt(amount);
    this.isFrozen = isFrozen;
    this.deleted = deleted;
    this.optedInAtRound = typeof optedInAtRound === "undefined" ? void 0 : ensureBigInt(optedInAtRound);
    this.optedOutAtRound = typeof optedOutAtRound === "undefined" ? void 0 : ensureBigInt(optedOutAtRound);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _MiniAssetHolding.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["address", this.address],
      ["amount", this.amount],
      ["is-frozen", this.isFrozen],
      ["deleted", this.deleted],
      ["opted-in-at-round", this.optedInAtRound],
      ["opted-out-at-round", this.optedOutAtRound]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded MiniAssetHolding: ${data}`);
    }
    return new _MiniAssetHolding({
      address: data.get("address"),
      amount: data.get("amount"),
      isFrozen: data.get("is-frozen"),
      deleted: data.get("deleted"),
      optedInAtRound: data.get("opted-in-at-round"),
      optedOutAtRound: data.get("opted-out-at-round")
    });
  }
};
var ParticipationUpdates2 = class _ParticipationUpdates {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "absent-participation-accounts",
        valueSchema: new OptionalSchema(new ArraySchema(new StringSchema())),
        omitEmpty: true
      }, {
        key: "expired-participation-accounts",
        valueSchema: new OptionalSchema(new ArraySchema(new StringSchema())),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `ParticipationUpdates` object.
   * @param absentParticipationAccounts - (partupabs) a list of online accounts that need to be suspended.
   * @param expiredParticipationAccounts - (partupdrmv) a list of online accounts that needs to be converted to offline
   * since their participation key expired.
   */
  constructor({ absentParticipationAccounts, expiredParticipationAccounts }) {
    this.absentParticipationAccounts = absentParticipationAccounts;
    this.expiredParticipationAccounts = expiredParticipationAccounts;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _ParticipationUpdates.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["absent-participation-accounts", this.absentParticipationAccounts],
      ["expired-participation-accounts", this.expiredParticipationAccounts]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded ParticipationUpdates: ${data}`);
    }
    return new _ParticipationUpdates({
      absentParticipationAccounts: data.get("absent-participation-accounts"),
      expiredParticipationAccounts: data.get("expired-participation-accounts")
    });
  }
};
var ResourceRef = class _ResourceRef {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "address",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "application-id",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "asset-id",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "box",
        valueSchema: new OptionalSchema(BoxReference2.encodingSchema),
        omitEmpty: true
      }, {
        key: "holding",
        valueSchema: new OptionalSchema(HoldingRef.encodingSchema),
        omitEmpty: true
      }, {
        key: "local",
        valueSchema: new OptionalSchema(LocalsRef.encodingSchema),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `ResourceRef` object.
   * @param address - (d) Account whose balance record is accessible by the executing ApprovalProgram
   * or ClearStateProgram.
   * @param applicationId - (p) Application id whose GlobalState may be read by the executing
   * ApprovalProgram or ClearStateProgram.
   * @param assetId - (s) Asset whose AssetParams may be read by the executing
   * ApprovalProgram or ClearStateProgram.
   * @param box - BoxReference names a box by its name and the application ID it belongs to.
   * @param holding - HoldingRef names a holding by referring to an Address and Asset it belongs to.
   * @param local - LocalsRef names a local state by referring to an Address and App it belongs to.
   */
  constructor({ address, applicationId, assetId, box, holding, local }) {
    this.address = typeof address === "string" ? Address.fromString(address) : address;
    this.applicationId = typeof applicationId === "undefined" ? void 0 : ensureSafeInteger(applicationId);
    this.assetId = typeof assetId === "undefined" ? void 0 : ensureSafeInteger(assetId);
    this.box = box;
    this.holding = holding;
    this.local = local;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _ResourceRef.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      [
        "address",
        typeof this.address !== "undefined" ? this.address.toString() : void 0
      ],
      ["application-id", this.applicationId],
      ["asset-id", this.assetId],
      [
        "box",
        typeof this.box !== "undefined" ? this.box.toEncodingData() : void 0
      ],
      [
        "holding",
        typeof this.holding !== "undefined" ? this.holding.toEncodingData() : void 0
      ],
      [
        "local",
        typeof this.local !== "undefined" ? this.local.toEncodingData() : void 0
      ]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded ResourceRef: ${data}`);
    }
    return new _ResourceRef({
      address: data.get("address"),
      applicationId: data.get("application-id"),
      assetId: data.get("asset-id"),
      box: typeof data.get("box") !== "undefined" ? BoxReference2.fromEncodingData(data.get("box")) : void 0,
      holding: typeof data.get("holding") !== "undefined" ? HoldingRef.fromEncodingData(data.get("holding")) : void 0,
      local: typeof data.get("local") !== "undefined" ? LocalsRef.fromEncodingData(data.get("local")) : void 0
    });
  }
};
var StateProofFields = class _StateProofFields {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "part-proofs",
        valueSchema: new OptionalSchema(MerkleArrayProof2.encodingSchema),
        omitEmpty: true
      }, {
        key: "positions-to-reveal",
        valueSchema: new OptionalSchema(new ArraySchema(new Uint64Schema())),
        omitEmpty: true
      }, {
        key: "reveals",
        valueSchema: new OptionalSchema(new ArraySchema(StateProofReveal.encodingSchema)),
        omitEmpty: true
      }, {
        key: "salt-version",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "sig-commit",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      }, {
        key: "sig-proofs",
        valueSchema: new OptionalSchema(MerkleArrayProof2.encodingSchema),
        omitEmpty: true
      }, {
        key: "signed-weight",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `StateProofFields` object.
   * @param partProofs - (P)
   * @param positionsToReveal - (pr) Sequence of reveal positions.
   * @param reveals - (r) Note that this is actually stored as a map[uint64] - Reveal in the actual
   * msgp
   * @param saltVersion - (v) Salt version of the merkle signature.
   * @param sigCommit - (c)
   * @param sigProofs - (S)
   * @param signedWeight - (w)
   */
  constructor({ partProofs, positionsToReveal, reveals, saltVersion, sigCommit, sigProofs, signedWeight }) {
    this.partProofs = partProofs;
    this.positionsToReveal = typeof positionsToReveal === "undefined" ? void 0 : positionsToReveal.map(ensureBigInt);
    this.reveals = reveals;
    this.saltVersion = typeof saltVersion === "undefined" ? void 0 : ensureSafeInteger(saltVersion);
    this.sigCommit = typeof sigCommit === "string" ? base64ToBytes(sigCommit) : sigCommit;
    this.sigProofs = sigProofs;
    this.signedWeight = typeof signedWeight === "undefined" ? void 0 : ensureBigInt(signedWeight);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _StateProofFields.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      [
        "part-proofs",
        typeof this.partProofs !== "undefined" ? this.partProofs.toEncodingData() : void 0
      ],
      ["positions-to-reveal", this.positionsToReveal],
      [
        "reveals",
        typeof this.reveals !== "undefined" ? this.reveals.map((v2) => v2.toEncodingData()) : void 0
      ],
      ["salt-version", this.saltVersion],
      ["sig-commit", this.sigCommit],
      [
        "sig-proofs",
        typeof this.sigProofs !== "undefined" ? this.sigProofs.toEncodingData() : void 0
      ],
      ["signed-weight", this.signedWeight]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded StateProofFields: ${data}`);
    }
    return new _StateProofFields({
      partProofs: typeof data.get("part-proofs") !== "undefined" ? MerkleArrayProof2.fromEncodingData(data.get("part-proofs")) : void 0,
      positionsToReveal: data.get("positions-to-reveal"),
      reveals: typeof data.get("reveals") !== "undefined" ? data.get("reveals").map((v2) => StateProofReveal.fromEncodingData(v2)) : void 0,
      saltVersion: data.get("salt-version"),
      sigCommit: data.get("sig-commit"),
      sigProofs: typeof data.get("sig-proofs") !== "undefined" ? MerkleArrayProof2.fromEncodingData(data.get("sig-proofs")) : void 0,
      signedWeight: data.get("signed-weight")
    });
  }
};
var StateProofParticipant = class _StateProofParticipant {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "verifier",
        valueSchema: new OptionalSchema(StateProofVerifier.encodingSchema),
        omitEmpty: true
      }, {
        key: "weight",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `StateProofParticipant` object.
   * @param verifier - (p)
   * @param weight - (w)
   */
  constructor({ verifier, weight }) {
    this.verifier = verifier;
    this.weight = typeof weight === "undefined" ? void 0 : ensureBigInt(weight);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _StateProofParticipant.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      [
        "verifier",
        typeof this.verifier !== "undefined" ? this.verifier.toEncodingData() : void 0
      ],
      ["weight", this.weight]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded StateProofParticipant: ${data}`);
    }
    return new _StateProofParticipant({
      verifier: typeof data.get("verifier") !== "undefined" ? StateProofVerifier.fromEncodingData(data.get("verifier")) : void 0,
      weight: data.get("weight")
    });
  }
};
var StateProofReveal = class _StateProofReveal {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "participant",
        valueSchema: new OptionalSchema(StateProofParticipant.encodingSchema),
        omitEmpty: true
      }, {
        key: "position",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "sig-slot",
        valueSchema: new OptionalSchema(StateProofSigSlot.encodingSchema),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `StateProofReveal` object.
   * @param participant - (p)
   * @param position - The position in the signature and participants arrays corresponding to this
   * entry.
   * @param sigSlot - (s)
   */
  constructor({ participant, position, sigSlot }) {
    this.participant = participant;
    this.position = typeof position === "undefined" ? void 0 : ensureBigInt(position);
    this.sigSlot = sigSlot;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _StateProofReveal.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      [
        "participant",
        typeof this.participant !== "undefined" ? this.participant.toEncodingData() : void 0
      ],
      ["position", this.position],
      [
        "sig-slot",
        typeof this.sigSlot !== "undefined" ? this.sigSlot.toEncodingData() : void 0
      ]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded StateProofReveal: ${data}`);
    }
    return new _StateProofReveal({
      participant: typeof data.get("participant") !== "undefined" ? StateProofParticipant.fromEncodingData(data.get("participant")) : void 0,
      position: data.get("position"),
      sigSlot: typeof data.get("sig-slot") !== "undefined" ? StateProofSigSlot.fromEncodingData(data.get("sig-slot")) : void 0
    });
  }
};
var StateProofSigSlot = class _StateProofSigSlot {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "lower-sig-weight",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "signature",
        valueSchema: new OptionalSchema(StateProofSignature.encodingSchema),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `StateProofSigSlot` object.
   * @param lowerSigWeight - (l) The total weight of signatures in the lower-numbered slots.
   * @param signature -
   */
  constructor({ lowerSigWeight, signature }) {
    this.lowerSigWeight = typeof lowerSigWeight === "undefined" ? void 0 : ensureBigInt(lowerSigWeight);
    this.signature = signature;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _StateProofSigSlot.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["lower-sig-weight", this.lowerSigWeight],
      [
        "signature",
        typeof this.signature !== "undefined" ? this.signature.toEncodingData() : void 0
      ]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded StateProofSigSlot: ${data}`);
    }
    return new _StateProofSigSlot({
      lowerSigWeight: data.get("lower-sig-weight"),
      signature: typeof data.get("signature") !== "undefined" ? StateProofSignature.fromEncodingData(data.get("signature")) : void 0
    });
  }
};
var StateProofSignature = class _StateProofSignature {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "falcon-signature",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      }, {
        key: "merkle-array-index",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "proof",
        valueSchema: new OptionalSchema(MerkleArrayProof2.encodingSchema),
        omitEmpty: true
      }, {
        key: "verifying-key",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `StateProofSignature` object.
   * @param falconSignature -
   * @param merkleArrayIndex -
   * @param proof -
   * @param verifyingKey - (vkey)
   */
  constructor({ falconSignature, merkleArrayIndex, proof, verifyingKey }) {
    this.falconSignature = typeof falconSignature === "string" ? base64ToBytes(falconSignature) : falconSignature;
    this.merkleArrayIndex = typeof merkleArrayIndex === "undefined" ? void 0 : ensureSafeInteger(merkleArrayIndex);
    this.proof = proof;
    this.verifyingKey = typeof verifyingKey === "string" ? base64ToBytes(verifyingKey) : verifyingKey;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _StateProofSignature.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["falcon-signature", this.falconSignature],
      ["merkle-array-index", this.merkleArrayIndex],
      [
        "proof",
        typeof this.proof !== "undefined" ? this.proof.toEncodingData() : void 0
      ],
      ["verifying-key", this.verifyingKey]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded StateProofSignature: ${data}`);
    }
    return new _StateProofSignature({
      falconSignature: data.get("falcon-signature"),
      merkleArrayIndex: data.get("merkle-array-index"),
      proof: typeof data.get("proof") !== "undefined" ? MerkleArrayProof2.fromEncodingData(data.get("proof")) : void 0,
      verifyingKey: data.get("verifying-key")
    });
  }
};
var StateProofTracking = class _StateProofTracking {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "next-round",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "online-total-weight",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "type",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "voters-commitment",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `StateProofTracking` object.
   * @param nextRound - (n) Next round for which we will accept a state proof transaction.
   * @param onlineTotalWeight - (t) The total number of microalgos held by the online accounts during the
   * StateProof round.
   * @param type - State Proof Type. Note the raw object uses map with this as key.
   * @param votersCommitment - (v) Root of a vector commitment containing online accounts that will help sign
   * the proof.
   */
  constructor({ nextRound, onlineTotalWeight, type, votersCommitment }) {
    this.nextRound = typeof nextRound === "undefined" ? void 0 : ensureBigInt(nextRound);
    this.onlineTotalWeight = typeof onlineTotalWeight === "undefined" ? void 0 : ensureBigInt(onlineTotalWeight);
    this.type = typeof type === "undefined" ? void 0 : ensureSafeInteger(type);
    this.votersCommitment = typeof votersCommitment === "string" ? base64ToBytes(votersCommitment) : votersCommitment;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _StateProofTracking.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["next-round", this.nextRound],
      ["online-total-weight", this.onlineTotalWeight],
      ["type", this.type],
      ["voters-commitment", this.votersCommitment]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded StateProofTracking: ${data}`);
    }
    return new _StateProofTracking({
      nextRound: data.get("next-round"),
      onlineTotalWeight: data.get("online-total-weight"),
      type: data.get("type"),
      votersCommitment: data.get("voters-commitment")
    });
  }
};
var StateProofVerifier = class _StateProofVerifier {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "commitment",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      }, {
        key: "key-lifetime",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `StateProofVerifier` object.
   * @param commitment - (cmt) Represents the root of the vector commitment tree.
   * @param keyLifetime - (lf) Key lifetime.
   */
  constructor({ commitment, keyLifetime }) {
    this.commitment = typeof commitment === "string" ? base64ToBytes(commitment) : commitment;
    this.keyLifetime = typeof keyLifetime === "undefined" ? void 0 : ensureBigInt(keyLifetime);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _StateProofVerifier.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["commitment", this.commitment],
      ["key-lifetime", this.keyLifetime]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded StateProofVerifier: ${data}`);
    }
    return new _StateProofVerifier({
      commitment: data.get("commitment"),
      keyLifetime: data.get("key-lifetime")
    });
  }
};
var StateSchema2 = class _StateSchema {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "num-byte-slice",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, { key: "num-uint", valueSchema: new Uint64Schema(), omitEmpty: true });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `StateSchema` object.
   * @param numByteSlice - Maximum number of TEAL byte slices that may be stored in the key/value store.
   * @param numUint - Maximum number of TEAL uints that may be stored in the key/value store.
   */
  constructor({ numByteSlice, numUint }) {
    this.numByteSlice = ensureSafeInteger(numByteSlice);
    this.numUint = ensureSafeInteger(numUint);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _StateSchema.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["num-byte-slice", this.numByteSlice],
      ["num-uint", this.numUint]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded StateSchema: ${data}`);
    }
    return new _StateSchema({
      numByteSlice: data.get("num-byte-slice"),
      numUint: data.get("num-uint")
    });
  }
};
var TealKeyValue2 = class _TealKeyValue {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "key", valueSchema: new ByteArraySchema(), omitEmpty: true }, { key: "value", valueSchema: TealValue3.encodingSchema, omitEmpty: true });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `TealKeyValue` object.
   * @param key -
   * @param value - Represents a TEAL value.
   */
  constructor({ key, value }) {
    this.key = typeof key === "string" ? base64ToBytes(key) : key;
    this.value = value;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _TealKeyValue.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["key", this.key],
      ["value", this.value.toEncodingData()]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded TealKeyValue: ${data}`);
    }
    return new _TealKeyValue({
      key: data.get("key"),
      value: TealValue3.fromEncodingData(data.get("value") ?? /* @__PURE__ */ new Map())
    });
  }
};
var TealValue3 = class _TealValue {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "bytes", valueSchema: new ByteArraySchema(), omitEmpty: true }, { key: "type", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "uint", valueSchema: new Uint64Schema(), omitEmpty: true });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `TealValue` object.
   * @param bytes - bytes value.
   * @param type - type of the value. Value `1` refers to **bytes**, value `2` refers to **uint**
   * @param uint - uint value.
   */
  constructor({ bytes, type, uint }) {
    this.bytes = typeof bytes === "string" ? base64ToBytes(bytes) : bytes;
    this.type = ensureSafeInteger(type);
    this.uint = ensureBigInt(uint);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _TealValue.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["bytes", this.bytes],
      ["type", this.type],
      ["uint", this.uint]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded TealValue: ${data}`);
    }
    return new _TealValue({
      bytes: data.get("bytes"),
      type: data.get("type"),
      uint: data.get("uint")
    });
  }
};
var Transaction2 = class _Transaction {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "fee", valueSchema: new Uint64Schema(), omitEmpty: true }, {
        key: "first-valid",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, { key: "last-valid", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "sender", valueSchema: new StringSchema(), omitEmpty: true }, {
        key: "application-transaction",
        valueSchema: new OptionalSchema(TransactionApplication.encodingSchema),
        omitEmpty: true
      }, {
        key: "asset-config-transaction",
        valueSchema: new OptionalSchema(TransactionAssetConfig.encodingSchema),
        omitEmpty: true
      }, {
        key: "asset-freeze-transaction",
        valueSchema: new OptionalSchema(TransactionAssetFreeze.encodingSchema),
        omitEmpty: true
      }, {
        key: "asset-transfer-transaction",
        valueSchema: new OptionalSchema(TransactionAssetTransfer.encodingSchema),
        omitEmpty: true
      }, {
        key: "auth-addr",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "close-rewards",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "closing-amount",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "confirmed-round",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "created-application-index",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "created-asset-index",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "genesis-hash",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      }, {
        key: "genesis-id",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "global-state-delta",
        valueSchema: new OptionalSchema(new ArraySchema(EvalDeltaKeyValue2.encodingSchema)),
        omitEmpty: true
      }, {
        key: "group",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      }, {
        key: "heartbeat-transaction",
        valueSchema: new OptionalSchema(TransactionHeartbeat.encodingSchema),
        omitEmpty: true
      }, {
        key: "id",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "inner-txns",
        valueSchema: new OptionalSchema(new ArraySchema(_Transaction.encodingSchema)),
        omitEmpty: true
      }, {
        key: "intra-round-offset",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "keyreg-transaction",
        valueSchema: new OptionalSchema(TransactionKeyreg.encodingSchema),
        omitEmpty: true
      }, {
        key: "lease",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      }, {
        key: "local-state-delta",
        valueSchema: new OptionalSchema(new ArraySchema(AccountStateDelta2.encodingSchema)),
        omitEmpty: true
      }, {
        key: "logs",
        valueSchema: new OptionalSchema(new ArraySchema(new ByteArraySchema())),
        omitEmpty: true
      }, {
        key: "note",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      }, {
        key: "payment-transaction",
        valueSchema: new OptionalSchema(TransactionPayment.encodingSchema),
        omitEmpty: true
      }, {
        key: "receiver-rewards",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "rekey-to",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "round-time",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "sender-rewards",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "signature",
        valueSchema: new OptionalSchema(TransactionSignature.encodingSchema),
        omitEmpty: true
      }, {
        key: "state-proof-transaction",
        valueSchema: new OptionalSchema(TransactionStateProof.encodingSchema),
        omitEmpty: true
      }, {
        key: "tx-type",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `Transaction` object.
   * @param fee - (fee) Transaction fee.
   * @param firstValid - (fv) First valid round for this transaction.
   * @param lastValid - (lv) Last valid round for this transaction.
   * @param sender - (snd) Sender's address.
   * @param applicationTransaction - Fields for application transactions.
   * Definition:
   * data/transactions/application.go : ApplicationCallTxnFields
   * @param assetConfigTransaction - Fields for asset allocation, re-configuration, and destruction.
   * A zero value for asset-id indicates asset creation.
   * A zero value for the params indicates asset destruction.
   * Definition:
   * data/transactions/asset.go : AssetConfigTxnFields
   * @param assetFreezeTransaction - Fields for an asset freeze transaction.
   * Definition:
   * data/transactions/asset.go : AssetFreezeTxnFields
   * @param assetTransferTransaction - Fields for an asset transfer transaction.
   * Definition:
   * data/transactions/asset.go : AssetTransferTxnFields
   * @param authAddr - (sgnr) this is included with signed transactions when the signing address does
   * not equal the sender. The backend can use this to ensure that auth addr is equal
   * to the accounts auth addr.
   * @param closeRewards - (rc) rewards applied to close-remainder-to account.
   * @param closingAmount - (ca) closing amount for transaction.
   * @param confirmedRound - Round when the transaction was confirmed.
   * @param createdApplicationIndex - Specifies an application index (ID) if an application was created with this
   * transaction.
   * @param createdAssetIndex - Specifies an asset index (ID) if an asset was created with this transaction.
   * @param genesisHash - (gh) Hash of genesis block.
   * @param genesisId - (gen) genesis block ID.
   * @param globalStateDelta - (gd) Global state key/value changes for the application being executed by this
   * transaction.
   * @param group - (grp) Base64 encoded byte array of a sha512/256 digest. When present indicates
   * that this transaction is part of a transaction group and the value is the
   * sha512/256 hash of the transactions in that group.
   * @param heartbeatTransaction - Fields for a heartbeat transaction.
   * Definition:
   * data/transactions/heartbeat.go : HeartbeatTxnFields
   * @param id - Transaction ID
   * @param innerTxns - Inner transactions produced by application execution.
   * @param intraRoundOffset - Offset into the round where this transaction was confirmed.
   * @param keyregTransaction - Fields for a keyreg transaction.
   * Definition:
   * data/transactions/keyreg.go : KeyregTxnFields
   * @param lease - (lx) Base64 encoded 32-byte array. Lease enforces mutual exclusion of
   * transactions. If this field is nonzero, then once the transaction is confirmed,
   * it acquires the lease identified by the (Sender, Lease) pair of the transaction
   * until the LastValid round passes. While this transaction possesses the lease, no
   * other transaction specifying this lease can be confirmed.
   * @param localStateDelta - (ld) Local state key/value changes for the application being executed by this
   * transaction.
   * @param logs - (lg) Logs for the application being executed by this transaction.
   * @param note - (note) Free form data.
   * @param paymentTransaction - Fields for a payment transaction.
   * Definition:
   * data/transactions/payment.go : PaymentTxnFields
   * @param receiverRewards - (rr) rewards applied to receiver account.
   * @param rekeyTo - (rekey) when included in a valid transaction, the accounts auth addr will be
   * updated with this value and future signatures must be signed with the key
   * represented by this address.
   * @param roundTime - Time when the block this transaction is in was confirmed.
   * @param senderRewards - (rs) rewards applied to sender account.
   * @param signature - Validation signature associated with some data. Only one of the signatures
   * should be provided.
   * @param stateProofTransaction - Fields for a state proof transaction.
   * Definition:
   * data/transactions/stateproof.go : StateProofTxnFields
   * @param txType - (type) Indicates what type of transaction this is. Different types have
   * different fields.
   * Valid types, and where their fields are stored:
   * * (pay) payment-transaction
   * * (keyreg) keyreg-transaction
   * * (acfg) asset-config-transaction
   * * (axfer) asset-transfer-transaction
   * * (afrz) asset-freeze-transaction
   * * (appl) application-transaction
   * * (stpf) state-proof-transaction
   * * (hb) heartbeat-transaction
   */
  constructor({ fee, firstValid, lastValid, sender, applicationTransaction, assetConfigTransaction, assetFreezeTransaction, assetTransferTransaction, authAddr, closeRewards, closingAmount, confirmedRound, createdApplicationIndex, createdAssetIndex, genesisHash, genesisId, globalStateDelta, group, heartbeatTransaction, id, innerTxns, intraRoundOffset, keyregTransaction, lease, localStateDelta, logs, note, paymentTransaction, receiverRewards, rekeyTo, roundTime, senderRewards, signature, stateProofTransaction, txType }) {
    this.fee = ensureBigInt(fee);
    this.firstValid = ensureBigInt(firstValid);
    this.lastValid = ensureBigInt(lastValid);
    this.sender = sender;
    this.applicationTransaction = applicationTransaction;
    this.assetConfigTransaction = assetConfigTransaction;
    this.assetFreezeTransaction = assetFreezeTransaction;
    this.assetTransferTransaction = assetTransferTransaction;
    this.authAddr = typeof authAddr === "string" ? Address.fromString(authAddr) : authAddr;
    this.closeRewards = typeof closeRewards === "undefined" ? void 0 : ensureBigInt(closeRewards);
    this.closingAmount = typeof closingAmount === "undefined" ? void 0 : ensureBigInt(closingAmount);
    this.confirmedRound = typeof confirmedRound === "undefined" ? void 0 : ensureBigInt(confirmedRound);
    this.createdApplicationIndex = typeof createdApplicationIndex === "undefined" ? void 0 : ensureBigInt(createdApplicationIndex);
    this.createdAssetIndex = typeof createdAssetIndex === "undefined" ? void 0 : ensureBigInt(createdAssetIndex);
    this.genesisHash = typeof genesisHash === "string" ? base64ToBytes(genesisHash) : genesisHash;
    this.genesisId = genesisId;
    this.globalStateDelta = globalStateDelta;
    this.group = typeof group === "string" ? base64ToBytes(group) : group;
    this.heartbeatTransaction = heartbeatTransaction;
    this.id = id;
    this.innerTxns = innerTxns;
    this.intraRoundOffset = typeof intraRoundOffset === "undefined" ? void 0 : ensureSafeInteger(intraRoundOffset);
    this.keyregTransaction = keyregTransaction;
    this.lease = typeof lease === "string" ? base64ToBytes(lease) : lease;
    this.localStateDelta = localStateDelta;
    this.logs = logs;
    this.note = typeof note === "string" ? base64ToBytes(note) : note;
    this.paymentTransaction = paymentTransaction;
    this.receiverRewards = typeof receiverRewards === "undefined" ? void 0 : ensureBigInt(receiverRewards);
    this.rekeyTo = typeof rekeyTo === "string" ? Address.fromString(rekeyTo) : rekeyTo;
    this.roundTime = typeof roundTime === "undefined" ? void 0 : ensureSafeInteger(roundTime);
    this.senderRewards = typeof senderRewards === "undefined" ? void 0 : ensureBigInt(senderRewards);
    this.signature = signature;
    this.stateProofTransaction = stateProofTransaction;
    this.txType = txType;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _Transaction.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["fee", this.fee],
      ["first-valid", this.firstValid],
      ["last-valid", this.lastValid],
      ["sender", this.sender],
      [
        "application-transaction",
        typeof this.applicationTransaction !== "undefined" ? this.applicationTransaction.toEncodingData() : void 0
      ],
      [
        "asset-config-transaction",
        typeof this.assetConfigTransaction !== "undefined" ? this.assetConfigTransaction.toEncodingData() : void 0
      ],
      [
        "asset-freeze-transaction",
        typeof this.assetFreezeTransaction !== "undefined" ? this.assetFreezeTransaction.toEncodingData() : void 0
      ],
      [
        "asset-transfer-transaction",
        typeof this.assetTransferTransaction !== "undefined" ? this.assetTransferTransaction.toEncodingData() : void 0
      ],
      [
        "auth-addr",
        typeof this.authAddr !== "undefined" ? this.authAddr.toString() : void 0
      ],
      ["close-rewards", this.closeRewards],
      ["closing-amount", this.closingAmount],
      ["confirmed-round", this.confirmedRound],
      ["created-application-index", this.createdApplicationIndex],
      ["created-asset-index", this.createdAssetIndex],
      ["genesis-hash", this.genesisHash],
      ["genesis-id", this.genesisId],
      [
        "global-state-delta",
        typeof this.globalStateDelta !== "undefined" ? this.globalStateDelta.map((v2) => v2.toEncodingData()) : void 0
      ],
      ["group", this.group],
      [
        "heartbeat-transaction",
        typeof this.heartbeatTransaction !== "undefined" ? this.heartbeatTransaction.toEncodingData() : void 0
      ],
      ["id", this.id],
      [
        "inner-txns",
        typeof this.innerTxns !== "undefined" ? this.innerTxns.map((v2) => v2.toEncodingData()) : void 0
      ],
      ["intra-round-offset", this.intraRoundOffset],
      [
        "keyreg-transaction",
        typeof this.keyregTransaction !== "undefined" ? this.keyregTransaction.toEncodingData() : void 0
      ],
      ["lease", this.lease],
      [
        "local-state-delta",
        typeof this.localStateDelta !== "undefined" ? this.localStateDelta.map((v2) => v2.toEncodingData()) : void 0
      ],
      ["logs", this.logs],
      ["note", this.note],
      [
        "payment-transaction",
        typeof this.paymentTransaction !== "undefined" ? this.paymentTransaction.toEncodingData() : void 0
      ],
      ["receiver-rewards", this.receiverRewards],
      [
        "rekey-to",
        typeof this.rekeyTo !== "undefined" ? this.rekeyTo.toString() : void 0
      ],
      ["round-time", this.roundTime],
      ["sender-rewards", this.senderRewards],
      [
        "signature",
        typeof this.signature !== "undefined" ? this.signature.toEncodingData() : void 0
      ],
      [
        "state-proof-transaction",
        typeof this.stateProofTransaction !== "undefined" ? this.stateProofTransaction.toEncodingData() : void 0
      ],
      ["tx-type", this.txType]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded Transaction: ${data}`);
    }
    return new _Transaction({
      fee: data.get("fee"),
      firstValid: data.get("first-valid"),
      lastValid: data.get("last-valid"),
      sender: data.get("sender"),
      applicationTransaction: typeof data.get("application-transaction") !== "undefined" ? TransactionApplication.fromEncodingData(data.get("application-transaction")) : void 0,
      assetConfigTransaction: typeof data.get("asset-config-transaction") !== "undefined" ? TransactionAssetConfig.fromEncodingData(data.get("asset-config-transaction")) : void 0,
      assetFreezeTransaction: typeof data.get("asset-freeze-transaction") !== "undefined" ? TransactionAssetFreeze.fromEncodingData(data.get("asset-freeze-transaction")) : void 0,
      assetTransferTransaction: typeof data.get("asset-transfer-transaction") !== "undefined" ? TransactionAssetTransfer.fromEncodingData(data.get("asset-transfer-transaction")) : void 0,
      authAddr: data.get("auth-addr"),
      closeRewards: data.get("close-rewards"),
      closingAmount: data.get("closing-amount"),
      confirmedRound: data.get("confirmed-round"),
      createdApplicationIndex: data.get("created-application-index"),
      createdAssetIndex: data.get("created-asset-index"),
      genesisHash: data.get("genesis-hash"),
      genesisId: data.get("genesis-id"),
      globalStateDelta: typeof data.get("global-state-delta") !== "undefined" ? data.get("global-state-delta").map((v2) => EvalDeltaKeyValue2.fromEncodingData(v2)) : void 0,
      group: data.get("group"),
      heartbeatTransaction: typeof data.get("heartbeat-transaction") !== "undefined" ? TransactionHeartbeat.fromEncodingData(data.get("heartbeat-transaction")) : void 0,
      id: data.get("id"),
      innerTxns: typeof data.get("inner-txns") !== "undefined" ? data.get("inner-txns").map((v2) => _Transaction.fromEncodingData(v2)) : void 0,
      intraRoundOffset: data.get("intra-round-offset"),
      keyregTransaction: typeof data.get("keyreg-transaction") !== "undefined" ? TransactionKeyreg.fromEncodingData(data.get("keyreg-transaction")) : void 0,
      lease: data.get("lease"),
      localStateDelta: typeof data.get("local-state-delta") !== "undefined" ? data.get("local-state-delta").map((v2) => AccountStateDelta2.fromEncodingData(v2)) : void 0,
      logs: data.get("logs"),
      note: data.get("note"),
      paymentTransaction: typeof data.get("payment-transaction") !== "undefined" ? TransactionPayment.fromEncodingData(data.get("payment-transaction")) : void 0,
      receiverRewards: data.get("receiver-rewards"),
      rekeyTo: data.get("rekey-to"),
      roundTime: data.get("round-time"),
      senderRewards: data.get("sender-rewards"),
      signature: typeof data.get("signature") !== "undefined" ? TransactionSignature.fromEncodingData(data.get("signature")) : void 0,
      stateProofTransaction: typeof data.get("state-proof-transaction") !== "undefined" ? TransactionStateProof.fromEncodingData(data.get("state-proof-transaction")) : void 0,
      txType: data.get("tx-type")
    });
  }
};
var TransactionApplication = class _TransactionApplication {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "application-id",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "access",
        valueSchema: new OptionalSchema(new ArraySchema(ResourceRef.encodingSchema)),
        omitEmpty: true
      }, {
        key: "accounts",
        valueSchema: new OptionalSchema(new ArraySchema(new StringSchema())),
        omitEmpty: true
      }, {
        key: "application-args",
        valueSchema: new OptionalSchema(new ArraySchema(new ByteArraySchema())),
        omitEmpty: true
      }, {
        key: "approval-program",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      }, {
        key: "box-references",
        valueSchema: new OptionalSchema(new ArraySchema(BoxReference2.encodingSchema)),
        omitEmpty: true
      }, {
        key: "clear-state-program",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      }, {
        key: "extra-program-pages",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "foreign-apps",
        valueSchema: new OptionalSchema(new ArraySchema(new Uint64Schema())),
        omitEmpty: true
      }, {
        key: "foreign-assets",
        valueSchema: new OptionalSchema(new ArraySchema(new Uint64Schema())),
        omitEmpty: true
      }, {
        key: "global-state-schema",
        valueSchema: new OptionalSchema(StateSchema2.encodingSchema),
        omitEmpty: true
      }, {
        key: "local-state-schema",
        valueSchema: new OptionalSchema(StateSchema2.encodingSchema),
        omitEmpty: true
      }, {
        key: "on-completion",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "reject-version",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `TransactionApplication` object.
   * @param applicationId - (apid) ID of the application being configured or empty if creating.
   * @param access - (al) Access unifies `accounts`, `foreign-apps`, `foreign-assets`, and
   * `box-references` under a single list. If access is non-empty, these lists must
   * be empty. If access is empty, those lists may be non-empty.
   * @param accounts - (apat) List of accounts in addition to the sender that may be accessed from the
   * application's approval-program and clear-state-program.
   * @param applicationArgs - (apaa) transaction specific arguments accessed from the application's
   * approval-program and clear-state-program.
   * @param approvalProgram - (apap) Logic executed for every application transaction, except when
   * on-completion is set to "clear". It can read and write global state for the
   * application, as well as account-specific local state. Approval programs may
   * reject the transaction.
   * @param boxReferences - (apbx) the boxes that can be accessed by this transaction (and others in the
   * same group).
   * @param clearStateProgram - (apsu) Logic executed for application transactions with on-completion set to
   * "clear". It can read and write global state for the application, as well as
   * account-specific local state. Clear state programs cannot reject the
   * transaction.
   * @param extraProgramPages - (epp) specifies the additional app program len requested in pages.
   * @param foreignApps - (apfa) Lists the applications in addition to the application-id whose global
   * states may be accessed by this application's approval-program and
   * clear-state-program. The access is read-only.
   * @param foreignAssets - (apas) lists the assets whose parameters may be accessed by this application's
   * ApprovalProgram and ClearStateProgram. The access is read-only.
   * @param globalStateSchema - Represents a (apls) local-state or (apgs) global-state schema. These schemas
   * determine how much storage may be used in a local-state or global-state for an
   * application. The more space used, the larger minimum balance must be maintained
   * in the account holding the data.
   * @param localStateSchema - Represents a (apls) local-state or (apgs) global-state schema. These schemas
   * determine how much storage may be used in a local-state or global-state for an
   * application. The more space used, the larger minimum balance must be maintained
   * in the account holding the data.
   * @param onCompletion - (apan) defines the what additional actions occur with the transaction.
   * Valid types:
   * * noop
   * * optin
   * * closeout
   * * clear
   * * update
   * * update
   * * delete
   * @param rejectVersion - (aprv) the lowest application version for which this transaction should
   * immediately fail. 0 indicates that no version check should be performed.
   */
  constructor({ applicationId, access, accounts, applicationArgs, approvalProgram, boxReferences, clearStateProgram, extraProgramPages, foreignApps, foreignAssets, globalStateSchema, localStateSchema, onCompletion, rejectVersion }) {
    this.applicationId = ensureBigInt(applicationId);
    this.access = access;
    this.accounts = typeof accounts !== "undefined" ? accounts.map((addr) => typeof addr === "string" ? Address.fromString(addr) : addr) : void 0;
    this.applicationArgs = applicationArgs;
    this.approvalProgram = typeof approvalProgram === "string" ? base64ToBytes(approvalProgram) : approvalProgram;
    this.boxReferences = boxReferences;
    this.clearStateProgram = typeof clearStateProgram === "string" ? base64ToBytes(clearStateProgram) : clearStateProgram;
    this.extraProgramPages = typeof extraProgramPages === "undefined" ? void 0 : ensureSafeInteger(extraProgramPages);
    this.foreignApps = typeof foreignApps === "undefined" ? void 0 : foreignApps.map(ensureBigInt);
    this.foreignAssets = typeof foreignAssets === "undefined" ? void 0 : foreignAssets.map(ensureBigInt);
    this.globalStateSchema = globalStateSchema;
    this.localStateSchema = localStateSchema;
    this.onCompletion = onCompletion;
    this.rejectVersion = typeof rejectVersion === "undefined" ? void 0 : ensureSafeInteger(rejectVersion);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _TransactionApplication.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["application-id", this.applicationId],
      [
        "access",
        typeof this.access !== "undefined" ? this.access.map((v2) => v2.toEncodingData()) : void 0
      ],
      [
        "accounts",
        typeof this.accounts !== "undefined" ? this.accounts.map((v2) => v2.toString()) : void 0
      ],
      ["application-args", this.applicationArgs],
      ["approval-program", this.approvalProgram],
      [
        "box-references",
        typeof this.boxReferences !== "undefined" ? this.boxReferences.map((v2) => v2.toEncodingData()) : void 0
      ],
      ["clear-state-program", this.clearStateProgram],
      ["extra-program-pages", this.extraProgramPages],
      ["foreign-apps", this.foreignApps],
      ["foreign-assets", this.foreignAssets],
      [
        "global-state-schema",
        typeof this.globalStateSchema !== "undefined" ? this.globalStateSchema.toEncodingData() : void 0
      ],
      [
        "local-state-schema",
        typeof this.localStateSchema !== "undefined" ? this.localStateSchema.toEncodingData() : void 0
      ],
      ["on-completion", this.onCompletion],
      ["reject-version", this.rejectVersion]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded TransactionApplication: ${data}`);
    }
    return new _TransactionApplication({
      applicationId: data.get("application-id"),
      access: typeof data.get("access") !== "undefined" ? data.get("access").map((v2) => ResourceRef.fromEncodingData(v2)) : void 0,
      accounts: data.get("accounts"),
      applicationArgs: data.get("application-args"),
      approvalProgram: data.get("approval-program"),
      boxReferences: typeof data.get("box-references") !== "undefined" ? data.get("box-references").map((v2) => BoxReference2.fromEncodingData(v2)) : void 0,
      clearStateProgram: data.get("clear-state-program"),
      extraProgramPages: data.get("extra-program-pages"),
      foreignApps: data.get("foreign-apps"),
      foreignAssets: data.get("foreign-assets"),
      globalStateSchema: typeof data.get("global-state-schema") !== "undefined" ? StateSchema2.fromEncodingData(data.get("global-state-schema")) : void 0,
      localStateSchema: typeof data.get("local-state-schema") !== "undefined" ? StateSchema2.fromEncodingData(data.get("local-state-schema")) : void 0,
      onCompletion: data.get("on-completion"),
      rejectVersion: data.get("reject-version")
    });
  }
};
var TransactionAssetConfig = class _TransactionAssetConfig {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "asset-id",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "params",
        valueSchema: new OptionalSchema(AssetParams3.encodingSchema),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `TransactionAssetConfig` object.
   * @param assetId - (xaid) ID of the asset being configured or empty if creating.
   * @param params - AssetParams specifies the parameters for an asset.
   * (apar) when part of an AssetConfig transaction.
   * Definition:
   * data/transactions/asset.go : AssetParams
   */
  constructor({ assetId, params }) {
    this.assetId = typeof assetId === "undefined" ? void 0 : ensureBigInt(assetId);
    this.params = params;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _TransactionAssetConfig.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["asset-id", this.assetId],
      [
        "params",
        typeof this.params !== "undefined" ? this.params.toEncodingData() : void 0
      ]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded TransactionAssetConfig: ${data}`);
    }
    return new _TransactionAssetConfig({
      assetId: data.get("asset-id"),
      params: typeof data.get("params") !== "undefined" ? AssetParams3.fromEncodingData(data.get("params")) : void 0
    });
  }
};
var TransactionAssetFreeze = class _TransactionAssetFreeze {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "address", valueSchema: new StringSchema(), omitEmpty: true }, { key: "asset-id", valueSchema: new Uint64Schema(), omitEmpty: true }, {
        key: "new-freeze-status",
        valueSchema: new BooleanSchema(),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `TransactionAssetFreeze` object.
   * @param address - (fadd) Address of the account whose asset is being frozen or thawed.
   * @param assetId - (faid) ID of the asset being frozen or thawed.
   * @param newFreezeStatus - (afrz) The new freeze status.
   */
  constructor({ address, assetId, newFreezeStatus }) {
    this.address = address;
    this.assetId = ensureBigInt(assetId);
    this.newFreezeStatus = newFreezeStatus;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _TransactionAssetFreeze.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["address", this.address],
      ["asset-id", this.assetId],
      ["new-freeze-status", this.newFreezeStatus]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded TransactionAssetFreeze: ${data}`);
    }
    return new _TransactionAssetFreeze({
      address: data.get("address"),
      assetId: data.get("asset-id"),
      newFreezeStatus: data.get("new-freeze-status")
    });
  }
};
var TransactionAssetTransfer = class _TransactionAssetTransfer {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "amount", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "asset-id", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "receiver", valueSchema: new StringSchema(), omitEmpty: true }, {
        key: "close-amount",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "close-to",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      }, {
        key: "sender",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `TransactionAssetTransfer` object.
   * @param amount - (aamt) Amount of asset to transfer. A zero amount transferred to self allocates
   * that asset in the account's Assets map.
   * @param assetId - (xaid) ID of the asset being transferred.
   * @param receiver - (arcv) Recipient address of the transfer.
   * @param closeAmount - Number of assets transferred to the close-to account as part of the transaction.
   * @param closeTo - (aclose) Indicates that the asset should be removed from the account's Assets
   * map, and specifies where the remaining asset holdings should be transferred.
   * It's always valid to transfer remaining asset holdings to the creator account.
   * @param sender - (asnd) The effective sender during a clawback transactions. If this is not a
   * zero value, the real transaction sender must be the Clawback address from the
   * AssetParams.
   */
  constructor({ amount, assetId, receiver, closeAmount, closeTo, sender }) {
    this.amount = ensureBigInt(amount);
    this.assetId = ensureBigInt(assetId);
    this.receiver = receiver;
    this.closeAmount = typeof closeAmount === "undefined" ? void 0 : ensureBigInt(closeAmount);
    this.closeTo = closeTo;
    this.sender = sender;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _TransactionAssetTransfer.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["amount", this.amount],
      ["asset-id", this.assetId],
      ["receiver", this.receiver],
      ["close-amount", this.closeAmount],
      ["close-to", this.closeTo],
      ["sender", this.sender]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded TransactionAssetTransfer: ${data}`);
    }
    return new _TransactionAssetTransfer({
      amount: data.get("amount"),
      assetId: data.get("asset-id"),
      receiver: data.get("receiver"),
      closeAmount: data.get("close-amount"),
      closeTo: data.get("close-to"),
      sender: data.get("sender")
    });
  }
};
var TransactionHeartbeat = class _TransactionHeartbeat {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "hb-address", valueSchema: new StringSchema(), omitEmpty: true }, {
        key: "hb-key-dilution",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "hb-proof",
        valueSchema: HbProofFields.encodingSchema,
        omitEmpty: true
      }, { key: "hb-seed", valueSchema: new ByteArraySchema(), omitEmpty: true }, {
        key: "hb-vote-id",
        valueSchema: new ByteArraySchema(),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `TransactionHeartbeat` object.
   * @param hbAddress - (hbad) HbAddress is the account this txn is proving onlineness for.
   * @param hbKeyDilution - (hbkd) HbKeyDilution must match HbAddress account's current KeyDilution.
   * @param hbProof - (hbprf) HbProof is a signature using HeartbeatAddress's partkey, thereby showing
   * it is online.
   * @param hbSeed - (hbsd) HbSeed must be the block seed for the this transaction's firstValid
   * block.
   * @param hbVoteId - (hbvid) HbVoteID must match the HbAddress account's current VoteID.
   */
  constructor({ hbAddress, hbKeyDilution, hbProof, hbSeed, hbVoteId }) {
    this.hbAddress = hbAddress;
    this.hbKeyDilution = ensureBigInt(hbKeyDilution);
    this.hbProof = hbProof;
    this.hbSeed = typeof hbSeed === "string" ? base64ToBytes(hbSeed) : hbSeed;
    this.hbVoteId = typeof hbVoteId === "string" ? base64ToBytes(hbVoteId) : hbVoteId;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _TransactionHeartbeat.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["hb-address", this.hbAddress],
      ["hb-key-dilution", this.hbKeyDilution],
      ["hb-proof", this.hbProof.toEncodingData()],
      ["hb-seed", this.hbSeed],
      ["hb-vote-id", this.hbVoteId]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded TransactionHeartbeat: ${data}`);
    }
    return new _TransactionHeartbeat({
      hbAddress: data.get("hb-address"),
      hbKeyDilution: data.get("hb-key-dilution"),
      hbProof: HbProofFields.fromEncodingData(data.get("hb-proof") ?? /* @__PURE__ */ new Map()),
      hbSeed: data.get("hb-seed"),
      hbVoteId: data.get("hb-vote-id")
    });
  }
};
var TransactionKeyreg = class _TransactionKeyreg {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "non-participation",
        valueSchema: new OptionalSchema(new BooleanSchema()),
        omitEmpty: true
      }, {
        key: "selection-participation-key",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      }, {
        key: "state-proof-key",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      }, {
        key: "vote-first-valid",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "vote-key-dilution",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "vote-last-valid",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "vote-participation-key",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `TransactionKeyreg` object.
   * @param nonParticipation - (nonpart) Mark the account as participating or non-participating.
   * @param selectionParticipationKey - (selkey) Public key used with the Verified Random Function (VRF) result during
   * committee selection.
   * @param stateProofKey - (sprfkey) State proof key used in key registration transactions.
   * @param voteFirstValid - (votefst) First round this participation key is valid.
   * @param voteKeyDilution - (votekd) Number of subkeys in each batch of participation keys.
   * @param voteLastValid - (votelst) Last round this participation key is valid.
   * @param voteParticipationKey - (votekey) Participation public key used in key registration transactions.
   */
  constructor({ nonParticipation, selectionParticipationKey, stateProofKey, voteFirstValid, voteKeyDilution, voteLastValid, voteParticipationKey }) {
    this.nonParticipation = nonParticipation;
    this.selectionParticipationKey = typeof selectionParticipationKey === "string" ? base64ToBytes(selectionParticipationKey) : selectionParticipationKey;
    this.stateProofKey = typeof stateProofKey === "string" ? base64ToBytes(stateProofKey) : stateProofKey;
    this.voteFirstValid = typeof voteFirstValid === "undefined" ? void 0 : ensureBigInt(voteFirstValid);
    this.voteKeyDilution = typeof voteKeyDilution === "undefined" ? void 0 : ensureBigInt(voteKeyDilution);
    this.voteLastValid = typeof voteLastValid === "undefined" ? void 0 : ensureBigInt(voteLastValid);
    this.voteParticipationKey = typeof voteParticipationKey === "string" ? base64ToBytes(voteParticipationKey) : voteParticipationKey;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _TransactionKeyreg.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["non-participation", this.nonParticipation],
      ["selection-participation-key", this.selectionParticipationKey],
      ["state-proof-key", this.stateProofKey],
      ["vote-first-valid", this.voteFirstValid],
      ["vote-key-dilution", this.voteKeyDilution],
      ["vote-last-valid", this.voteLastValid],
      ["vote-participation-key", this.voteParticipationKey]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded TransactionKeyreg: ${data}`);
    }
    return new _TransactionKeyreg({
      nonParticipation: data.get("non-participation"),
      selectionParticipationKey: data.get("selection-participation-key"),
      stateProofKey: data.get("state-proof-key"),
      voteFirstValid: data.get("vote-first-valid"),
      voteKeyDilution: data.get("vote-key-dilution"),
      voteLastValid: data.get("vote-last-valid"),
      voteParticipationKey: data.get("vote-participation-key")
    });
  }
};
var TransactionPayment = class _TransactionPayment {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "amount", valueSchema: new Uint64Schema(), omitEmpty: true }, { key: "receiver", valueSchema: new StringSchema(), omitEmpty: true }, {
        key: "close-amount",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "close-remainder-to",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `TransactionPayment` object.
   * @param amount - (amt) number of MicroAlgos intended to be transferred.
   * @param receiver - (rcv) receiver's address.
   * @param closeAmount - Number of MicroAlgos that were sent to the close-remainder-to address when
   * closing the sender account.
   * @param closeRemainderTo - (close) when set, indicates that the sending account should be closed and all
   * remaining funds be transferred to this address.
   */
  constructor({ amount, receiver, closeAmount, closeRemainderTo }) {
    this.amount = ensureBigInt(amount);
    this.receiver = receiver;
    this.closeAmount = typeof closeAmount === "undefined" ? void 0 : ensureBigInt(closeAmount);
    this.closeRemainderTo = closeRemainderTo;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _TransactionPayment.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["amount", this.amount],
      ["receiver", this.receiver],
      ["close-amount", this.closeAmount],
      ["close-remainder-to", this.closeRemainderTo]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded TransactionPayment: ${data}`);
    }
    return new _TransactionPayment({
      amount: data.get("amount"),
      receiver: data.get("receiver"),
      closeAmount: data.get("close-amount"),
      closeRemainderTo: data.get("close-remainder-to")
    });
  }
};
var TransactionResponse = class _TransactionResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "current-round",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "transaction",
        valueSchema: Transaction2.encodingSchema,
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `TransactionResponse` object.
   * @param currentRound - Round at which the results were computed.
   * @param transaction - Contains all fields common to all transactions and serves as an envelope to all
   * transactions type. Represents both regular and inner transactions.
   * Definition:
   * data/transactions/signedtxn.go : SignedTxn
   * data/transactions/transaction.go : Transaction
   */
  constructor({ currentRound, transaction }) {
    this.currentRound = ensureBigInt(currentRound);
    this.transaction = transaction;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _TransactionResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["current-round", this.currentRound],
      ["transaction", this.transaction.toEncodingData()]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded TransactionResponse: ${data}`);
    }
    return new _TransactionResponse({
      currentRound: data.get("current-round"),
      transaction: Transaction2.fromEncodingData(data.get("transaction") ?? /* @__PURE__ */ new Map())
    });
  }
};
var TransactionSignature = class _TransactionSignature {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "logicsig",
        valueSchema: new OptionalSchema(TransactionSignatureLogicsig.encodingSchema),
        omitEmpty: true
      }, {
        key: "multisig",
        valueSchema: new OptionalSchema(TransactionSignatureMultisig.encodingSchema),
        omitEmpty: true
      }, {
        key: "sig",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `TransactionSignature` object.
   * @param logicsig - (lsig) Programatic transaction signature.
   * Definition:
   * data/transactions/logicsig.go
   * @param multisig - structure holding multiple subsignatures.
   * Definition:
   * crypto/multisig.go : MultisigSig
   * @param sig - (sig) Standard ed25519 signature.
   */
  constructor({ logicsig, multisig, sig }) {
    this.logicsig = logicsig;
    this.multisig = multisig;
    this.sig = typeof sig === "string" ? base64ToBytes(sig) : sig;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _TransactionSignature.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      [
        "logicsig",
        typeof this.logicsig !== "undefined" ? this.logicsig.toEncodingData() : void 0
      ],
      [
        "multisig",
        typeof this.multisig !== "undefined" ? this.multisig.toEncodingData() : void 0
      ],
      ["sig", this.sig]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded TransactionSignature: ${data}`);
    }
    return new _TransactionSignature({
      logicsig: typeof data.get("logicsig") !== "undefined" ? TransactionSignatureLogicsig.fromEncodingData(data.get("logicsig")) : void 0,
      multisig: typeof data.get("multisig") !== "undefined" ? TransactionSignatureMultisig.fromEncodingData(data.get("multisig")) : void 0,
      sig: data.get("sig")
    });
  }
};
var TransactionSignatureLogicsig = class _TransactionSignatureLogicsig {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({ key: "logic", valueSchema: new ByteArraySchema(), omitEmpty: true }, {
        key: "args",
        valueSchema: new OptionalSchema(new ArraySchema(new ByteArraySchema())),
        omitEmpty: true
      }, {
        key: "logic-multisig-signature",
        valueSchema: new OptionalSchema(TransactionSignatureMultisig.encodingSchema),
        omitEmpty: true
      }, {
        key: "multisig-signature",
        valueSchema: new OptionalSchema(TransactionSignatureMultisig.encodingSchema),
        omitEmpty: true
      }, {
        key: "signature",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `TransactionSignatureLogicsig` object.
   * @param logic - (l) Program signed by a signature or multi signature, or hashed to be the
   * address of ana ccount. Base64 encoded TEAL program.
   * @param args - (arg) Logic arguments, base64 encoded.
   * @param logicMultisigSignature - structure holding multiple subsignatures.
   * Definition:
   * crypto/multisig.go : MultisigSig
   * @param multisigSignature - structure holding multiple subsignatures.
   * Definition:
   * crypto/multisig.go : MultisigSig
   * @param signature - (sig) ed25519 signature.
   */
  constructor({ logic, args, logicMultisigSignature, multisigSignature, signature }) {
    this.logic = typeof logic === "string" ? base64ToBytes(logic) : logic;
    this.args = args;
    this.logicMultisigSignature = logicMultisigSignature;
    this.multisigSignature = multisigSignature;
    this.signature = typeof signature === "string" ? base64ToBytes(signature) : signature;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _TransactionSignatureLogicsig.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["logic", this.logic],
      ["args", this.args],
      [
        "logic-multisig-signature",
        typeof this.logicMultisigSignature !== "undefined" ? this.logicMultisigSignature.toEncodingData() : void 0
      ],
      [
        "multisig-signature",
        typeof this.multisigSignature !== "undefined" ? this.multisigSignature.toEncodingData() : void 0
      ],
      ["signature", this.signature]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded TransactionSignatureLogicsig: ${data}`);
    }
    return new _TransactionSignatureLogicsig({
      logic: data.get("logic"),
      args: data.get("args"),
      logicMultisigSignature: typeof data.get("logic-multisig-signature") !== "undefined" ? TransactionSignatureMultisig.fromEncodingData(data.get("logic-multisig-signature")) : void 0,
      multisigSignature: typeof data.get("multisig-signature") !== "undefined" ? TransactionSignatureMultisig.fromEncodingData(data.get("multisig-signature")) : void 0,
      signature: data.get("signature")
    });
  }
};
var TransactionSignatureMultisig = class _TransactionSignatureMultisig {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "subsignature",
        valueSchema: new OptionalSchema(new ArraySchema(TransactionSignatureMultisigSubsignature.encodingSchema)),
        omitEmpty: true
      }, {
        key: "threshold",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      }, {
        key: "version",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `TransactionSignatureMultisig` object.
   * @param subsignature - (subsig) holds pairs of public key and signatures.
   * @param threshold - (thr)
   * @param version - (v)
   */
  constructor({ subsignature, threshold, version }) {
    this.subsignature = subsignature;
    this.threshold = typeof threshold === "undefined" ? void 0 : ensureSafeInteger(threshold);
    this.version = typeof version === "undefined" ? void 0 : ensureSafeInteger(version);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _TransactionSignatureMultisig.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      [
        "subsignature",
        typeof this.subsignature !== "undefined" ? this.subsignature.map((v2) => v2.toEncodingData()) : void 0
      ],
      ["threshold", this.threshold],
      ["version", this.version]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded TransactionSignatureMultisig: ${data}`);
    }
    return new _TransactionSignatureMultisig({
      subsignature: typeof data.get("subsignature") !== "undefined" ? data.get("subsignature").map((v2) => TransactionSignatureMultisigSubsignature.fromEncodingData(v2)) : void 0,
      threshold: data.get("threshold"),
      version: data.get("version")
    });
  }
};
var TransactionSignatureMultisigSubsignature = class _TransactionSignatureMultisigSubsignature {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "public-key",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      }, {
        key: "signature",
        valueSchema: new OptionalSchema(new ByteArraySchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `TransactionSignatureMultisigSubsignature` object.
   * @param publicKey - (pk)
   * @param signature - (s)
   */
  constructor({ publicKey, signature }) {
    this.publicKey = typeof publicKey === "string" ? base64ToBytes(publicKey) : publicKey;
    this.signature = typeof signature === "string" ? base64ToBytes(signature) : signature;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _TransactionSignatureMultisigSubsignature.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["public-key", this.publicKey],
      ["signature", this.signature]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded TransactionSignatureMultisigSubsignature: ${data}`);
    }
    return new _TransactionSignatureMultisigSubsignature({
      publicKey: data.get("public-key"),
      signature: data.get("signature")
    });
  }
};
var TransactionStateProof = class _TransactionStateProof {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "message",
        valueSchema: new OptionalSchema(IndexerStateProofMessage.encodingSchema),
        omitEmpty: true
      }, {
        key: "state-proof",
        valueSchema: new OptionalSchema(StateProofFields.encodingSchema),
        omitEmpty: true
      }, {
        key: "state-proof-type",
        valueSchema: new OptionalSchema(new Uint64Schema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `TransactionStateProof` object.
   * @param message - (spmsg)
   * @param stateProof - (sp) represents a state proof.
   * Definition:
   * crypto/stateproof/structs.go : StateProof
   * @param stateProofType - (sptype) Type of the state proof. Integer representing an entry defined in
   * protocol/stateproof.go
   */
  constructor({ message, stateProof, stateProofType }) {
    this.message = message;
    this.stateProof = stateProof;
    this.stateProofType = typeof stateProofType === "undefined" ? void 0 : ensureSafeInteger(stateProofType);
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _TransactionStateProof.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      [
        "message",
        typeof this.message !== "undefined" ? this.message.toEncodingData() : void 0
      ],
      [
        "state-proof",
        typeof this.stateProof !== "undefined" ? this.stateProof.toEncodingData() : void 0
      ],
      ["state-proof-type", this.stateProofType]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded TransactionStateProof: ${data}`);
    }
    return new _TransactionStateProof({
      message: typeof data.get("message") !== "undefined" ? IndexerStateProofMessage.fromEncodingData(data.get("message")) : void 0,
      stateProof: typeof data.get("state-proof") !== "undefined" ? StateProofFields.fromEncodingData(data.get("state-proof")) : void 0,
      stateProofType: data.get("state-proof-type")
    });
  }
};
var TransactionsResponse = class _TransactionsResponse {
  static get encodingSchema() {
    if (!this.encodingSchemaValue) {
      this.encodingSchemaValue = new NamedMapSchema([]);
      this.encodingSchemaValue.pushEntries({
        key: "current-round",
        valueSchema: new Uint64Schema(),
        omitEmpty: true
      }, {
        key: "transactions",
        valueSchema: new ArraySchema(Transaction2.encodingSchema),
        omitEmpty: true
      }, {
        key: "next-token",
        valueSchema: new OptionalSchema(new StringSchema()),
        omitEmpty: true
      });
    }
    return this.encodingSchemaValue;
  }
  /**
   * Creates a new `TransactionsResponse` object.
   * @param currentRound - Round at which the results were computed.
   * @param transactions -
   * @param nextToken - Used for pagination, when making another request provide this token with the
   * next parameter.
   */
  constructor({ currentRound, transactions, nextToken }) {
    this.currentRound = ensureBigInt(currentRound);
    this.transactions = transactions;
    this.nextToken = nextToken;
  }
  // eslint-disable-next-line class-methods-use-this
  getEncodingSchema() {
    return _TransactionsResponse.encodingSchema;
  }
  toEncodingData() {
    return /* @__PURE__ */ new Map([
      ["current-round", this.currentRound],
      ["transactions", this.transactions.map((v2) => v2.toEncodingData())],
      ["next-token", this.nextToken]
    ]);
  }
  static fromEncodingData(data) {
    if (!(data instanceof Map)) {
      throw new Error(`Invalid decoded TransactionsResponse: ${data}`);
    }
    return new _TransactionsResponse({
      currentRound: data.get("current-round"),
      transactions: (data.get("transactions") ?? []).map((v2) => Transaction2.fromEncodingData(v2)),
      nextToken: data.get("next-token")
    });
  }
};

// node_modules/algosdk/dist/esm/client/v2/indexer/makeHealthCheck.js
var MakeHealthCheck = class extends JSONRequest {
  /**
   * @returns `/health`
   */
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/health";
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), HealthCheck2);
  }
};

// node_modules/algosdk/dist/esm/client/v2/indexer/lookupAssetBalances.js
var LookupAssetBalances = class extends JSONRequest {
  /**
   * Returns the list of accounts which hold the given asset and their balance.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const assetBalances = await indexerClient.lookupAssetBalances(assetId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2assetsasset-idbalances)
   * @param index - The asset ID to look up.
   */
  constructor(c2, index) {
    super(c2);
    this.index = BigInt(index);
  }
  /**
   * @returns `/v2/assets/${index}/balances`
   */
  path() {
    return `/v2/assets/${this.index}/balances`;
  }
  /**
   * Limit results for pagination.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const maxResults = 20;
   * const assetBalances = await indexerClient
   *        .lookupAssetBalances(assetId)
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit - maximum number of results to return.
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Filtered results should have an asset balance greater than this value.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const minBalance = 1000000;
   * const assetBalances = await indexerClient
   *        .lookupAssetBalances(assetId)
   *        .currencyGreaterThan(minBalance)
   *        .do();
   * ```
   * @param greater
   * @category query
   */
  currencyGreaterThan(greater) {
    this.query["currency-greater-than"] = greater.toString();
    return this;
  }
  /**
   * Filtered results should have an asset balance less than this value.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const maxBalance = 2000000;
   * const assetBalances = await indexerClient
   *        .lookupAssetBalances(assetId)
   *        .currencyLessThan(maxBalance)
   *        .do();
   * ```
   * @param lesser
   * @category query
   */
  currencyLessThan(lesser) {
    this.query["currency-less-than"] = lesser;
    return this;
  }
  /**
   * Specify the next page of results.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const maxResults = 20;
   *
   * const assetBalancesPage1 = await indexerClient
   *        .lookupAssetBalances(assetId)
   *        .limit(maxResults)
   *        .do();
   *
   * const assetBalancesPage2 = await indexerClient
   *        .lookupAssetBalances(assetId)
   *        .limit(maxResults)
   *        .nextToken(assetBalancesPage1["next-token"])
   *        .do();
   * ```
   * @param nextToken - provided by the previous results.
   * @category query
   */
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  /**
   * Include all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates.
   *
   * #### Example 1
   * ```typescript
   * const assetId = 163650;
   * const assetBalances = await indexerClient
   *        .lookupAssetBalances(assetId)
   *        .includeAll(false)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const assetId = 163650;
   * const assetBalances = await indexerClient
   *        .lookupAssetBalances(assetId)
   *        .includeAll()
   *        .do();
   * ```
   *
   * @param value
   * @category query
   */
  includeAll(value = true) {
    this.query["include-all"] = value;
    return this;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), AssetBalancesResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/indexer/lookupAccountTransactions.js
function base64StringFunnel(data) {
  if (typeof data === "string") {
    return data;
  }
  return bytesToBase64(data);
}
var LookupAccountTransactions = class extends JSONRequest {
  /**
   * Returns transactions relating to the given account.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient.lookupAccountTransactions(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-idtransactions)
   * @param account - The address of the account.
   */
  constructor(c2, account) {
    super(c2);
    this.account = account.toString();
  }
  /**
   * @returns `/v2/accounts/${account}/transactions`
   */
  path() {
    return `/v2/accounts/${this.account}/transactions`;
  }
  /**
   * Specifies a prefix which must be contained in the note field.
   *
   * #### Example
   * ```typescript
   * const notePrefixBase64Encoded = "Y3JlYXRl";
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .notePrefix(notePrefixBase64Encoded)
   *        .do();
   * ```
   *
   * @param prefix - base64 string or uint8array
   * @category query
   */
  notePrefix(prefix) {
    this.query["note-prefix"] = base64StringFunnel(prefix);
    return this;
  }
  /**
   * Type of transaction to filter with.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .txType("appl")
   *        .do();
   * ```
   *
   * @param type - one of `pay`, `keyreg`, `acfg`, `axfer`, `afrz`, `appl`, `stpf`
   * @category query
   */
  txType(type) {
    this.query["tx-type"] = type;
    return this;
  }
  /**
   * Type of signature to filter with.
   * - sig: Standard
   * - msig: MultiSig
   * - lsig: LogicSig
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .sigType("msig")
   *        .do();
   * ```
   *
   * @param type - one of `sig`, `msig`, `lsig`
   * @category query
   */
  sigType(type) {
    this.query["sig-type"] = type;
    return this;
  }
  /**
   * Lookup the specific transaction by ID.
   *
   * #### Example
   * ```typescript
   * const txId = "MEUOC4RQJB23CQZRFRKYEI6WBO73VTTPST5A7B3S5OKBUY6LFUDA";
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .txid(txId)
   *        .do();
   * ```
   * @remarks Alternatively, use `indexerClient.lookupTransactionByID(txnId).do()`
   * @param txid
   * @category query
   */
  txid(txid) {
    this.query.txid = txid;
    return this;
  }
  /**
   * Include results for the specified round.
   *
   * #### Example
   * ```typescript
   * const targetBlock = 18309917;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .round(targetBlock)
   *        .do();
   * ```
   *
   * @param round
   * @category query
   */
  round(round) {
    this.query.round = round;
    return this;
  }
  /**
   * Include results at or after the specified min-round.
   *
   * #### Example
   * ```typescript
   * const minRound = 18309917;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .minRound(minRound)
   *        .do();
   * ```
   *
   * @param round
   * @category query
   */
  minRound(round) {
    this.query["min-round"] = round;
    return this;
  }
  /**
   * Include results at or before the specified max-round.
   *
   * #### Example
   * ```typescript
   * const maxRound = 18309917;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .maxRound(maxRound)
   *        .do();
   * ```
   *
   * @param round
   * @category query
   */
  maxRound(round) {
    this.query["max-round"] = round;
    return this;
  }
  /**
   * Asset ID to filter with.
   *
   * #### Example
   * ```typescript
   * const assetID = 163650;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .assetID(assetID)
   *        .do();
   * ```
   *
   * @param id
   * @category query
   */
  assetID(id) {
    this.query["asset-id"] = id;
    return this;
  }
  /**
   * Maximum number of results to return.
   *
   * #### Example
   * ```typescript
   * const maxResults = 25;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Include results before the given time.
   *
   * #### Example
   * ```typescript
   * const beforeTime = "2022-02-02T20:20:22.02Z";
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .beforeTime(beforeTime)
   *        .do();
   * ```
   *
   * @param before - rfc3339 string or Date object
   * @category query
   */
  beforeTime(before) {
    this.query["before-time"] = before instanceof Date ? before.toISOString() : before;
    return this;
  }
  /**
   * Include results after the given time.
   *
   * #### Example
   * ```typescript
   * const afterTime = "2022-10-21T00:00:11.55Z";
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .afterTime(afterTime)
   *        .do();
   * ```
   *
   * @param after - rfc3339 string or Date object
   * @category query
   */
  afterTime(after) {
    this.query["after-time"] = after instanceof Date ? after.toISOString() : after;
    return this;
  }
  /**
   * Filtered results should have an amount greater than this value, as int, representing microAlgos, unless an asset-id is provided, in which case units are in the asset's units.
   *
   * #### Example 1
   * ```typescript
   * const minBalance = 300000;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .currencyGreaterThan(minBalance - 1)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const assetID = 163650;
   * const minBalance = 300000;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .assetID(assetID)
   *        .currencyGreaterThan(minBalance - 1)
   *        .do();
   * ```
   *
   * @param greater
   * @category query
   */
  currencyGreaterThan(greater) {
    this.query["currency-greater-than"] = greater.toString();
    return this;
  }
  /**
   * Filtered results should have an amount less than this value, as int, representing microAlgos, unless an asset-id is provided, in which case units are in the asset's units.
   *
   * #### Example 1
   * ```typescript
   * const maxBalance = 500000;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .currencyLessThan(maxBalance + 1)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const assetID = 163650;
   * const maxBalance = 500000;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .assetID(assetID)
   *        .currencyLessThan(maxBalance + 1)
   *        .do();
   * ```
   *
   * @param lesser
   * @category query
   */
  currencyLessThan(lesser) {
    this.query["currency-less-than"] = lesser;
    return this;
  }
  /**
   * The next page of results. Use the next token provided by the previous results.
   *
   * #### Example
   * ```typescript
   * const maxResults = 25;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   *
   * const accountTxnsPage1 = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .limit(maxResults)
   *        .do();
   *
   * const accountTxnsPage2 = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .limit(maxResults)
   *        .nextToken(accountTxnsPage1["next-token"])
   *        .do();
   * ```
   *
   * @param nextToken - provided by the previous results.
   * @category query
   */
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  /**
   * Whether or not to include rekeying transactions.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient
   *        .lookupAccountTransactions(address)
   *        .rekeyTo(false)
   *        .do();
   * ```
   *
   * @param rekeyTo
   * @category query
   */
  rekeyTo(rekeyTo) {
    this.query["rekey-to"] = rekeyTo;
    return this;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), TransactionsResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/indexer/lookupAssetTransactions.js
var LookupAssetTransactions = class extends JSONRequest {
  /**
   * Returns transactions relating to the given asset.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const assetTxns = await indexerClient.lookupAssetTransactions(assetId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2assetsasset-idtransactions)
   * @param index - The asset ID to look up.
   */
  constructor(c2, index) {
    super(c2);
    this.index = BigInt(index);
  }
  /**
   * @returns `/v2/assets/${index}/transactions`
   */
  path() {
    return `/v2/assets/${this.index}/transactions`;
  }
  /**
   * Specifies a prefix which must be contained in the note field.
   *
   * #### Example
   * ```typescript
   * const notePrefixBase64Encoded = "Y3JlYXRl";
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .notePrefix(notePrefixBase64Encoded)
   *        .do();
   * ```
   *
   * @param prefix - base64 string or uint8array
   * @category query
   */
  notePrefix(prefix) {
    this.query["note-prefix"] = base64StringFunnel(prefix);
    return this;
  }
  /**
   * Type of transaction to filter with.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .txType("axfer")
   *        .do();
   * ```
   *
   * @param type - one of `pay`, `keyreg`, `acfg`, `axfer`, `afrz`, `appl`
   * @category query
   */
  txType(type) {
    this.query["tx-type"] = type;
    return this;
  }
  /**
   * Type of signature to filter with.
   * - sig: Standard
   * - msig: MultiSig
   * - lsig: LogicSig
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .sigType("lsig")
   *        .do();
   * ```
   *
   * @param type - one of `sig`, `msig`, `lsig`
   * @category query
   */
  sigType(type) {
    this.query["sig-type"] = type;
    return this;
  }
  /**
   * Lookup the specific transaction by ID.
   *
   * #### Example
   * ```typescript
   * const txId = "MEUOC4RQJB23CQZRFRKYEI6WBO73VTTPST5A7B3S5OKBUY6LFUDA";
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .txid(txId)
   *        .do();
   * ```
   *
   * @param txid
   * @category query
   */
  txid(txid) {
    this.query.txid = txid;
    return this;
  }
  /**
   * Include results for the specified round.
   *
   * #### Example
   * ```typescript
   * const targetBlock = 18309917;
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .round(targetBlock)
   *        .do();
   * ```
   *
   * @param round
   * @category query
   */
  round(round) {
    this.query.round = round;
    return this;
  }
  /**
   * Include results at or after the specified min-round.
   *
   * #### Example
   * ```typescript
   * const minRound = 18309917;
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .minRound(minRound)
   *        .do();
   * ```
   *
   * @param round
   * @category query
   */
  minRound(round) {
    this.query["min-round"] = round;
    return this;
  }
  /**
   * Include results at or before the specified max-round.
   *
   * #### Example
   * ```typescript
   * const maxRound = 18309917;
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .maxRound(maxRound)
   *        .do();
   * ```
   *
   * @param round
   * @category query
   */
  maxRound(round) {
    this.query["max-round"] = round;
    return this;
  }
  /**
   * Maximum number of results to return.
   *
   * #### Example
   * ```typescript
   * const maxResults = 25;
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Include results before the given time.
   *
   * #### Example
   * ```typescript
   * const beforeTime = "2022-02-02T20:20:22.02Z";
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .beforeTime(beforeTime)
   *        .do();
   * ```
   *
   * @param before - rfc3339 string or Date object
   * @category query
   */
  beforeTime(before) {
    this.query["before-time"] = before instanceof Date ? before.toISOString() : before;
    return this;
  }
  /**
   * Include results after the given time.
   *
   * #### Example
   * ```typescript
   * const afterTime = "2022-10-21T00:00:11.55Z";
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .afterTime(afterTime)
   *        .do();
   * ```
   *
   * @param after - rfc3339 string or Date object
   * @category query
   */
  afterTime(after) {
    this.query["after-time"] = after instanceof Date ? after.toISOString() : after;
    return this;
  }
  /**
   * Filtered results should have an amount greater than this value, as int, representing asset units.
   *
   * #### Example
   * ```typescript
   * const minBalance = 300000;
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .currencyGreaterThan(minBalance - 1)
   *        .do();
   * ```
   *
   * @param greater
   * @category query
   */
  currencyGreaterThan(greater) {
    this.query["currency-greater-than"] = greater.toString();
    return this;
  }
  /**
   * Filtered results should have an amount less than this value, as int, representing asset units.
   *
   * #### Example
   * ```typescript
   * const maxBalance = 500000;
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .currencyLessThan(maxBalance + 1)
   *        .do();
   * ```
   *
   * @param lesser
   * @category query
   */
  currencyLessThan(lesser) {
    this.query["currency-less-than"] = lesser;
    return this;
  }
  /**
   * Combined with address, defines what address to filter on, as string.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const role = "sender";
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .address(address)
   *        .addressRole(role)
   *        .do();
   * ```
   *
   * @param role - one of `sender`, `receiver`, `freeze-target`
   * @category query
   */
  addressRole(role) {
    this.query["address-role"] = role;
    return this;
  }
  /**
   * Only include transactions with this address in one of the transaction fields.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .address(address)
   *        .do();
   * ```
   *
   * @param address
   * @category query
   */
  address(address) {
    this.query.address = address.toString();
    return this;
  }
  /**
   * Whether or not to consider the `close-to` field as a receiver when filtering transactions, as bool. Set to `true` to ignore `close-to`.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .excludeCloseTo(true)
   *        .do();
   * ```
   *
   * @param exclude
   * @category query
   */
  excludeCloseTo(exclude) {
    this.query["exclude-close-to"] = exclude;
    return this;
  }
  /**
   * The next page of results.
   *
   * #### Example
   * ```typescript
   * const maxResults = 25;
   * const assetId = 163650;
   *
   * const assetTxnsPage1 = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .limit(maxResults)
   *        .do();
   *
   * const assetTxnsPage2 = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .limit(maxResults)
   *        .nextToken(assetTxnsPage1["next-token"])
   *        .do();
   * ```
   *
   * @param nextToken - provided by the previous results.
   * @category query
   */
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  /**
   * Whether or not to include rekeying transactions.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const assetTxns = await indexerClient
   *        .lookupAssetTransactions(assetId)
   *        .rekeyTo(false)
   *        .do();
   * ```
   *
   * @param rekeyTo
   * @category query
   */
  rekeyTo(rekeyTo) {
    this.query["rekey-to"] = rekeyTo;
    return this;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), TransactionsResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/indexer/lookupBlock.js
var LookupBlock = class extends JSONRequest {
  /**
   * Returns the block for the passed round.
   *
   * #### Example
   * ```typescript
   * const targetBlock = 18309917;
   * const blockInfo = await indexerClient.lookupBlock(targetBlock).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2blocksround-number)
   * @param round - The number of the round to look up.
   * @category GET
   */
  constructor(c2, round) {
    super(c2);
    this.round = BigInt(round);
  }
  /**
   * @returns `/v2/blocks/${round}`
   */
  path() {
    return `/v2/blocks/${this.round}`;
  }
  /**
   * Header only flag. When this is set to true, returned block does not contain the
   * transactions.
   */
  headerOnly(headerOnly) {
    this.query["header-only"] = headerOnly;
    return this;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), Block3);
  }
};

// node_modules/algosdk/dist/esm/client/v2/indexer/lookupTransactionByID.js
var LookupTransactionByID = class extends JSONRequest {
  /**
   * Returns information about the given transaction.
   *
   * #### Example
   * ```typescript
   * const txnId = "MEUOC4RQJB23CQZRFRKYEI6WBO73VTTPST5A7B3S5OKBUY6LFUDA";
   * const txnInfo = await indexerClient.lookupTransactionByID(txnId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2transactionstxid)
   * @param txID - The ID of the transaction to look up.
   * @category GET
   */
  constructor(c2, txID) {
    super(c2);
    this.txID = txID;
  }
  /**
   * @returns `/v2/transactions/${txID}`
   */
  path() {
    return `/v2/transactions/${this.txID}`;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), TransactionResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/indexer/lookupAccountByID.js
var LookupAccountByID = class extends JSONRequest {
  /**
   * Returns information about the given account.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountInfo = await indexerClient.lookupAccountByID(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-id)
   * @param account - The address of the account to look up.
   * @category GET
   */
  constructor(c2, account) {
    super(c2);
    this.account = account.toString();
  }
  /**
   * @returns `/v2/accounts/${account}`
   */
  path() {
    return `/v2/accounts/${this.account}`;
  }
  /**
   * Specify round to filter with.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const targetBlock = 18309917;
   * const accountInfo = await indexerClient
   *        .lookupAccountByID(address)
   *        .round(targetBlock)
   *        .do();
   * ```
   * @param round
   */
  round(round) {
    this.query.round = round;
    return this;
  }
  /**
   * Include all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates.
   *
   * #### Example 1
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountInfo = await indexerClient
   *        .lookupAccountByID(address)
   *        .includeAll(false)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountInfo = await indexerClient
   *        .lookupAccountByID(address)
   *        .includeAll()
   *        .do();
   * ```
   * @param value
   */
  includeAll(value = true) {
    this.query["include-all"] = value;
    return this;
  }
  /**
   * Exclude additional items such as asset holdings, application local data stored for this account, asset parameters created by this account, and application parameters created by this account.
   *
   * #### Example 1
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountInfo = await indexerClient
   *        .lookupAccountByID(address)
   *        .exclude("all")
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountInfo = await indexerClient
   *        .lookupAccountByID(address)
   *        .exclude("assets,created-assets")
   *        .do();
   * ```
   * @remarks By default, it behaves as exclude=none
   * @param exclude - Array of `all`, `assets`, `created-assets`, `apps-local-state`, `created-apps`, `none`
   * @category query
   */
  exclude(exclude) {
    this.query.exclude = exclude;
    return this;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), AccountResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/indexer/lookupAccountAssets.js
var LookupAccountAssets = class extends JSONRequest {
  /**
   * Returns asset about the given account.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountAssets = await indexerClient.lookupAccountAssets(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-idassets)
   * @param account - The address of the account to look up.
   * @category GET
   */
  constructor(c2, account) {
    super(c2);
    this.account = account.toString();
  }
  /**
   * @returns `/v2/accounts/${account}/assets`
   */
  path() {
    return `/v2/accounts/${this.account}/assets`;
  }
  /**
   * Add a limit for filter.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const maxResults = 20;
   * const accountAssets = await indexerClient
   *        .lookupAccountAssets(address)
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit - maximum number of results to return.
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Specify round to filter with.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const targetBlock = 18309917;
   * const accountAssets = await indexerClient
   *        .lookupAccountAssets(address)
   *        .round(targetBlock)
   *        .do();
   * ```
   * @param round
   * @category query
   */
  round(round) {
    this.query.round = round;
    return this;
  }
  /**
   * Specify the next page of results.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const maxResults = 20;
   *
   * const accountAssetsPage1 = await indexerClient
   *        .lookupAccountAssets(address)
   *        .limit(maxResults)
   *        .do();
   *
   * const accountAssetsPage2 = await indexerClient
   *        .lookupAccountAssets(address)
   *        .limit(maxResults)
   *        .next(accountAssetsPage1["next-token"])
   *        .do();
   * ```
   * @param nextToken - provided by the previous results.
   * @category query
   */
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  /**
   * Include all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountAssets = await indexerClient
   *        .lookupAccountAssets(address)
   *        .includeAll(false)
   *        .do();
   * ```
   * @param value
   * @category query
   */
  includeAll(value = true) {
    this.query["include-all"] = value;
    return this;
  }
  /**
   * Specify an assetID to search for.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const assetAssets = await indexerClient
   *        .lookupAccountAssets(address)
   *        .assetId(assetId)
   *        .do();
   * ```
   * @param index - the assetID
   * @category query
   */
  assetId(index) {
    this.query["asset-id"] = index;
    return this;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), AssetHoldingsResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/indexer/lookupAccountCreatedAssets.js
var LookupAccountCreatedAssets = class extends JSONRequest {
  /**
   * Returns asset information created by the given account.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountCreatedAssets = await indexerClient.lookupAccountCreatedAssets(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-idcreated-assets)
   * @param account - The address of the account to look up.
   * @category GET
   */
  constructor(c2, account) {
    super(c2);
    this.account = account.toString();
  }
  /**
   * @returns `/v2/accounts/${account}/created-assets`
   */
  path() {
    return `/v2/accounts/${this.account}/created-assets`;
  }
  /**
   * Add a limit for filter.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const maxResults = 20;
   * const accountAssets = await indexerClient
   *        .lookupAccountCreatedAssets(address)
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit - maximum number of results to return.
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Specify round to filter with.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const targetBlock = 18309917;
   * const accountAssets = await indexerClient
   *        .lookupAccountCreatedAssets(address)
   *        .round(targetBlock)
   *        .do();
   * ```
   * @param round
   * @category query
   */
  round(round) {
    this.query.round = round;
    return this;
  }
  /**
   * Specify the next page of results.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const maxResults = 20;
   *
   * const accountAssetsPage1 = await indexerClient
   *        .lookupAccountCreatedAssets(address)
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * const accountAssetsPage2 = await indexerClient
   *        .lookupAccountCreatedAssets(address)
   *        .limit(maxResults)
   *        .next(accountAssetsPage1["next-token"])
   *        .do();
   * ```
   * @param nextToken - provided by the previous results.
   * @category query
   */
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  /**
   * Include all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountAssets = await indexerClient
   *        .lookupAccountCreatedAssets(address)
   *        .includeAll(false)
   *        .do();
   * ```
   * @param value
   * @category query
   */
  includeAll(value = true) {
    this.query["include-all"] = value;
    return this;
  }
  /**
   * Specify an assetID to search for.
   *
   * #### Example
   * ```typescript
   * const assetID = 163650;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const assetAssets = await indexerClient
   *        .lookupAccountCreatedAssets(address)
   *        .assetID(assetID)
   *        .do();
   * ```
   * @param index - the assetID
   * @category query
   */
  assetID(index) {
    this.query["asset-id"] = index;
    return this;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), AssetsResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/indexer/lookupAccountAppLocalStates.js
var LookupAccountAppLocalStates = class extends JSONRequest {
  /**
   * Returns application local state about the given account.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountAppLocalStates = await indexerClient.lookupAccountAppLocalStates(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-idapps-local-state)
   * @param account - The address of the account to look up.
   * @category GET
   */
  constructor(c2, account) {
    super(c2);
    this.account = account.toString();
  }
  /**
   * @returns `/v2/accounts/${account}/apps-local-state`
   */
  path() {
    return `/v2/accounts/${this.account}/apps-local-state`;
  }
  /**
   * Add a limit for filter.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const maxResults = 20;
   * const accountAssets = await indexerClient
   *        .lookupAccountAppLocalStates(address)
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit - maximum number of results to return.
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Specify round to filter with.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const targetBlock = 18309917;
   * const accountAssets = await indexerClient
   *        .lookupAccountAppLocalStates(address)
   *        .round(targetBlock)
   *        .do();
   * ```
   * @param round
   * @category query
   */
  round(round) {
    this.query.round = round;
    return this;
  }
  /**
   * Specify the next page of results.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const maxResults = 20;
   *
   * const accountAssetsPage1 = await indexerClient
   *        .lookupAccountAppLocalStates(address)
   *        .limit(maxResults)
   *        .do();
   *
   * const accountAssetsPage2 = await indexerClient
   *        .lookupAccountAppLocalStates(address)
   *        .limit(maxResults)
   *        .next(accountAssetsPage1["next-token"])
   *        .do();
   * ```
   * @param nextToken - provided by the previous results.
   */
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  /**
   * Include all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountAssets = await indexerClient
   *        .lookupAccountAppLocalStates(address)
   *        .includeAll(false)
   *        .do();
   * ```
   * @param value
   * @category query
   */
  includeAll(value = true) {
    this.query["include-all"] = value;
    return this;
  }
  /**
   * Specify an applicationID to search for.
   *
   * #### Example
   * ```typescript
   * const applicationID = 163650;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountApplications = await indexerClient
   *        .lookupAccountAppLocalStates(address)
   *        .applicationID(applicationID)
   *        .do();
   * ```
   * @param index - the applicationID
   * @category query
   */
  applicationID(index) {
    this.query["application-id"] = index;
    return this;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), ApplicationLocalStatesResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/indexer/lookupAccountCreatedApplications.js
var LookupAccountCreatedApplications = class extends JSONRequest {
  /**
   * Returns application information created by the given account.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountCreatedApps = await indexerClient.lookupAccountCreatedApplications(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-idcreated-applications)
   * @param account - The address of the account to look up.
   * @category GET
   */
  constructor(c2, account) {
    super(c2);
    this.account = account.toString();
  }
  /**
   * @returns `/v2/accounts/${account}/created-applications`
   */
  path() {
    return `/v2/accounts/${this.account}/created-applications`;
  }
  /**
   * Add a limit for filter.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const maxResults = 20;
   * const accountAssets = await indexerClient
   *        .lookupAccountCreatedApplications(address)
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit - maximum number of results to return.
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Specify round to filter with.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const targetBlock = 18309917;
   * const accountAssets = await indexerClient
   *        .lookupAccountCreatedApplications(address)
   *        .round(targetBlock)
   *        .do();
   * ```
   * @param round
   * @category query
   */
  round(round) {
    this.query.round = round;
    return this;
  }
  /**
   * Specify the next page of results.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const maxResults = 20;
   *
   * const accountAssetsPage1 = await indexerClient
   *        .lookupAccountCreatedApplications(address)
   *        .limit(maxResults)
   *        .do();
   *
   * const accountAssetsPage2 = await indexerClient
   *        .lookupAccountCreatedApplications(address)
   *        .limit(maxResults)
   *        .next(accountAssetsPage1["next-token"])
   *        .do();
   * ```
   * @param nextToken - provided by the previous results.
   * @category query
   */
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  /**
   * Include all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountAssets = await indexerClient
   *        .lookupAccountCreatedApplications(address)
   *        .includeAll(false)
   *        .do();
   * ```
   * @param value
   * @category query
   */
  includeAll(value = true) {
    this.query["include-all"] = value;
    return this;
  }
  /**
   * Specify an applicationID to search for.
   *
   * #### Example
   * ```typescript
   * const applicationID = 163650;
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountApplications = await indexerClient
   *        .lookupAccountAppLocalStates(address)
   *        .applicationID(applicationID)
   *        .do();
   * ```
   * @param index - the applicationID
   * @category query
   */
  applicationID(index) {
    this.query["application-id"] = index;
    return this;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), ApplicationsResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/indexer/lookupAssetByID.js
var LookupAssetByID = class extends JSONRequest {
  /**
   * Returns asset information of the queried asset.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const assetInfo = await indexerClient.lookupAssetByID(assetId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2assetsasset-id)
   * @param index - The asset ID to look up.
   */
  constructor(c2, index) {
    super(c2);
    this.index = BigInt(index);
  }
  /**
   * @returns `/v2/assets/${index}`
   */
  path() {
    return `/v2/assets/${this.index}`;
  }
  /**
   * Includes all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates
   *
   * #### Example 1
   * ```typescript
   * const assetId = 163650;
   * const assetInfo = await indexerClient
   *        .lookupAssetByID(assetId)
   *        .includeAll(false)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const assetId = 163650;
   * const assetInfo = await indexerClient
   *        .lookupAssetByID(assetId)
   *        .includeAll()
   *        .do();
   * ```
   *
   * @param value - default true when called without passing a value
   * @category query
   */
  includeAll(value = true) {
    this.query["include-all"] = value;
    return this;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), AssetResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/indexer/lookupApplications.js
var LookupApplications = class extends JSONRequest {
  /**
   * Returns information about the passed application.
   *
   * #### Example
   * ```typescript
   * const appId = 60553466;
   * const appInfo = await indexerClient.lookupApplications(appId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2applicationsapplication-id)
   * @param index - The ID of the application to look up.
   * @category GET
   */
  constructor(c2, index) {
    super(c2);
    this.index = BigInt(index);
  }
  /**
   * @returns `/v2/applications/${index}`
   */
  path() {
    return `/v2/applications/${this.index}`;
  }
  /**
   * Includes all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates
   *
   * #### Example 1
   * ```typescript
   * const appId = 60553466;
   * const appInfo = await indexerClient
   *        .lookupApplications(appId)
   *        .includeAll(false)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const appId = 60553466;
   * const appInfo = await indexerClient
   *        .lookupApplications(appId)
   *        .includeAll()
   *        .do();
   * ```
   *
   * @param value - default true when called without passing a value
   * @category query
   */
  includeAll(value = true) {
    this.query["include-all"] = value;
    return this;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), ApplicationResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/indexer/lookupApplicationLogs.js
var LookupApplicationLogs = class extends JSONRequest {
  /**
   * Returns log messages generated by the passed in application.
   *
   * #### Example
   * ```typescript
   * const appId = 60553466;
   * const appLogs = await indexerClient.lookupApplicationLogs(appId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2applicationsapplication-idlogs)
   * @param appID - The ID of the application which generated the logs.
   * @category GET
   */
  constructor(c2, appID) {
    super(c2);
    this.appID = BigInt(appID);
  }
  /**
   * @returns `/v2/applications/${appID}/logs`
   */
  path() {
    return `/v2/applications/${this.appID}/logs`;
  }
  /**
   * Limit results for pagination.
   *
   * #### Example
   * ```typescript
   * const maxResults = 20;
   * const appLogs = await indexerClient
   *        .lookupApplicationLogs(appId)
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit - maximum number of results to return.
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Include results at or after the specified min-round.
   *
   * #### Example
   * ```typescript
   * const minRound = 18309917;
   * const appLogs = await indexerClient
   *        .lookupApplicationLogs(appId)
   *        .minRound(minRound)
   *        .do();
   * ```
   *
   * @param round
   * @category query
   */
  minRound(round) {
    this.query["min-round"] = round;
    return this;
  }
  /**
   * Include results at or before the specified max-round.
   *
   * #### Example
   * ```typescript
   * const maxRound = 18309917;
   * const appLogs = await indexerClient
   *        .lookupApplicationLogs(appId)
   *        .maxRound(maxRound)
   *        .do();
   * ```
   *
   * @param round
   * @category query
   */
  maxRound(round) {
    this.query["max-round"] = round;
    return this;
  }
  /**
   * The next page of results.
   *
   * #### Example
   * ```typescript
   * const maxResults = 25;
   *
   * const appLogsPage1 = await indexerClient
   *        .lookupApplicationLogs(appId)
   *        .limit(maxResults)
   *        .do();
   *
   * const appLogsPage2 = await indexerClient
   *        .lookupApplicationLogs(appId)
   *        .limit(maxResults)
   *        .nextToken(appLogsPage1["next-token"])
   *        .do();
   * ```
   *
   * @param nextToken - provided by the previous results.
   * @category query
   */
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  /**
   * Only include transactions with this sender address.
   *
   * #### Example
   * ```typescript
   * const sender = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const appLogs = await indexerClient
   *        .lookupApplicationLogs(appId)
   *        .sender(sender)
   *        .do();
   * ```
   *
   * @param senderAddress
   * @category query
   */
  sender(senderAddress) {
    this.query["sender-address"] = senderAddress;
    return this;
  }
  /**
   * Lookup the specific transaction by ID.
   *
   * #### Example
   * ```typescript
   * const txId = "MEUOC4RQJB23CQZRFRKYEI6WBO73VTTPST5A7B3S5OKBUY6LFUDA";
   * const appLogs = await indexerClient
   *        .lookupApplicationLogs(appId)
   *        .txid(txId)
   *        .do();
   * ```
   *
   * @param txid
   * @category query
   */
  txid(txid) {
    this.query.txid = txid;
    return this;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), ApplicationLogsResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/indexer/lookupApplicationBoxByIDandName.js
var LookupApplicationBoxByIDandName = class extends JSONRequest {
  /**
   * Returns information about indexed application boxes.
   *
   * #### Example
   * ```typescript
   * const boxName = Buffer.from("foo");
   * const boxResponse = await indexerClient
   *        .LookupApplicationBoxByIDandName(1234, boxName)
   *        .do();
   * const boxValue = boxResponse.value;
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2applicationsapplication-idbox)
   * @oaram index - application index.
   * @category GET
   */
  constructor(c2, index, boxName) {
    super(c2);
    this.index = BigInt(index);
    const encodedName = bytesToBase64(boxName);
    this.query.name = encodeURI(`b64:${encodedName}`);
  }
  /**
   * @returns `/v2/applications/${index}/box`
   */
  path() {
    return `/v2/applications/${this.index}/box`;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), Box2);
  }
};

// node_modules/algosdk/dist/esm/client/v2/indexer/searchAccounts.js
var SearchAccounts = class extends JSONRequest {
  /**
   * @returns `/v2/accounts`
   */
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/v2/accounts";
  }
  /**
   * Filtered results should have an amount greater than this value, as int, representing microAlgos, unless an asset-id is provided, in which case units are in the asset's units.
   *
   * #### Example 1
   * ```typescript
   * const minBalance = 300000;
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .currencyGreaterThan(minBalance - 1)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const assetID = 163650;
   * const minBalance = 300000;
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .assetID(assetID)
   *        .currencyGreaterThan(minBalance - 1)
   *        .do();
   * ```
   * @remarks
   * If you are looking for accounts with the currency amount greater than 0, simply construct the query without `currencyGreaterThan` because it doesn't accept `-1`, and passing the `0` `currency-greater-than` value would exclude accounts with a 0 amount.
   *
   * @param greater
   * @category query
   */
  currencyGreaterThan(greater) {
    this.query["currency-greater-than"] = greater.toString();
    return this;
  }
  /**
   * Filtered results should have an amount less than this value, as int, representing microAlgos, unless an asset-id is provided, in which case units are in the asset's units.
   *
   * #### Example 1
   * ```typescript
   * const maxBalance = 500000;
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .currencyLessThan(maxBalance + 1)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const assetID = 163650;
   * const maxBalance = 500000;
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .assetID(assetID)
   *        .currencyLessThan(maxBalance + 1)
   *        .do();
   * ```
   *
   * @param lesser
   * @category query
   */
  currencyLessThan(lesser) {
    this.query["currency-less-than"] = lesser;
    return this;
  }
  /**
   * Maximum number of results to return.
   *
   * #### Example
   * ```typescript
   * const maxResults = 25;
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Asset ID to filter with.
   *
   * #### Example
   * ```typescript
   * const assetID = 163650;
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .assetID(assetID)
   *        .do();
   * ```
   *
   * @param id
   * @category query
   */
  assetID(id) {
    this.query["asset-id"] = id;
    return this;
  }
  /**
   * The next page of results.
   *
   * #### Example
   * ```typescript
   * const maxResults = 25;
   *
   * const accountsPage1 = await indexerClient
   *        .searchAccounts()
   *        .limit(maxResults)
   *        .do();
   *
   * const accountsPage2 = await indexerClient
   *        .searchAccounts()
   *        .limit(maxResults)
   *        .nextToken(accountsPage1["next-token"])
   *        .do();
   * ```
   *
   * @param nextToken - provided by the previous results
   * @category query
   */
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  /**
   * Include results for the specified round.
   *
   * #### Example
   * ```typescript
   * const targetBlock = 18309917;
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .round(targetBlock)
   *        .do();
   * ```
   * @remarks For performance reasons, this parameter may be disabled on some configurations.
   * @param round
   * @category query
   */
  round(round) {
    this.query.round = round;
    return this;
  }
  /**
   * Include accounts that use this spending key.
   *
   * #### Example
   * ```typescript
   * const authAddr = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .authAddr(authAddr)
   *        .do();
   * ```
   *
   * @param authAddr
   */
  authAddr(authAddr) {
    this.query["auth-addr"] = authAddr.toString();
    return this;
  }
  /**
   * Filter for this application.
   *
   * #### Example
   * ```typescript
   * const appId = 60553466;
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .applicationID(appId)
   *        .do();
   * ```
   *
   * @param applicationID
   * @category query
   */
  applicationID(applicationID) {
    this.query["application-id"] = applicationID;
    return this;
  }
  /**
   * Includes all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates
   *
   * #### Example 1
   * ```typescript
   * const assetId = 163650;
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .includeAll(false)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const assetId = 163650;
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .includeAll()
   *        .do();
   * ```
   *
   * @param value - default true when called without passing a value
   * @category query
   */
  includeAll(value = true) {
    this.query["include-all"] = value;
    return this;
  }
  /**
   * Exclude additional items such as asset holdings, application local data stored for this account, asset parameters created by this account, and application parameters created by this account.
   *
   * #### Example 1
   * ```typescript
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .exclude("all")
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const accounts = await indexerClient
   *        .searchAccounts()
   *        .exclude("assets,created-assets")
   *        .do();
   * ```
   * @remarks By default, it behaves as exclude=none
   * @param exclude - Array of `all`, `assets`, `created-assets`, `apps-local-state`, `created-apps`, `none`
   * @category query
   */
  exclude(exclude) {
    this.query.exclude = exclude;
    return this;
  }
  /**
   * If true, only online accounts will be returned in the response.
   *
   * #### Example
   * ```typescript
   * const onlineOnly = true;
   * const accounts = await indexerClient
   *        .searchAccounts
   *        .onlineOnly(onlineOnly)
   *        .do();
   * ```
   *
   * @param onlineOnly - if true, only online accounts will be returned in the response
   * @category query
   */
  onlineOnly(onlineOnly) {
    this.query["online-only"] = onlineOnly;
    return this;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), AccountsResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/indexer/searchForBlockHeaders.js
var SearchForBlockHeaders = class extends JSONRequest {
  /**
   * @returns `/v2/block-headers`
   */
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/v2/block-headers";
  }
  /**
   * Accounts marked as absent in the block header's participation updates.
   *
   * #### Example
   * ```typescript
   * const address1 = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const address2 = "4H5UNRBJ2Q6JENAXQ6HNTGKLKINP4J4VTQBEPK5F3I6RDICMZBPGNH6KD4";
   * const bhs = await indexerClient
   *        .searchForBlockHeaders()
   *        .absent([address1,address2])
   *        .do();
   * ```
   *
   * @param absent - a comma separated list of addresses
   * @category query
   */
  absent(absent) {
    this.query.absent = absent;
    return this;
  }
  /**
   * Include results after the given time.
   *
   * #### Example
   * ```typescript
   * const afterTime = "2022-10-21T00:00:11.55Z";
   * const bhs = await indexerClient
   *        .searchForBlockHeaders()
   *        .afterTime(afterTime)
   *        .do();
   * ```
   *
   * @param after - rfc3339 string or Date object
   * @category query
   */
  afterTime(after) {
    this.query["after-time"] = after instanceof Date ? after.toISOString() : after;
    return this;
  }
  /**
   * Include results before the given time.
   *
   * #### Example
   * ```typescript
   * const beforeTime = "2022-02-02T20:20:22.02Z";
   * const bhs = await indexerClient
   *        .searchForBlockHeaders()
   *        .beforeTime(beforeTime)
   *        .do();
   * ```
   *
   * @param before - rfc3339 string or Date object
   * @category query
   */
  beforeTime(before) {
    this.query["before-time"] = before instanceof Date ? before.toISOString() : before;
    return this;
  }
  /**
   * Accounts marked as expired in the block header's participation updates.
   *
   * #### Example
   * ```typescript
   * const address1 = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const address2 = "4H5UNRBJ2Q6JENAXQ6HNTGKLKINP4J4VTQBEPK5F3I6RDICMZBPGNH6KD4";
   * const bhs = await indexerClient
   *        .searchForBlockHeaders()
   *        .expired([address1,address2])
   *        .do();
   * ```
   *
   * @param expired - - a comma separated list of addresses
   * @category query
   */
  expired(expired) {
    this.query.expired = expired;
    return this;
  }
  /**
   * Maximum number of results to return.
   *
   * #### Example
   * ```typescript
   * const maxResults = 25;
   * const bhs = await indexerClient
   *        .searchForBlockHeaders()
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Include results at or before the specified max-round.
   *
   * #### Example
   * ```typescript
   * const maxRound = 18309917;
   * const bhs = await indexerClient
   *        .searchForBlockHeaders()
   *        .maxRound(maxRound)
   *        .do();
   * ```
   *
   * @param round
   * @category query
   */
  maxRound(round) {
    this.query["max-round"] = round;
    return this;
  }
  /**
   * Include results at or after the specified min-round.
   *
   * #### Example
   * ```typescript
   * const minRound = 18309917;
   * const bhs = await indexerClient
   *        .searchForBlockHeaders()
   *        .minRound(minRound)
   *        .do();
   * ```
   *
   * @param round
   * @category query
   */
  minRound(round) {
    this.query["min-round"] = round;
    return this;
  }
  /**
   * The next page of results.
   *
   * #### Example
   * ```typescript
   * const maxResults = 25;
   *
   * const bh1 = await indexerClient
   *        .searchForBlockHeaders()
   *        .limit(maxResults)
   *        .do();
   *
   * const bh2 = await indexerClient
   *        .searchForBlockHeaders()
   *        .limit(maxResults)
   *        .nextToken(bh1["next-token"])
   *        .do();
   * ```
   *
   * @param nextToken - provided by the previous results
   * @category query
   */
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  /**
   * Accounts marked as proposer in the block header's participation updates.
   *
   * #### Example
   * ```typescript
   * const address1 = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const address2 = "4H5UNRBJ2Q6JENAXQ6HNTGKLKINP4J4VTQBEPK5F3I6RDICMZBPGNH6KD4";
   * const bhs = await indexerClient
   *        .searchForBlockHeaders()
   *        .proposers([address1,address2])
   *        .do();
   * ```
   *
   * @param proposers - a comma separated list of addresses
   * @category query
   */
  proposers(proposers) {
    this.query.proposers = proposers;
    return this;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), BlockHeadersResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/indexer/searchForTransactions.js
var SearchForTransactions = class extends JSONRequest {
  /**
   * @returns `/v2/transactions`
   */
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/v2/transactions";
  }
  /**
   * Specifies a prefix which must be contained in the note field.
   *
   * #### Example
   * ```typescript
   * const notePrefixBase64Encoded = "Y3JlYXRl";
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .notePrefix(notePrefixBase64Encoded)
   *        .do();
   * ```
   *
   * @param prefix - base64 string or uint8array
   * @category query
   */
  notePrefix(prefix) {
    this.query["note-prefix"] = base64StringFunnel(prefix);
    return this;
  }
  /**
   * Type of transaction to filter with.
   *
   * #### Example
   * ```typescript
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .txType("keyreg")
   *        .do();
   * ```
   *
   * @param type - one of `pay`, `keyreg`, `acfg`, `axfer`, `afrz`, `appl`, `stpf`
   * @category query
   */
  txType(type) {
    this.query["tx-type"] = type;
    return this;
  }
  /**
   * Type of signature to filter with.
   * - sig: Standard
   * - msig: MultiSig
   * - lsig: LogicSig
   *
   * #### Example
   * ```typescript
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .sigType("sig")
   *        .do();
   * ```
   *
   * @param type - one of `sig`, `msig`, `lsig`
   * @category query
   */
  sigType(type) {
    this.query["sig-type"] = type;
    return this;
  }
  /**
   * Lookup the specific transaction by ID.
   *
   * #### Example
   * ```typescript
   * const txId = "MEUOC4RQJB23CQZRFRKYEI6WBO73VTTPST5A7B3S5OKBUY6LFUDA";
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .txid(txId)
   *        .do();
   * ```
   * @remarks Alternatively, use `indexerClient.lookupTransactionByID(txnId).do()`
   * @param txid
   * @category query
   */
  txid(txid) {
    this.query.txid = txid;
    return this;
  }
  /**
   * Lookup transactions by group ID.
   *
   * #### Example
   * ```typescript
   * const groupIdBase64Encoded = "A62qVigWtWo0laUzcE1iZY8+KXWzK1vSkgwN/eKgvjc=";
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .groupid(groupIdBase64Encoded)
   *        .do();
   * ```
   *
   * @param groupid - base64 string or uint8array
   * @category query
   */
  groupid(groupid) {
    this.query["group-id"] = base64StringFunnel(groupid);
    return this;
  }
  /**
   * Include results for the specified round.
   *
   * #### Example
   * ```typescript
   * const targetBlock = 18309917;
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .round(targetBlock)
   *        .do();
   * ```
   * @remarks Alternatively, use `indexerClient.lookupBlock(targetBlock).do()`
   * @param round
   * @category query
   */
  round(round) {
    this.query.round = round;
    return this;
  }
  /**
   * Include results at or after the specified min-round.
   *
   * #### Example
   * ```typescript
   * const minRound = 18309917;
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .minRound(minRound)
   *        .do();
   * ```
   *
   * @param round
   * @category query
   */
  minRound(round) {
    this.query["min-round"] = round;
    return this;
  }
  /**
   * Include results at or before the specified max-round.
   *
   * #### Example
   * ```typescript
   * const maxRound = 18309917;
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .maxRound(maxRound)
   *        .do();
   * ```
   *
   * @param round
   * @category query
   */
  maxRound(round) {
    this.query["max-round"] = round;
    return this;
  }
  /**
   * Asset ID to filter with.
   *
   * #### Example
   * ```typescript
   * const assetID = 163650;
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .assetID(assetID)
   *        .do();
   * ```
   * @remarks Alternatively, use `indexerClient.lookupAssetTransactions(assetId).do()`
   * @param id
   * @category query
   */
  assetID(id) {
    this.query["asset-id"] = id;
    return this;
  }
  /**
   * Maximum number of results to return.
   *
   * #### Example
   * ```typescript
   * const maxResults = 25;
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Include results before the given time.
   *
   * #### Example
   * ```typescript
   * const beforeTime = "2022-02-02T20:20:22.02Z";
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .beforeTime(beforeTime)
   *        .do();
   * ```
   *
   * @param before - rfc3339 string or Date object
   * @category query
   */
  beforeTime(before) {
    this.query["before-time"] = before instanceof Date ? before.toISOString() : before;
    return this;
  }
  /**
   * Include results after the given time.
   *
   * #### Example
   * ```typescript
   * const afterTime = "2022-10-21T00:00:11.55Z";
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .afterTime(afterTime)
   *        .do();
   * ```
   *
   * @param after - rfc3339 string or Date object
   * @category query
   */
  afterTime(after) {
    this.query["after-time"] = after instanceof Date ? after.toISOString() : after;
    return this;
  }
  /**
   * Combined with address, defines what address to filter on, as string.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const role = "freeze-target";
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .address(address)
   *        .addressRole(role)
   *        .do();
   * ```
   *
   * @param role - one of `sender`, `receiver`, `freeze-target`
   * @category query
   */
  addressRole(role) {
    this.query["address-role"] = role;
    return this;
  }
  /**
   * Only include transactions with this address in one of the transaction fields.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .address(address)
   *        .do();
   * ```
   * @remarks Alternatively, use `indexerClient.lookupAccountTransactions(address).do()`
   * @param address
   * @category query
   */
  address(address) {
    this.query.address = address.toString();
    return this;
  }
  /**
   * Whether or not to consider the `close-to` field as a receiver when filtering transactions, as bool. Set to `true` to ignore `close-to`.
   *
   * #### Example
   * ```typescript
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .excludeCloseTo(true)
   *        .do();
   * ```
   *
   * @param exclude
   * @category query
   */
  excludeCloseTo(exclude) {
    this.query["exclude-close-to"] = exclude;
    return this;
  }
  /**
   * The next page of results.
   *
   * #### Example
   * ```typescript
   * const maxResults = 25;
   *
   * const txnsPage1 = await indexerClient
   *        .searchForTransactions()
   *        .limit(maxResults)
   *        .do();
   *
   * const txnsPage2 = await indexerClient
   *        .searchForTransactions()
   *        .limit(maxResults)
   *        .nextToken(txnsPage1["next-token"])
   *        .do();
   * ```
   *
   * @param nextToken - provided by the previous results
   * @category query
   */
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  /**
   * Whether or not to include rekeying transactions.
   *
   * #### Example
   * ```typescript
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .rekeyTo(false)
   *        .do();
   * ```
   *
   * @param rekeyTo
   * @category query
   */
  rekeyTo(rekeyTo) {
    this.query["rekey-to"] = rekeyTo;
    return this;
  }
  /**
   * Filter for this application.
   *
   * #### Example
   * ```typescript
   * const appId = 60553466;
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .applicationID(appId)
   *        .do();
   * ```
   *
   * @param applicationID
   * @category query
   */
  applicationID(applicationID) {
    this.query["application-id"] = applicationID;
    return this;
  }
  /**
   * Filtered results should have an amount greater than this value, as int, representing microAlgos, unless an asset-id is provided, in which case units are in the asset's units.
   *
   * #### Example 1
   * ```typescript
   * const minBalance = 300000;
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .currencyGreaterThan(minBalance - 1)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const assetID = 163650;
   * const minBalance = 300000;
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .assetID(assetID)
   *        .currencyGreaterThan(minBalance - 1)
   *        .do();
   * ```
   *
   * @param greater
   * @category query
   */
  currencyGreaterThan(greater) {
    this.query["currency-greater-than"] = greater.toString();
    return this;
  }
  /**
   * Filtered results should have an amount less than this value, as int, representing microAlgos, unless an asset-id is provided, in which case units are in the asset's units.
   *
   * #### Example 1
   * ```typescript
   * const maxBalance = 500000;
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .currencyLessThan(maxBalance + 1)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const assetID = 163650;
   * const maxBalance = 500000;
   * const txns = await indexerClient
   *        .searchForTransactions()
   *        .assetID(assetID)
   *        .currencyLessThan(maxBalance + 1)
   *        .do();
   * ```
   *
   * @param lesser
   * @category query
   */
  currencyLessThan(lesser) {
    this.query["currency-less-than"] = lesser;
    return this;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), TransactionsResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/indexer/searchForAssets.js
var SearchForAssets = class extends JSONRequest {
  /**
   * @returns `/v2/assets`
   */
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/v2/assets";
  }
  /**
   * Limit results for pagination.
   *
   * #### Example
   * ```typescript
   * const maxResults = 20;
   * const assets = await indexerClient
   *        .searchForAssets()
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit - maximum number of results to return.
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Filter just assets with the given creator address.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const assets = await indexerClient
   *        .searchForAssets()
   *        .creator(address)
   *        .do();
   * ```
   *
   * @param creator
   * @category query
   */
  creator(creator) {
    this.query.creator = creator.toString();
    return this;
  }
  /**
   * Filter just assets with the given name.
   *
   * #### Example
   * ```typescript
   * const name = "Test Token";
   * const assets = await indexerClient
   *        .searchForAssets()
   *        .name(name)
   *        .do();
   * ```
   *
   * @param name
   * @category query
   */
  name(name) {
    this.query.name = name;
    return this;
  }
  /**
   * Filter just assets with the given unit.
   *
   * #### Example
   * ```typescript
   * const unit = "test";
   * const assets = await indexerClient
   *        .searchForAssets()
   *        .unit(unit)
   *        .do();
   * ```
   *
   * @param unit
   * @category query
   */
  unit(unit) {
    this.query.unit = unit;
    return this;
  }
  /**
   * Asset ID for filter, as int.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const assets = await indexerClient
   *        .searchForAssets()
   *        .index(assetId)
   *        .do();
   * ```
   * @remarks Alternatively, use `indexerClient.lookupAssetByID(assetId).do();`
   * @param index
   * @category query
   */
  index(index) {
    this.query["asset-id"] = index;
    return this;
  }
  /**
   * Specify the next page of results.
   *
   * #### Example
   * ```typescript
   * const maxResults = 20;
   *
   * const assetsPage1 = await indexerClient
   *        .searchForAssets()
   *        .limit(maxResults)
   *        .do();
   *
   * const assetsPage2 = await indexerClient
   *        .searchForAssets()
   *        .limit(maxResults)
   *        .nextToken(assetsPage1["next-token"])
   *        .do();
   * ```
   * @param nextToken - provided by the previous results.
   * @category query
   */
  nextToken(nextToken) {
    this.query.next = nextToken;
    return this;
  }
  /**
   * Includes all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates
   *
   * #### Example 1
   * ```typescript
   * const assets = await indexerClient
   *        .searchForAssets()
   *        .includeAll(false)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const assets = await indexerClient
   *        .searchForAssets()
   *        .includeAll()
   *        .do();
   * ```
   *
   * @param value - default true when called without passing a value
   * @category query
   */
  includeAll(value = true) {
    this.query["include-all"] = value;
    return this;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), AssetsResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/indexer/searchForApplications.js
var SearchForApplications = class extends JSONRequest {
  /**
   * @returns `/v2/applications`
   */
  // eslint-disable-next-line class-methods-use-this
  path() {
    return "/v2/applications";
  }
  /**
   * Application ID for filter, as int
   *
   * #### Example
   * ```typescript
   * const appId = 60553466;
   * const apps = await indexerClient
   *        .searchForApplications()
   *        .index(appId)
   *        .do();
   * ```
   * @remarks Alternatively, use `indexerClient.lookupApplications(appId).do()`
   * @param index
   * @category query
   */
  index(index) {
    this.query["application-id"] = index;
    return this;
  }
  /**
   * Creator for filter, as string
   *
   * #### Example
   * ```typescript
   * const creator = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const apps = await indexerClient
   *        .searchForApplications()
   *        .creator(creator)
   *        .do();
   * ```
   * @param creator
   * @category query
   */
  creator(creator) {
    this.query.creator = creator.toString();
    return this;
  }
  /**
   * Specify the next page of results.
   *
   * #### Example
   * ```typescript
   * const maxResults = 20;
   *
   * const appsPage1 = await indexerClient
   *        .searchForApplications()
   *        .limit(maxResults)
   *        .do();
   *
   * const appsPage2 = await indexerClient
   *        .searchForApplications()
   *        .limit(maxResults)
   *        .nextToken(appsPage1["next-token"])
   *        .do();
   * ```
   * @param nextToken - provided by the previous results.
   * @category query
   */
  nextToken(next) {
    this.query.next = next;
    return this;
  }
  /**
   * Limit results for pagination.
   *
   * #### Example
   * ```typescript
   * const maxResults = 20;
   * const apps = await indexerClient
   *        .searchForApplications()
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit - maximum number of results to return.
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  /**
   * Includes all items including closed accounts, deleted applications, destroyed assets, opted-out asset holdings, and closed-out application localstates
   *
   * #### Example 1
   * ```typescript
   * const apps = await indexerClient
   *        .searchForApplications()
   *        .includeAll(false)
   *        .do();
   * ```
   *
   * #### Example 2
   * ```typescript
   * const apps = await indexerClient
   *        .searchForApplications()
   *        .includeAll()
   *        .do();
   * ```
   *
   * @param value - default true when called without passing a value
   * @category query
   */
  includeAll(value = true) {
    this.query["include-all"] = value;
    return this;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), ApplicationsResponse);
  }
};

// node_modules/algosdk/dist/esm/client/v2/indexer/searchForApplicationBoxes.js
var SearchForApplicationBoxes = class extends JSONRequest {
  /**
   * Returns information about indexed application boxes.
   *
   * #### Example
   * ```typescript
   * const maxResults = 20;
   * const appID = 1234;
   *
   * const responsePage1 = await indexerClient
   *        .searchForApplicationBoxes(appID)
   *        .limit(maxResults)
   *        .do();
   * const boxNamesPage1 = responsePage1.boxes.map(box => box.name);
   *
   * const responsePage2 = await indexerClient
   *        .searchForApplicationBoxes(appID)
   *        .limit(maxResults)
   *        .nextToken(responsePage1.nextToken)
   *        .do();
   * const boxNamesPage2 = responsePage2.boxes.map(box => box.name);
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2applicationsapplication-idboxes)
   * @oaram index - application index.
   * @category GET
   */
  constructor(c2, index) {
    super(c2);
    this.index = BigInt(index);
  }
  /**
   * @returns `/v2/applications/${index}/boxes`
   */
  path() {
    return `/v2/applications/${this.index}/boxes`;
  }
  /**
   * Specify the next page of results.
   *
   * #### Example
   * ```typescript
   * const maxResults = 20;
   * const appID = 1234;
   *
   * const responsePage1 = await indexerClient
   *        .searchForApplicationBoxes(appID)
   *        .limit(maxResults)
   *        .do();
   * const boxNamesPage1 = responsePage1.boxes.map(box => box.name);
   *
   * const responsePage2 = await indexerClient
   *        .searchForApplicationBoxes(appID)
   *        .limit(maxResults)
   *        .nextToken(responsePage1.nextToken)
   *        .do();
   * const boxNamesPage2 = responsePage2.boxes.map(box => box.name);
   * ```
   * @param nextToken - provided by the previous results.
   * @category query
   */
  nextToken(next) {
    this.query.next = next;
    return this;
  }
  /**
   * Limit results for pagination.
   *
   * #### Example
   * ```typescript
   * const maxResults = 20;
   * const boxesResponse = await indexerClient
   *        .searchForApplicationBoxes(1234)
   *        .limit(maxResults)
   *        .do();
   * ```
   *
   * @param limit - maximum number of results to return.
   * @category query
   */
  limit(limit) {
    this.query.limit = limit;
    return this;
  }
  // eslint-disable-next-line class-methods-use-this
  prepare(response) {
    return decodeJSON(response.getJSONText(), BoxesResponse2);
  }
};

// node_modules/algosdk/dist/esm/client/v2/indexer/indexer.js
var IndexerClient = class extends ServiceClient {
  /**
   * Create an IndexerClient from
   * * either a token, baseServer, port, and optional headers
   * * or a base client server for interoperability with external dApp wallets
   *
   * #### Example
   * ```typescript
   * const token  = "";
   * const server = "http://localhost";
   * const port   = 8980;
   * const indexerClient = new algosdk.Indexer(token, server, port);
   * ```
   * @remarks
   * The above configuration is for a sandbox private network.
   * For applications on production, you are encouraged to run your own node with indexer, or use an Algorand REST API provider with a dedicated API key.
   *
   * @param tokenOrBaseClient - The API token for the Indexer API
   * @param baseServer - REST endpoint
   * @param port - Port number if specifically configured by the server
   * @param headers - Optional headers
   */
  constructor(tokenOrBaseClient, baseServer = "http://127.0.0.1", port = 8080, headers = {}) {
    super("X-Indexer-API-Token", tokenOrBaseClient, baseServer, port, headers);
  }
  /**
   * Returns the health object for the service.
   * Returns 200 if healthy.
   *
   * #### Example
   * ```typescript
   * const health = await indexerClient.makeHealthCheck().do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-health)
   * @category GET
   */
  makeHealthCheck() {
    return new MakeHealthCheck(this.c);
  }
  /**
   * Returns the list of accounts who hold the given asset and their balance.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const assetBalances = await indexerClient.lookupAssetBalances(assetId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2assetsasset-idbalances)
   * @param index - The asset ID to look up.
   * @category GET
   */
  lookupAssetBalances(index) {
    return new LookupAssetBalances(this.c, index);
  }
  /**
   * Returns transactions relating to the given asset.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const assetTxns = await indexerClient.lookupAssetTransactions(assetId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2assetsasset-idtransactions)
   * @param index - The asset ID to look up.
   * @category GET
   */
  lookupAssetTransactions(index) {
    return new LookupAssetTransactions(this.c, index);
  }
  /**
   * Returns transactions relating to the given account.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountTxns = await indexerClient.lookupAccountTransactions(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-idtransactions)
   * @param account - The address of the account.
   * @category GET
   */
  lookupAccountTransactions(account) {
    return new LookupAccountTransactions(this.c, account);
  }
  /**
   * Returns the block for the passed round.
   *
   * #### Example
   * ```typescript
   * const targetBlock = 18309917;
   * const blockInfo = await indexerClient.lookupBlock(targetBlock).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2blocksround-number)
   * @param round - The number of the round to look up.
   * @category GET
   */
  lookupBlock(round) {
    return new LookupBlock(this.c, round);
  }
  /**
   * Returns information about the given transaction.
   *
   * #### Example
   * ```typescript
   * const txnId = "MEUOC4RQJB23CQZRFRKYEI6WBO73VTTPST5A7B3S5OKBUY6LFUDA";
   * const txnInfo = await indexerClient.lookupTransactionByID(txnId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2transactionstxid)
   * @param txID - The ID of the transaction to look up.
   * @category GET
   */
  lookupTransactionByID(txID) {
    return new LookupTransactionByID(this.c, txID);
  }
  /**
   * Returns information about the given account.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountInfo = await indexerClient.lookupAccountByID(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-id)
   * @param account - The address of the account to look up.
   * @category GET
   */
  lookupAccountByID(account) {
    return new LookupAccountByID(this.c, account);
  }
  /**
   * Returns asset about the given account.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountAssets = await indexerClient.lookupAccountAssets(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-idassets)
   * @param account - The address of the account to look up.
   * @category GET
   */
  lookupAccountAssets(account) {
    return new LookupAccountAssets(this.c, account);
  }
  /**
   * Returns asset information created by the given account.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountCreatedAssets = await indexerClient.lookupAccountCreatedAssets(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-idcreated-assets)
   * @param account - The address of the account to look up.
   * @category GET
   */
  lookupAccountCreatedAssets(account) {
    return new LookupAccountCreatedAssets(this.c, account);
  }
  /**
   * Returns application local state about the given account.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountAppLocalStates = await indexerClient.lookupAccountAppLocalStates(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-idapps-local-state)
   * @param account - The address of the account to look up.
   * @category GET
   */
  lookupAccountAppLocalStates(account) {
    return new LookupAccountAppLocalStates(this.c, account);
  }
  /**
   * Returns application information created by the given account.
   *
   * #### Example
   * ```typescript
   * const address = "XBYLS2E6YI6XXL5BWCAMOA4GTWHXWENZMX5UHXMRNWWUQ7BXCY5WC5TEPA";
   * const accountCreatedApps = await indexerClient.lookupAccountCreatedApplications(address).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accountsaccount-idcreated-applications)
   * @param account - The address of the account to look up.
   * @category GET
   */
  lookupAccountCreatedApplications(account) {
    return new LookupAccountCreatedApplications(this.c, account);
  }
  /**
   * Returns information about the passed asset.
   *
   * #### Example
   * ```typescript
   * const assetId = 163650;
   * const assetInfo = await indexerClient.lookupAssetByID(assetId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2assetsasset-id)
   * @param index - The ID of the asset ot look up.
   * @category GET
   */
  lookupAssetByID(index) {
    return new LookupAssetByID(this.c, index);
  }
  /**
   * Returns information about the passed application.
   *
   * #### Example
   * ```typescript
   * const appId = 60553466;
   * const appInfo = await indexerClient.lookupApplications(appId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2applicationsapplication-id)
   * @param index - The ID of the application to look up.
   * @category GET
   */
  lookupApplications(index) {
    return new LookupApplications(this.c, index);
  }
  /**
   * Returns log messages generated by the passed in application.
   *
   * #### Example
   * ```typescript
   * const appId = 60553466;
   * const appLogs = await indexerClient.lookupApplicationLogs(appId).do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2applicationsapplication-idlogs)
   * @param appID - The ID of the application which generated the logs.
   * @category GET
   */
  lookupApplicationLogs(appID) {
    return new LookupApplicationLogs(this.c, appID);
  }
  /**
   * Returns information about indexed accounts.
   *
   * #### Example
   * ```typescript
   * const accounts = await indexerClient.searchAccounts().do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2accounts)
   * @category GET
   */
  searchAccounts() {
    return new SearchAccounts(this.c);
  }
  /**
   * Returns information about indexed block headers.
   *
   * #### Example
   * ```typescript
   * const bhs = await indexerClient.searchForBlockHeaders().do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2block-headers)
   * @category GET
   */
  searchForBlockHeaders() {
    return new SearchForBlockHeaders(this.c);
  }
  /**
   * Returns information about indexed transactions.
   *
   * #### Example
   * ```typescript
   * const txns = await indexerClient.searchForTransactions().do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2transactions)
   * @category GET
   */
  searchForTransactions() {
    return new SearchForTransactions(this.c);
  }
  /**
   * Returns information about indexed assets.
   *
   * #### Example
   * ```typescript
   * const assets = await indexerClient.searchForAssets().do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2assets)
   * @category GET
   */
  searchForAssets() {
    return new SearchForAssets(this.c);
  }
  /**
   * Returns information about indexed applications.
   *
   * #### Example
   * ```typescript
   * const apps = await indexerClient.searchForApplications().do();
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2applications)
   * @category GET
   */
  searchForApplications() {
    return new SearchForApplications(this.c);
  }
  /**
   * Returns information about indexed application boxes.
   *
   * #### Example
   * ```typescript
   * const maxResults = 20;
   * const appID = 1234;
   *
   * const responsePage1 = await indexerClient
   *        .searchForApplicationBoxes(appID)
   *        .limit(maxResults)
   *        .do();
   * const boxNamesPage1 = responsePage1.boxes.map(box => box.name);
   *
   * const responsePage2 = await indexerClient
   *        .searchForApplicationBoxes(appID)
   *        .limit(maxResults)
   *        .nextToken(responsePage1.nextToken)
   *        .do();
   * const boxNamesPage2 = responsePage2.boxes.map(box => box.name);
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2applicationsapplication-idboxes)
   * @param appID - The ID of the application with boxes.
   * @category GET
   */
  searchForApplicationBoxes(appID) {
    return new SearchForApplicationBoxes(this.c, appID);
  }
  /**
   * Returns information about the application box given its name.
   *
   * #### Example
   * ```typescript
   * const boxName = Buffer.from("foo");
   * const boxResponse = await indexerClient
   *        .LookupApplicationBoxByIDandName(1234, boxName)
   *        .do();
   * const boxValue = boxResponse.value;
   * ```
   *
   * [Response data schema details](https://developer.algorand.org/docs/rest-apis/indexer/#get-v2applicationsapplication-idbox)
   * @param appID - The ID of the application with boxes.
   * @category GET
   */
  lookupApplicationBoxByIDandName(appID, boxName) {
    return new LookupApplicationBoxByIDandName(this.c, appID, boxName);
  }
};

// node_modules/algosdk/dist/esm/wait.js
async function waitForConfirmation(client, txid, waitRounds) {
  const status = await client.status().do();
  if (typeof status === "undefined") {
    throw new Error("Unable to get node status");
  }
  const startRound = status.lastRound + BigInt(1);
  const stopRound = startRound + BigInt(waitRounds);
  let currentRound = startRound;
  while (currentRound < stopRound) {
    let poolError = false;
    try {
      const pendingInfo = await client.pendingTransactionInformation(txid).do();
      if (pendingInfo.confirmedRound) {
        return pendingInfo;
      }
      if (pendingInfo.poolError) {
        poolError = true;
        throw new Error(`Transaction Rejected: ${pendingInfo.poolError}`);
      }
    } catch (err) {
      if (poolError) {
        throw err;
      }
    }
    await client.statusAfterBlock(currentRound).do();
    currentRound += BigInt(1);
  }
  throw new Error(`Transaction not confirmed after ${waitRounds} rounds`);
}

// node_modules/algosdk/dist/esm/encoding/bigint.js
function bigIntToBytes(bi, size) {
  let hex = bi.toString(16);
  if (hex.length !== size * 2) {
    hex = hex.padStart(size * 2, "0");
  }
  const byteArray = new Uint8Array(hex.length / 2);
  for (let i2 = 0, j2 = 0; i2 < hex.length / 2; i2++, j2 += 2) {
    byteArray[i2] = parseInt(hex.slice(j2, j2 + 2), 16);
  }
  return byteArray;
}
function bytesToBigInt(bytes) {
  let res = BigInt(0);
  const buf = new DataView(bytes.buffer, bytes.byteOffset);
  for (let i2 = 0; i2 < bytes.length; i2++) {
    res = BigInt(Number(buf.getUint8(i2))) + res * BigInt(256);
  }
  return res;
}

// node_modules/algosdk/dist/esm/account.js
function generateAccount() {
  const keys = keyPair();
  const addr = new Address(keys.publicKey);
  return { addr, sk: keys.secretKey };
}

// node_modules/algosdk/dist/esm/mnemonic/wordlists/english.js
var english = [
  "abandon",
  "ability",
  "able",
  "about",
  "above",
  "absent",
  "absorb",
  "abstract",
  "absurd",
  "abuse",
  "access",
  "accident",
  "account",
  "accuse",
  "achieve",
  "acid",
  "acoustic",
  "acquire",
  "across",
  "act",
  "action",
  "actor",
  "actress",
  "actual",
  "adapt",
  "add",
  "addict",
  "address",
  "adjust",
  "admit",
  "adult",
  "advance",
  "advice",
  "aerobic",
  "affair",
  "afford",
  "afraid",
  "again",
  "age",
  "agent",
  "agree",
  "ahead",
  "aim",
  "air",
  "airport",
  "aisle",
  "alarm",
  "album",
  "alcohol",
  "alert",
  "alien",
  "all",
  "alley",
  "allow",
  "almost",
  "alone",
  "alpha",
  "already",
  "also",
  "alter",
  "always",
  "amateur",
  "amazing",
  "among",
  "amount",
  "amused",
  "analyst",
  "anchor",
  "ancient",
  "anger",
  "angle",
  "angry",
  "animal",
  "ankle",
  "announce",
  "annual",
  "another",
  "answer",
  "antenna",
  "antique",
  "anxiety",
  "any",
  "apart",
  "apology",
  "appear",
  "apple",
  "approve",
  "april",
  "arch",
  "arctic",
  "area",
  "arena",
  "argue",
  "arm",
  "armed",
  "armor",
  "army",
  "around",
  "arrange",
  "arrest",
  "arrive",
  "arrow",
  "art",
  "artefact",
  "artist",
  "artwork",
  "ask",
  "aspect",
  "assault",
  "asset",
  "assist",
  "assume",
  "asthma",
  "athlete",
  "atom",
  "attack",
  "attend",
  "attitude",
  "attract",
  "auction",
  "audit",
  "august",
  "aunt",
  "author",
  "auto",
  "autumn",
  "average",
  "avocado",
  "avoid",
  "awake",
  "aware",
  "away",
  "awesome",
  "awful",
  "awkward",
  "axis",
  "baby",
  "bachelor",
  "bacon",
  "badge",
  "bag",
  "balance",
  "balcony",
  "ball",
  "bamboo",
  "banana",
  "banner",
  "bar",
  "barely",
  "bargain",
  "barrel",
  "base",
  "basic",
  "basket",
  "battle",
  "beach",
  "bean",
  "beauty",
  "because",
  "become",
  "beef",
  "before",
  "begin",
  "behave",
  "behind",
  "believe",
  "below",
  "belt",
  "bench",
  "benefit",
  "best",
  "betray",
  "better",
  "between",
  "beyond",
  "bicycle",
  "bid",
  "bike",
  "bind",
  "biology",
  "bird",
  "birth",
  "bitter",
  "black",
  "blade",
  "blame",
  "blanket",
  "blast",
  "bleak",
  "bless",
  "blind",
  "blood",
  "blossom",
  "blouse",
  "blue",
  "blur",
  "blush",
  "board",
  "boat",
  "body",
  "boil",
  "bomb",
  "bone",
  "bonus",
  "book",
  "boost",
  "border",
  "boring",
  "borrow",
  "boss",
  "bottom",
  "bounce",
  "box",
  "boy",
  "bracket",
  "brain",
  "brand",
  "brass",
  "brave",
  "bread",
  "breeze",
  "brick",
  "bridge",
  "brief",
  "bright",
  "bring",
  "brisk",
  "broccoli",
  "broken",
  "bronze",
  "broom",
  "brother",
  "brown",
  "brush",
  "bubble",
  "buddy",
  "budget",
  "buffalo",
  "build",
  "bulb",
  "bulk",
  "bullet",
  "bundle",
  "bunker",
  "burden",
  "burger",
  "burst",
  "bus",
  "business",
  "busy",
  "butter",
  "buyer",
  "buzz",
  "cabbage",
  "cabin",
  "cable",
  "cactus",
  "cage",
  "cake",
  "call",
  "calm",
  "camera",
  "camp",
  "can",
  "canal",
  "cancel",
  "candy",
  "cannon",
  "canoe",
  "canvas",
  "canyon",
  "capable",
  "capital",
  "captain",
  "car",
  "carbon",
  "card",
  "cargo",
  "carpet",
  "carry",
  "cart",
  "case",
  "cash",
  "casino",
  "castle",
  "casual",
  "cat",
  "catalog",
  "catch",
  "category",
  "cattle",
  "caught",
  "cause",
  "caution",
  "cave",
  "ceiling",
  "celery",
  "cement",
  "census",
  "century",
  "cereal",
  "certain",
  "chair",
  "chalk",
  "champion",
  "change",
  "chaos",
  "chapter",
  "charge",
  "chase",
  "chat",
  "cheap",
  "check",
  "cheese",
  "chef",
  "cherry",
  "chest",
  "chicken",
  "chief",
  "child",
  "chimney",
  "choice",
  "choose",
  "chronic",
  "chuckle",
  "chunk",
  "churn",
  "cigar",
  "cinnamon",
  "circle",
  "citizen",
  "city",
  "civil",
  "claim",
  "clap",
  "clarify",
  "claw",
  "clay",
  "clean",
  "clerk",
  "clever",
  "click",
  "client",
  "cliff",
  "climb",
  "clinic",
  "clip",
  "clock",
  "clog",
  "close",
  "cloth",
  "cloud",
  "clown",
  "club",
  "clump",
  "cluster",
  "clutch",
  "coach",
  "coast",
  "coconut",
  "code",
  "coffee",
  "coil",
  "coin",
  "collect",
  "color",
  "column",
  "combine",
  "come",
  "comfort",
  "comic",
  "common",
  "company",
  "concert",
  "conduct",
  "confirm",
  "congress",
  "connect",
  "consider",
  "control",
  "convince",
  "cook",
  "cool",
  "copper",
  "copy",
  "coral",
  "core",
  "corn",
  "correct",
  "cost",
  "cotton",
  "couch",
  "country",
  "couple",
  "course",
  "cousin",
  "cover",
  "coyote",
  "crack",
  "cradle",
  "craft",
  "cram",
  "crane",
  "crash",
  "crater",
  "crawl",
  "crazy",
  "cream",
  "credit",
  "creek",
  "crew",
  "cricket",
  "crime",
  "crisp",
  "critic",
  "crop",
  "cross",
  "crouch",
  "crowd",
  "crucial",
  "cruel",
  "cruise",
  "crumble",
  "crunch",
  "crush",
  "cry",
  "crystal",
  "cube",
  "culture",
  "cup",
  "cupboard",
  "curious",
  "current",
  "curtain",
  "curve",
  "cushion",
  "custom",
  "cute",
  "cycle",
  "dad",
  "damage",
  "damp",
  "dance",
  "danger",
  "daring",
  "dash",
  "daughter",
  "dawn",
  "day",
  "deal",
  "debate",
  "debris",
  "decade",
  "december",
  "decide",
  "decline",
  "decorate",
  "decrease",
  "deer",
  "defense",
  "define",
  "defy",
  "degree",
  "delay",
  "deliver",
  "demand",
  "demise",
  "denial",
  "dentist",
  "deny",
  "depart",
  "depend",
  "deposit",
  "depth",
  "deputy",
  "derive",
  "describe",
  "desert",
  "design",
  "desk",
  "despair",
  "destroy",
  "detail",
  "detect",
  "develop",
  "device",
  "devote",
  "diagram",
  "dial",
  "diamond",
  "diary",
  "dice",
  "diesel",
  "diet",
  "differ",
  "digital",
  "dignity",
  "dilemma",
  "dinner",
  "dinosaur",
  "direct",
  "dirt",
  "disagree",
  "discover",
  "disease",
  "dish",
  "dismiss",
  "disorder",
  "display",
  "distance",
  "divert",
  "divide",
  "divorce",
  "dizzy",
  "doctor",
  "document",
  "dog",
  "doll",
  "dolphin",
  "domain",
  "donate",
  "donkey",
  "donor",
  "door",
  "dose",
  "double",
  "dove",
  "draft",
  "dragon",
  "drama",
  "drastic",
  "draw",
  "dream",
  "dress",
  "drift",
  "drill",
  "drink",
  "drip",
  "drive",
  "drop",
  "drum",
  "dry",
  "duck",
  "dumb",
  "dune",
  "during",
  "dust",
  "dutch",
  "duty",
  "dwarf",
  "dynamic",
  "eager",
  "eagle",
  "early",
  "earn",
  "earth",
  "easily",
  "east",
  "easy",
  "echo",
  "ecology",
  "economy",
  "edge",
  "edit",
  "educate",
  "effort",
  "egg",
  "eight",
  "either",
  "elbow",
  "elder",
  "electric",
  "elegant",
  "element",
  "elephant",
  "elevator",
  "elite",
  "else",
  "embark",
  "embody",
  "embrace",
  "emerge",
  "emotion",
  "employ",
  "empower",
  "empty",
  "enable",
  "enact",
  "end",
  "endless",
  "endorse",
  "enemy",
  "energy",
  "enforce",
  "engage",
  "engine",
  "enhance",
  "enjoy",
  "enlist",
  "enough",
  "enrich",
  "enroll",
  "ensure",
  "enter",
  "entire",
  "entry",
  "envelope",
  "episode",
  "equal",
  "equip",
  "era",
  "erase",
  "erode",
  "erosion",
  "error",
  "erupt",
  "escape",
  "essay",
  "essence",
  "estate",
  "eternal",
  "ethics",
  "evidence",
  "evil",
  "evoke",
  "evolve",
  "exact",
  "example",
  "excess",
  "exchange",
  "excite",
  "exclude",
  "excuse",
  "execute",
  "exercise",
  "exhaust",
  "exhibit",
  "exile",
  "exist",
  "exit",
  "exotic",
  "expand",
  "expect",
  "expire",
  "explain",
  "expose",
  "express",
  "extend",
  "extra",
  "eye",
  "eyebrow",
  "fabric",
  "face",
  "faculty",
  "fade",
  "faint",
  "faith",
  "fall",
  "false",
  "fame",
  "family",
  "famous",
  "fan",
  "fancy",
  "fantasy",
  "farm",
  "fashion",
  "fat",
  "fatal",
  "father",
  "fatigue",
  "fault",
  "favorite",
  "feature",
  "february",
  "federal",
  "fee",
  "feed",
  "feel",
  "female",
  "fence",
  "festival",
  "fetch",
  "fever",
  "few",
  "fiber",
  "fiction",
  "field",
  "figure",
  "file",
  "film",
  "filter",
  "final",
  "find",
  "fine",
  "finger",
  "finish",
  "fire",
  "firm",
  "first",
  "fiscal",
  "fish",
  "fit",
  "fitness",
  "fix",
  "flag",
  "flame",
  "flash",
  "flat",
  "flavor",
  "flee",
  "flight",
  "flip",
  "float",
  "flock",
  "floor",
  "flower",
  "fluid",
  "flush",
  "fly",
  "foam",
  "focus",
  "fog",
  "foil",
  "fold",
  "follow",
  "food",
  "foot",
  "force",
  "forest",
  "forget",
  "fork",
  "fortune",
  "forum",
  "forward",
  "fossil",
  "foster",
  "found",
  "fox",
  "fragile",
  "frame",
  "frequent",
  "fresh",
  "friend",
  "fringe",
  "frog",
  "front",
  "frost",
  "frown",
  "frozen",
  "fruit",
  "fuel",
  "fun",
  "funny",
  "furnace",
  "fury",
  "future",
  "gadget",
  "gain",
  "galaxy",
  "gallery",
  "game",
  "gap",
  "garage",
  "garbage",
  "garden",
  "garlic",
  "garment",
  "gas",
  "gasp",
  "gate",
  "gather",
  "gauge",
  "gaze",
  "general",
  "genius",
  "genre",
  "gentle",
  "genuine",
  "gesture",
  "ghost",
  "giant",
  "gift",
  "giggle",
  "ginger",
  "giraffe",
  "girl",
  "give",
  "glad",
  "glance",
  "glare",
  "glass",
  "glide",
  "glimpse",
  "globe",
  "gloom",
  "glory",
  "glove",
  "glow",
  "glue",
  "goat",
  "goddess",
  "gold",
  "good",
  "goose",
  "gorilla",
  "gospel",
  "gossip",
  "govern",
  "gown",
  "grab",
  "grace",
  "grain",
  "grant",
  "grape",
  "grass",
  "gravity",
  "great",
  "green",
  "grid",
  "grief",
  "grit",
  "grocery",
  "group",
  "grow",
  "grunt",
  "guard",
  "guess",
  "guide",
  "guilt",
  "guitar",
  "gun",
  "gym",
  "habit",
  "hair",
  "half",
  "hammer",
  "hamster",
  "hand",
  "happy",
  "harbor",
  "hard",
  "harsh",
  "harvest",
  "hat",
  "have",
  "hawk",
  "hazard",
  "head",
  "health",
  "heart",
  "heavy",
  "hedgehog",
  "height",
  "hello",
  "helmet",
  "help",
  "hen",
  "hero",
  "hidden",
  "high",
  "hill",
  "hint",
  "hip",
  "hire",
  "history",
  "hobby",
  "hockey",
  "hold",
  "hole",
  "holiday",
  "hollow",
  "home",
  "honey",
  "hood",
  "hope",
  "horn",
  "horror",
  "horse",
  "hospital",
  "host",
  "hotel",
  "hour",
  "hover",
  "hub",
  "huge",
  "human",
  "humble",
  "humor",
  "hundred",
  "hungry",
  "hunt",
  "hurdle",
  "hurry",
  "hurt",
  "husband",
  "hybrid",
  "ice",
  "icon",
  "idea",
  "identify",
  "idle",
  "ignore",
  "ill",
  "illegal",
  "illness",
  "image",
  "imitate",
  "immense",
  "immune",
  "impact",
  "impose",
  "improve",
  "impulse",
  "inch",
  "include",
  "income",
  "increase",
  "index",
  "indicate",
  "indoor",
  "industry",
  "infant",
  "inflict",
  "inform",
  "inhale",
  "inherit",
  "initial",
  "inject",
  "injury",
  "inmate",
  "inner",
  "innocent",
  "input",
  "inquiry",
  "insane",
  "insect",
  "inside",
  "inspire",
  "install",
  "intact",
  "interest",
  "into",
  "invest",
  "invite",
  "involve",
  "iron",
  "island",
  "isolate",
  "issue",
  "item",
  "ivory",
  "jacket",
  "jaguar",
  "jar",
  "jazz",
  "jealous",
  "jeans",
  "jelly",
  "jewel",
  "job",
  "join",
  "joke",
  "journey",
  "joy",
  "judge",
  "juice",
  "jump",
  "jungle",
  "junior",
  "junk",
  "just",
  "kangaroo",
  "keen",
  "keep",
  "ketchup",
  "key",
  "kick",
  "kid",
  "kidney",
  "kind",
  "kingdom",
  "kiss",
  "kit",
  "kitchen",
  "kite",
  "kitten",
  "kiwi",
  "knee",
  "knife",
  "knock",
  "know",
  "lab",
  "label",
  "labor",
  "ladder",
  "lady",
  "lake",
  "lamp",
  "language",
  "laptop",
  "large",
  "later",
  "latin",
  "laugh",
  "laundry",
  "lava",
  "law",
  "lawn",
  "lawsuit",
  "layer",
  "lazy",
  "leader",
  "leaf",
  "learn",
  "leave",
  "lecture",
  "left",
  "leg",
  "legal",
  "legend",
  "leisure",
  "lemon",
  "lend",
  "length",
  "lens",
  "leopard",
  "lesson",
  "letter",
  "level",
  "liar",
  "liberty",
  "library",
  "license",
  "life",
  "lift",
  "light",
  "like",
  "limb",
  "limit",
  "link",
  "lion",
  "liquid",
  "list",
  "little",
  "live",
  "lizard",
  "load",
  "loan",
  "lobster",
  "local",
  "lock",
  "logic",
  "lonely",
  "long",
  "loop",
  "lottery",
  "loud",
  "lounge",
  "love",
  "loyal",
  "lucky",
  "luggage",
  "lumber",
  "lunar",
  "lunch",
  "luxury",
  "lyrics",
  "machine",
  "mad",
  "magic",
  "magnet",
  "maid",
  "mail",
  "main",
  "major",
  "make",
  "mammal",
  "man",
  "manage",
  "mandate",
  "mango",
  "mansion",
  "manual",
  "maple",
  "marble",
  "march",
  "margin",
  "marine",
  "market",
  "marriage",
  "mask",
  "mass",
  "master",
  "match",
  "material",
  "math",
  "matrix",
  "matter",
  "maximum",
  "maze",
  "meadow",
  "mean",
  "measure",
  "meat",
  "mechanic",
  "medal",
  "media",
  "melody",
  "melt",
  "member",
  "memory",
  "mention",
  "menu",
  "mercy",
  "merge",
  "merit",
  "merry",
  "mesh",
  "message",
  "metal",
  "method",
  "middle",
  "midnight",
  "milk",
  "million",
  "mimic",
  "mind",
  "minimum",
  "minor",
  "minute",
  "miracle",
  "mirror",
  "misery",
  "miss",
  "mistake",
  "mix",
  "mixed",
  "mixture",
  "mobile",
  "model",
  "modify",
  "mom",
  "moment",
  "monitor",
  "monkey",
  "monster",
  "month",
  "moon",
  "moral",
  "more",
  "morning",
  "mosquito",
  "mother",
  "motion",
  "motor",
  "mountain",
  "mouse",
  "move",
  "movie",
  "much",
  "muffin",
  "mule",
  "multiply",
  "muscle",
  "museum",
  "mushroom",
  "music",
  "must",
  "mutual",
  "myself",
  "mystery",
  "myth",
  "naive",
  "name",
  "napkin",
  "narrow",
  "nasty",
  "nation",
  "nature",
  "near",
  "neck",
  "need",
  "negative",
  "neglect",
  "neither",
  "nephew",
  "nerve",
  "nest",
  "net",
  "network",
  "neutral",
  "never",
  "news",
  "next",
  "nice",
  "night",
  "noble",
  "noise",
  "nominee",
  "noodle",
  "normal",
  "north",
  "nose",
  "notable",
  "note",
  "nothing",
  "notice",
  "novel",
  "now",
  "nuclear",
  "number",
  "nurse",
  "nut",
  "oak",
  "obey",
  "object",
  "oblige",
  "obscure",
  "observe",
  "obtain",
  "obvious",
  "occur",
  "ocean",
  "october",
  "odor",
  "off",
  "offer",
  "office",
  "often",
  "oil",
  "okay",
  "old",
  "olive",
  "olympic",
  "omit",
  "once",
  "one",
  "onion",
  "online",
  "only",
  "open",
  "opera",
  "opinion",
  "oppose",
  "option",
  "orange",
  "orbit",
  "orchard",
  "order",
  "ordinary",
  "organ",
  "orient",
  "original",
  "orphan",
  "ostrich",
  "other",
  "outdoor",
  "outer",
  "output",
  "outside",
  "oval",
  "oven",
  "over",
  "own",
  "owner",
  "oxygen",
  "oyster",
  "ozone",
  "pact",
  "paddle",
  "page",
  "pair",
  "palace",
  "palm",
  "panda",
  "panel",
  "panic",
  "panther",
  "paper",
  "parade",
  "parent",
  "park",
  "parrot",
  "party",
  "pass",
  "patch",
  "path",
  "patient",
  "patrol",
  "pattern",
  "pause",
  "pave",
  "payment",
  "peace",
  "peanut",
  "pear",
  "peasant",
  "pelican",
  "pen",
  "penalty",
  "pencil",
  "people",
  "pepper",
  "perfect",
  "permit",
  "person",
  "pet",
  "phone",
  "photo",
  "phrase",
  "physical",
  "piano",
  "picnic",
  "picture",
  "piece",
  "pig",
  "pigeon",
  "pill",
  "pilot",
  "pink",
  "pioneer",
  "pipe",
  "pistol",
  "pitch",
  "pizza",
  "place",
  "planet",
  "plastic",
  "plate",
  "play",
  "please",
  "pledge",
  "pluck",
  "plug",
  "plunge",
  "poem",
  "poet",
  "point",
  "polar",
  "pole",
  "police",
  "pond",
  "pony",
  "pool",
  "popular",
  "portion",
  "position",
  "possible",
  "post",
  "potato",
  "pottery",
  "poverty",
  "powder",
  "power",
  "practice",
  "praise",
  "predict",
  "prefer",
  "prepare",
  "present",
  "pretty",
  "prevent",
  "price",
  "pride",
  "primary",
  "print",
  "priority",
  "prison",
  "private",
  "prize",
  "problem",
  "process",
  "produce",
  "profit",
  "program",
  "project",
  "promote",
  "proof",
  "property",
  "prosper",
  "protect",
  "proud",
  "provide",
  "public",
  "pudding",
  "pull",
  "pulp",
  "pulse",
  "pumpkin",
  "punch",
  "pupil",
  "puppy",
  "purchase",
  "purity",
  "purpose",
  "purse",
  "push",
  "put",
  "puzzle",
  "pyramid",
  "quality",
  "quantum",
  "quarter",
  "question",
  "quick",
  "quit",
  "quiz",
  "quote",
  "rabbit",
  "raccoon",
  "race",
  "rack",
  "radar",
  "radio",
  "rail",
  "rain",
  "raise",
  "rally",
  "ramp",
  "ranch",
  "random",
  "range",
  "rapid",
  "rare",
  "rate",
  "rather",
  "raven",
  "raw",
  "razor",
  "ready",
  "real",
  "reason",
  "rebel",
  "rebuild",
  "recall",
  "receive",
  "recipe",
  "record",
  "recycle",
  "reduce",
  "reflect",
  "reform",
  "refuse",
  "region",
  "regret",
  "regular",
  "reject",
  "relax",
  "release",
  "relief",
  "rely",
  "remain",
  "remember",
  "remind",
  "remove",
  "render",
  "renew",
  "rent",
  "reopen",
  "repair",
  "repeat",
  "replace",
  "report",
  "require",
  "rescue",
  "resemble",
  "resist",
  "resource",
  "response",
  "result",
  "retire",
  "retreat",
  "return",
  "reunion",
  "reveal",
  "review",
  "reward",
  "rhythm",
  "rib",
  "ribbon",
  "rice",
  "rich",
  "ride",
  "ridge",
  "rifle",
  "right",
  "rigid",
  "ring",
  "riot",
  "ripple",
  "risk",
  "ritual",
  "rival",
  "river",
  "road",
  "roast",
  "robot",
  "robust",
  "rocket",
  "romance",
  "roof",
  "rookie",
  "room",
  "rose",
  "rotate",
  "rough",
  "round",
  "route",
  "royal",
  "rubber",
  "rude",
  "rug",
  "rule",
  "run",
  "runway",
  "rural",
  "sad",
  "saddle",
  "sadness",
  "safe",
  "sail",
  "salad",
  "salmon",
  "salon",
  "salt",
  "salute",
  "same",
  "sample",
  "sand",
  "satisfy",
  "satoshi",
  "sauce",
  "sausage",
  "save",
  "say",
  "scale",
  "scan",
  "scare",
  "scatter",
  "scene",
  "scheme",
  "school",
  "science",
  "scissors",
  "scorpion",
  "scout",
  "scrap",
  "screen",
  "script",
  "scrub",
  "sea",
  "search",
  "season",
  "seat",
  "second",
  "secret",
  "section",
  "security",
  "seed",
  "seek",
  "segment",
  "select",
  "sell",
  "seminar",
  "senior",
  "sense",
  "sentence",
  "series",
  "service",
  "session",
  "settle",
  "setup",
  "seven",
  "shadow",
  "shaft",
  "shallow",
  "share",
  "shed",
  "shell",
  "sheriff",
  "shield",
  "shift",
  "shine",
  "ship",
  "shiver",
  "shock",
  "shoe",
  "shoot",
  "shop",
  "short",
  "shoulder",
  "shove",
  "shrimp",
  "shrug",
  "shuffle",
  "shy",
  "sibling",
  "sick",
  "side",
  "siege",
  "sight",
  "sign",
  "silent",
  "silk",
  "silly",
  "silver",
  "similar",
  "simple",
  "since",
  "sing",
  "siren",
  "sister",
  "situate",
  "six",
  "size",
  "skate",
  "sketch",
  "ski",
  "skill",
  "skin",
  "skirt",
  "skull",
  "slab",
  "slam",
  "sleep",
  "slender",
  "slice",
  "slide",
  "slight",
  "slim",
  "slogan",
  "slot",
  "slow",
  "slush",
  "small",
  "smart",
  "smile",
  "smoke",
  "smooth",
  "snack",
  "snake",
  "snap",
  "sniff",
  "snow",
  "soap",
  "soccer",
  "social",
  "sock",
  "soda",
  "soft",
  "solar",
  "soldier",
  "solid",
  "solution",
  "solve",
  "someone",
  "song",
  "soon",
  "sorry",
  "sort",
  "soul",
  "sound",
  "soup",
  "source",
  "south",
  "space",
  "spare",
  "spatial",
  "spawn",
  "speak",
  "special",
  "speed",
  "spell",
  "spend",
  "sphere",
  "spice",
  "spider",
  "spike",
  "spin",
  "spirit",
  "split",
  "spoil",
  "sponsor",
  "spoon",
  "sport",
  "spot",
  "spray",
  "spread",
  "spring",
  "spy",
  "square",
  "squeeze",
  "squirrel",
  "stable",
  "stadium",
  "staff",
  "stage",
  "stairs",
  "stamp",
  "stand",
  "start",
  "state",
  "stay",
  "steak",
  "steel",
  "stem",
  "step",
  "stereo",
  "stick",
  "still",
  "sting",
  "stock",
  "stomach",
  "stone",
  "stool",
  "story",
  "stove",
  "strategy",
  "street",
  "strike",
  "strong",
  "struggle",
  "student",
  "stuff",
  "stumble",
  "style",
  "subject",
  "submit",
  "subway",
  "success",
  "such",
  "sudden",
  "suffer",
  "sugar",
  "suggest",
  "suit",
  "summer",
  "sun",
  "sunny",
  "sunset",
  "super",
  "supply",
  "supreme",
  "sure",
  "surface",
  "surge",
  "surprise",
  "surround",
  "survey",
  "suspect",
  "sustain",
  "swallow",
  "swamp",
  "swap",
  "swarm",
  "swear",
  "sweet",
  "swift",
  "swim",
  "swing",
  "switch",
  "sword",
  "symbol",
  "symptom",
  "syrup",
  "system",
  "table",
  "tackle",
  "tag",
  "tail",
  "talent",
  "talk",
  "tank",
  "tape",
  "target",
  "task",
  "taste",
  "tattoo",
  "taxi",
  "teach",
  "team",
  "tell",
  "ten",
  "tenant",
  "tennis",
  "tent",
  "term",
  "test",
  "text",
  "thank",
  "that",
  "theme",
  "then",
  "theory",
  "there",
  "they",
  "thing",
  "this",
  "thought",
  "three",
  "thrive",
  "throw",
  "thumb",
  "thunder",
  "ticket",
  "tide",
  "tiger",
  "tilt",
  "timber",
  "time",
  "tiny",
  "tip",
  "tired",
  "tissue",
  "title",
  "toast",
  "tobacco",
  "today",
  "toddler",
  "toe",
  "together",
  "toilet",
  "token",
  "tomato",
  "tomorrow",
  "tone",
  "tongue",
  "tonight",
  "tool",
  "tooth",
  "top",
  "topic",
  "topple",
  "torch",
  "tornado",
  "tortoise",
  "toss",
  "total",
  "tourist",
  "toward",
  "tower",
  "town",
  "toy",
  "track",
  "trade",
  "traffic",
  "tragic",
  "train",
  "transfer",
  "trap",
  "trash",
  "travel",
  "tray",
  "treat",
  "tree",
  "trend",
  "trial",
  "tribe",
  "trick",
  "trigger",
  "trim",
  "trip",
  "trophy",
  "trouble",
  "truck",
  "true",
  "truly",
  "trumpet",
  "trust",
  "truth",
  "try",
  "tube",
  "tuition",
  "tumble",
  "tuna",
  "tunnel",
  "turkey",
  "turn",
  "turtle",
  "twelve",
  "twenty",
  "twice",
  "twin",
  "twist",
  "two",
  "type",
  "typical",
  "ugly",
  "umbrella",
  "unable",
  "unaware",
  "uncle",
  "uncover",
  "under",
  "undo",
  "unfair",
  "unfold",
  "unhappy",
  "uniform",
  "unique",
  "unit",
  "universe",
  "unknown",
  "unlock",
  "until",
  "unusual",
  "unveil",
  "update",
  "upgrade",
  "uphold",
  "upon",
  "upper",
  "upset",
  "urban",
  "urge",
  "usage",
  "use",
  "used",
  "useful",
  "useless",
  "usual",
  "utility",
  "vacant",
  "vacuum",
  "vague",
  "valid",
  "valley",
  "valve",
  "van",
  "vanish",
  "vapor",
  "various",
  "vast",
  "vault",
  "vehicle",
  "velvet",
  "vendor",
  "venture",
  "venue",
  "verb",
  "verify",
  "version",
  "very",
  "vessel",
  "veteran",
  "viable",
  "vibrant",
  "vicious",
  "victory",
  "video",
  "view",
  "village",
  "vintage",
  "violin",
  "virtual",
  "virus",
  "visa",
  "visit",
  "visual",
  "vital",
  "vivid",
  "vocal",
  "voice",
  "void",
  "volcano",
  "volume",
  "vote",
  "voyage",
  "wage",
  "wagon",
  "wait",
  "walk",
  "wall",
  "walnut",
  "want",
  "warfare",
  "warm",
  "warrior",
  "wash",
  "wasp",
  "waste",
  "water",
  "wave",
  "way",
  "wealth",
  "weapon",
  "wear",
  "weasel",
  "weather",
  "web",
  "wedding",
  "weekend",
  "weird",
  "welcome",
  "west",
  "wet",
  "whale",
  "what",
  "wheat",
  "wheel",
  "when",
  "where",
  "whip",
  "whisper",
  "wide",
  "width",
  "wife",
  "wild",
  "will",
  "win",
  "window",
  "wine",
  "wing",
  "wink",
  "winner",
  "winter",
  "wire",
  "wisdom",
  "wise",
  "wish",
  "witness",
  "wolf",
  "woman",
  "wonder",
  "wood",
  "wool",
  "word",
  "work",
  "world",
  "worry",
  "worth",
  "wrap",
  "wreck",
  "wrestle",
  "wrist",
  "write",
  "wrong",
  "yard",
  "year",
  "yellow",
  "you",
  "young",
  "youth",
  "zebra",
  "zero",
  "zone",
  "zoo"
];
var english_default = english;

// node_modules/algosdk/dist/esm/mnemonic/mnemonic.js
var FAIL_TO_DECODE_MNEMONIC_ERROR_MSG = "failed to decode mnemonic";
var NOT_IN_WORDS_LIST_ERROR_MSG = "the mnemonic contains a word that is not in the wordlist";
function toUint11Array(buffer8) {
  const buffer11 = [];
  let acc = 0;
  let accBits = 0;
  function add(octet) {
    acc |= octet << accBits;
    accBits += 8;
    if (accBits >= 11) {
      buffer11.push(acc & 2047);
      acc >>= 11;
      accBits -= 11;
    }
  }
  function flush() {
    if (accBits) {
      buffer11.push(acc);
    }
  }
  buffer8.forEach(add);
  flush();
  return buffer11;
}
function applyWords(nums) {
  return nums.map((n2) => english_default[n2]);
}
function computeChecksum(seed) {
  const hashBuffer = genericHash(seed);
  const uint11Hash = toUint11Array(hashBuffer);
  const words = applyWords(uint11Hash);
  return words[0];
}
function mnemonicFromSeed(seed) {
  if (seed.length !== SEED_BTYES_LENGTH) {
    throw new RangeError(`Seed length must be ${SEED_BTYES_LENGTH}`);
  }
  const uint11Array = toUint11Array(seed);
  const words = applyWords(uint11Array);
  const checksumWord = computeChecksum(seed);
  return `${words.join(" ")} ${checksumWord}`;
}
function toUint8Array(buffer11) {
  const buffer8 = [];
  let acc = 0;
  let accBits = 0;
  function add(ui11) {
    acc |= ui11 << accBits;
    accBits += 11;
    while (accBits >= 8) {
      buffer8.push(acc & 255);
      acc >>= 8;
      accBits -= 8;
    }
  }
  function flush() {
    if (accBits) {
      buffer8.push(acc);
    }
  }
  buffer11.forEach(add);
  flush();
  return new Uint8Array(buffer8);
}
function seedFromMnemonic(mnemonic) {
  const words = mnemonic.split(" ");
  const key = words.slice(0, 24);
  for (const w2 of key) {
    if (english_default.indexOf(w2) === -1)
      throw new Error(NOT_IN_WORDS_LIST_ERROR_MSG);
  }
  const checksum = words[words.length - 1];
  const uint11Array = key.map((word) => english_default.indexOf(word));
  let uint8Array = toUint8Array(uint11Array);
  if (uint8Array.length !== 33)
    throw new Error(FAIL_TO_DECODE_MNEMONIC_ERROR_MSG);
  if (uint8Array[uint8Array.length - 1] !== 0)
    throw new Error(FAIL_TO_DECODE_MNEMONIC_ERROR_MSG);
  uint8Array = uint8Array.slice(0, uint8Array.length - 1);
  const cs = computeChecksum(uint8Array);
  if (cs === checksum)
    return uint8Array;
  throw new Error(FAIL_TO_DECODE_MNEMONIC_ERROR_MSG);
}
function mnemonicToSecretKey(mn) {
  const seed = seedFromMnemonic(mn);
  const keys = keyPairFromSeed(seed);
  const addr = new Address(keys.publicKey);
  return { addr, sk: keys.secretKey };
}
function secretKeyToMnemonic(sk) {
  const seed = sk.slice(0, SEED_BTYES_LENGTH);
  return mnemonicFromSeed(seed);
}
function mnemonicToMasterDerivationKey(mn) {
  return seedFromMnemonic(mn);
}
function masterDerivationKeyToMnemonic(mdk) {
  return mnemonicFromSeed(mdk);
}

// node_modules/algosdk/dist/esm/group.js
var ALGORAND_MAX_TX_GROUP_SIZE = 16;
var TX_GROUP_TAG = new TextEncoder().encode("TG");
function txGroupPreimage(txnHashes) {
  if (txnHashes.length > ALGORAND_MAX_TX_GROUP_SIZE) {
    throw new Error(`${txnHashes.length} transactions grouped together but max group size is ${ALGORAND_MAX_TX_GROUP_SIZE}`);
  }
  if (txnHashes.length === 0) {
    throw new Error("Cannot compute group ID of zero transactions");
  }
  const bytes = msgpackRawEncode({
    txlist: txnHashes
  });
  return concatArrays2(TX_GROUP_TAG, bytes);
}
function computeGroupID(txns) {
  const hashes = [];
  for (const txn of txns) {
    hashes.push(txn.rawTxID());
  }
  const toBeHashed = txGroupPreimage(hashes);
  const gid = genericHash(toBeHashed);
  return Uint8Array.from(gid);
}
function assignGroupID(txns) {
  const gid = computeGroupID(txns);
  for (const txn of txns) {
    txn.group = gid;
  }
  return txns;
}

// node_modules/algosdk/dist/esm/signing.js
function signLogicSigTransactionWithAddress(txn, lsig, lsigAddress) {
  if (!lsig.verify(lsigAddress.publicKey)) {
    throw new Error("Logic signature verification failed. Ensure the program and signature are valid.");
  }
  let sgnr;
  if (!bytesEqual(lsigAddress.publicKey, txn.sender.publicKey)) {
    sgnr = lsigAddress;
  }
  const signedTxn = new SignedTransaction({
    lsig,
    txn,
    sgnr
  });
  return {
    txID: txn.txID(),
    blob: encodeMsgpack(signedTxn)
  };
}
function signLogicSigTransactionObject(txn, lsigObject) {
  let lsig;
  let lsigAddress;
  if (lsigObject instanceof LogicSigAccount) {
    lsig = lsigObject.lsig;
    lsigAddress = lsigObject.address();
  } else {
    lsig = lsigObject;
    if (lsig.sig) {
      lsigAddress = new Address(txn.sender.publicKey);
    } else if (lsig.lmsig) {
      const msigMetadata = {
        version: lsig.lmsig.v,
        threshold: lsig.lmsig.thr,
        pks: lsig.lmsig.subsig.map((subsig) => subsig.pk)
      };
      lsigAddress = addressFromMultisigPreImg(msigMetadata);
    } else {
      lsigAddress = lsig.address();
    }
  }
  return signLogicSigTransactionWithAddress(txn, lsig, lsigAddress);
}
function signLogicSigTransaction(txn, lsigObject) {
  return signLogicSigTransactionObject(txn, lsigObject);
}

// node_modules/algosdk/dist/esm/multisigSigning.js
var MULTISIG_MERGE_LESSTHANTWO_ERROR_MSG = "Not enough multisig transactions to merge. Need at least two";
var MULTISIG_MERGE_MISMATCH_ERROR_MSG = "Cannot merge txs. txIDs differ";
var MULTISIG_MERGE_MISMATCH_AUTH_ADDR_MSG = "Cannot merge txs. Auth addrs differ";
var MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG = "Cannot merge txs. Multisig preimages differ";
var MULTISIG_MERGE_SIG_MISMATCH_ERROR_MSG = "Cannot merge txs. subsigs are mismatched.";
var MULTISIG_SIGNATURE_LENGTH_ERROR_MSG = "Cannot add multisig signature. Signature is not of the correct length.";
var MULTISIG_KEY_NOT_EXIST_ERROR_MSG = "Key does not exist";
function createMultisigTransaction(txn, { version, threshold, addrs }) {
  const pks = pksFromAddresses(addrs);
  const subsigs = pks.map((pk) => ({ pk }));
  const msig = {
    v: version,
    thr: threshold,
    subsig: subsigs
  };
  const msigAddr = addressFromMultisigPreImg({
    version,
    threshold,
    pks
  });
  let sgnr;
  if (!txn.sender.equals(msigAddr)) {
    sgnr = msigAddr;
  }
  const signedTxn = new SignedTransaction({
    txn,
    msig,
    sgnr
  });
  return encodeMsgpack(signedTxn);
}
function createMultisigTransactionWithSignature(txn, { rawSig, myPk }, { version, threshold, pks }) {
  const encodedMsig = createMultisigTransaction(txn, {
    version,
    threshold,
    addrs: pks.map((pk) => new Address(pk))
  });
  const signedTxn = decodeMsgpack(encodedMsig, SignedTransaction);
  let keyExist = false;
  signedTxn.msig.subsig.forEach((subsig, i2) => {
    if (bytesEqual(subsig.pk, myPk)) {
      keyExist = true;
      signedTxn.msig.subsig[i2].s = rawSig;
    }
  });
  if (!keyExist) {
    throw new Error(MULTISIG_KEY_NOT_EXIST_ERROR_MSG);
  }
  return encodeMsgpack(signedTxn);
}
function partialSignTxn(transaction, { version, threshold, pks }, sk) {
  const myPk = keyPairFromSecretKey(sk).publicKey;
  return createMultisigTransactionWithSignature(transaction, { rawSig: transaction.rawSignTxn(sk), myPk }, { version, threshold, pks });
}
function partialSignWithMultisigSignature(transaction, metadata, signerAddr, signature) {
  if (!isValidSignatureLength(signature.length)) {
    throw new Error(MULTISIG_SIGNATURE_LENGTH_ERROR_MSG);
  }
  const signerAddressObj = typeof signerAddr === "string" ? Address.fromString(signerAddr) : signerAddr;
  return createMultisigTransactionWithSignature(transaction, {
    rawSig: signature,
    myPk: signerAddressObj.publicKey
  }, metadata);
}
function mergeMultisigTransactions(multisigTxnBlobs) {
  if (multisigTxnBlobs.length < 2) {
    throw new Error(MULTISIG_MERGE_LESSTHANTWO_ERROR_MSG);
  }
  const refSigTx = decodeMsgpack(multisigTxnBlobs[0], SignedTransaction);
  if (!refSigTx.msig) {
    throw new Error("Invalid multisig transaction, multisig structure missing at index 0");
  }
  const refTxID = refSigTx.txn.txID();
  const refAuthAddr = refSigTx.sgnr ? refSigTx.sgnr.toString() : void 0;
  const refPreImage = {
    version: refSigTx.msig.v,
    threshold: refSigTx.msig.thr,
    pks: refSigTx.msig.subsig.map((subsig) => subsig.pk)
  };
  const refMsigAddr = addressFromMultisigPreImg(refPreImage);
  const newSubsigs = refSigTx.msig.subsig.map((sig) => ({ ...sig }));
  for (let i2 = 1; i2 < multisigTxnBlobs.length; i2++) {
    const unisig = decodeMsgpack(multisigTxnBlobs[i2], SignedTransaction);
    if (!unisig.msig) {
      throw new Error(`Invalid multisig transaction, multisig structure missing at index ${i2}`);
    }
    if (unisig.txn.txID() !== refTxID) {
      throw new Error(MULTISIG_MERGE_MISMATCH_ERROR_MSG);
    }
    const authAddr = unisig.sgnr ? unisig.sgnr.toString() : void 0;
    if (refAuthAddr !== authAddr) {
      throw new Error(MULTISIG_MERGE_MISMATCH_AUTH_ADDR_MSG);
    }
    if (unisig.msig.subsig.length !== refSigTx.msig.subsig.length) {
      throw new Error(MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG);
    }
    const preimg = {
      version: unisig.msig.v,
      threshold: unisig.msig.thr,
      pks: unisig.msig.subsig.map((subsig) => subsig.pk)
    };
    const msgigAddr = addressFromMultisigPreImg(preimg);
    if (!refMsigAddr.equals(msgigAddr)) {
      throw new Error(MULTISIG_MERGE_WRONG_PREIMAGE_ERROR_MSG);
    }
    unisig.msig.subsig.forEach((uniSubsig, index) => {
      if (!uniSubsig.s)
        return;
      const current = newSubsigs[index];
      if (current.s && !arrayEqual(uniSubsig.s, current.s)) {
        throw new Error(MULTISIG_MERGE_SIG_MISMATCH_ERROR_MSG);
      }
      current.s = uniSubsig.s;
    });
  }
  const msig = {
    v: refSigTx.msig.v,
    thr: refSigTx.msig.thr,
    subsig: newSubsigs
  };
  const refSgnr = typeof refAuthAddr !== "undefined" ? refSigTx.sgnr : void 0;
  const signedTxn = new SignedTransaction({
    msig,
    txn: refSigTx.txn,
    sgnr: refSgnr
  });
  return encodeMsgpack(signedTxn);
}
function signMultisigTransaction(txn, { version, threshold, addrs }, sk) {
  const pks = pksFromAddresses(addrs);
  const blob = partialSignTxn(txn, { version, threshold, pks }, sk);
  return {
    txID: txn.txID(),
    blob
  };
}
function appendSignMultisigTransaction(multisigTxnBlob, { version, threshold, addrs }, sk) {
  const pks = pksFromAddresses(addrs);
  const multisigTxObj = decodeMsgpack(multisigTxnBlob, SignedTransaction);
  const partialSignedBlob = partialSignTxn(multisigTxObj.txn, { version, threshold, pks }, sk);
  return {
    txID: multisigTxObj.txn.txID(),
    blob: mergeMultisigTransactions([multisigTxnBlob, partialSignedBlob])
  };
}
function appendSignRawMultisigSignature(multisigTxnBlob, { version, threshold, addrs }, signerAddr, signature) {
  const pks = pksFromAddresses(addrs);
  const multisigTxObj = decodeMsgpack(multisigTxnBlob, SignedTransaction);
  const partialSignedBlob = partialSignWithMultisigSignature(multisigTxObj.txn, { version, threshold, pks }, signerAddr, signature);
  return {
    txID: multisigTxObj.txn.txID(),
    blob: mergeMultisigTransactions([multisigTxnBlob, partialSignedBlob])
  };
}

// node_modules/vlq/src/index.js
var char_to_integer = {};
var integer_to_char = {};
"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".split("").forEach(function(char, i2) {
  char_to_integer[char] = i2;
  integer_to_char[i2] = char;
});
function decode2(string) {
  let result = [];
  let shift = 0;
  let value = 0;
  for (let i2 = 0; i2 < string.length; i2 += 1) {
    let integer = char_to_integer[string[i2]];
    if (integer === void 0) {
      throw new Error("Invalid character (" + string[i2] + ")");
    }
    const has_continuation_bit = integer & 32;
    integer &= 31;
    value += integer << shift;
    if (has_continuation_bit) {
      shift += 5;
    } else {
      const should_negate = value & 1;
      value >>>= 1;
      if (should_negate) {
        result.push(value === 0 ? -2147483648 : -value);
      } else {
        result.push(value);
      }
      value = shift = 0;
    }
  }
  return result;
}

// node_modules/algosdk/dist/esm/logic/sourcemap.js
var ProgramSourceMap = class {
  constructor({ version, sources, names, mappings }) {
    this.version = version;
    this.sources = sources;
    this.names = names;
    this.mappings = mappings;
    if (this.version !== 3)
      throw new Error(`Only version 3 is supported, got ${this.version}`);
    if (this.mappings === void 0)
      throw new Error("mapping undefined, cannot build source map without `mapping`");
    const pcList = this.mappings.split(";").map(decode2);
    this.pcToLocation = /* @__PURE__ */ new Map();
    this.sourceAndLineToPc = /* @__PURE__ */ new Map();
    const lastLocation = {
      line: 0,
      column: 0,
      sourceIndex: 0,
      nameIndex: 0
    };
    for (const [pc, data] of pcList.entries()) {
      if (data.length < 4)
        continue;
      const nameDelta = data.length > 4 ? data[4] : void 0;
      const [, sourceDelta, lineDelta, columnDelta] = data;
      lastLocation.sourceIndex += sourceDelta;
      lastLocation.line += lineDelta;
      lastLocation.column += columnDelta;
      if (typeof nameDelta !== "undefined") {
        lastLocation.nameIndex += nameDelta;
      }
      const sourceAndLineKey = `${lastLocation.sourceIndex}:${lastLocation.line}`;
      let pcsForSourceAndLine = this.sourceAndLineToPc.get(sourceAndLineKey);
      if (pcsForSourceAndLine === void 0) {
        pcsForSourceAndLine = [];
        this.sourceAndLineToPc.set(sourceAndLineKey, pcsForSourceAndLine);
      }
      const pcInLine = {
        pc,
        column: lastLocation.column
      };
      const pcLocation = {
        line: lastLocation.line,
        column: lastLocation.column,
        sourceIndex: lastLocation.sourceIndex
      };
      if (typeof nameDelta !== "undefined") {
        pcInLine.nameIndex = lastLocation.nameIndex;
        pcLocation.nameIndex = lastLocation.nameIndex;
      }
      pcsForSourceAndLine.push(pcInLine);
      this.pcToLocation.set(pc, pcLocation);
    }
  }
  getPcs() {
    return Array.from(this.pcToLocation.keys());
  }
  getLocationForPc(pc) {
    return this.pcToLocation.get(pc);
  }
  getPcsOnSourceLine(sourceIndex, line) {
    const pcs = this.sourceAndLineToPc.get(`${sourceIndex}:${line}`);
    if (pcs === void 0)
      return [];
    return pcs;
  }
};

// node_modules/algosdk/dist/esm/dryrun.js
var defaultAppId = 1380011588;
var defaultMaxWidth = 30;
async function createDryrun({ client, txns, protocolVersion, latestTimestamp, round, sources }) {
  const appInfos = [];
  const acctInfos = [];
  const apps = [];
  const assets = [];
  const accts = [];
  for (const t of txns) {
    if (t.txn.type === TransactionType.appl) {
      accts.push(t.txn.sender.toString());
      accts.push(...t.txn.applicationCall.accounts.map((a2) => a2.toString()));
      apps.push(...t.txn.applicationCall.foreignApps);
      accts.push(...t.txn.applicationCall.foreignApps.map(getApplicationAddress).map((a2) => a2.toString()));
      assets.push(...t.txn.applicationCall.foreignAssets);
      if (t.txn.applicationCall.appIndex === BigInt(0)) {
        appInfos.push(new Application({
          id: defaultAppId,
          params: new ApplicationParams({
            creator: t.txn.sender.toString(),
            approvalProgram: t.txn.applicationCall.approvalProgram,
            clearStateProgram: t.txn.applicationCall.clearProgram,
            localStateSchema: new ApplicationStateSchema({
              numUint: t.txn.applicationCall.numLocalInts,
              numByteSlice: t.txn.applicationCall.numLocalByteSlices
            }),
            globalStateSchema: new ApplicationStateSchema({
              numUint: t.txn.applicationCall.numGlobalInts,
              numByteSlice: t.txn.applicationCall.numGlobalByteSlices
            })
          })
        }));
      } else {
        const { appIndex } = t.txn.applicationCall;
        apps.push(appIndex);
        accts.push(getApplicationAddress(appIndex).toString());
      }
    }
  }
  const assetPromises = [];
  for (const assetId of new Set(assets)) {
    assetPromises.push(client.getAssetByID(assetId).do().then((assetInfo) => {
      accts.push(assetInfo.params.creator);
    }));
  }
  await Promise.all(assetPromises);
  const appPromises = [];
  for (const appId of new Set(apps)) {
    appPromises.push(client.getApplicationByID(appId).do().then((appInfo) => {
      appInfos.push(appInfo);
      accts.push(appInfo.params.creator.toString());
    }));
  }
  await Promise.all(appPromises);
  const acctPromises = [];
  for (const acct of new Set(accts)) {
    acctPromises.push(client.accountInformation(acct).do().then((acctInfo) => {
      acctInfos.push(acctInfo);
    }));
  }
  await Promise.all(acctPromises);
  return new DryrunRequest({
    txns: txns.slice(),
    accounts: acctInfos,
    apps: appInfos,
    latestTimestamp: latestTimestamp ?? 0,
    round: round ?? 0,
    protocolVersion: protocolVersion ?? "",
    sources: sources ?? []
  });
}
function truncate(str, maxValueWidth) {
  if (str.length > maxValueWidth && maxValueWidth > 0) {
    return `${str.slice(0, maxValueWidth)}...`;
  }
  return str;
}
function scratchToString(prevScratch, currScratch) {
  if (currScratch.length === 0)
    return "";
  let newScratchIdx = null;
  for (let idx = 0; idx < currScratch.length; idx++) {
    if (idx > prevScratch.length) {
      newScratchIdx = idx;
      continue;
    }
    if (stringifyJSON(prevScratch[idx]) !== stringifyJSON(currScratch[idx])) {
      newScratchIdx = idx;
    }
  }
  if (newScratchIdx == null)
    return "";
  const newScratch = currScratch[newScratchIdx];
  if (newScratch.bytes.length > 0) {
    return `${newScratchIdx} = 0x${bytesToHex(newScratch.bytes)}`;
  }
  return `${newScratchIdx} = ${newScratch.uint.toString()}`;
}
function stackToString(stack, reverse) {
  const svs = reverse ? stack.reverse() : stack;
  return `[${svs.map((sv) => {
    switch (sv.type) {
      case 1:
        return `0x${bytesToHex(sv.bytes)}`;
      case 2:
        return sv.uint.toString();
      default:
        return "";
    }
  }).join(", ")}]`;
}
function dryrunTrace(trace, disassembly, spc) {
  const maxWidth = spc.maxValueWidth || defaultMaxWidth;
  const lines = [["pc#", "ln#", "source", "scratch", "stack"]];
  for (let idx = 0; idx < trace.length; idx++) {
    const { line, error, pc, scratch, stack } = trace[idx];
    const currScratch = scratch !== void 0 ? scratch : [];
    const prevScratch = idx > 0 && trace[idx - 1].scratch !== void 0 ? trace[idx - 1].scratch : [];
    const src = !error ? disassembly[line] : `!! ${error} !!`;
    lines.push([
      pc.toString().padEnd(3, " "),
      line.toString().padEnd(3, " "),
      truncate(src, maxWidth),
      truncate(scratchToString(prevScratch, currScratch), maxWidth),
      truncate(stackToString(stack, spc.topOfStackFirst), maxWidth)
    ]);
  }
  const maxLengths = lines.reduce((prev, curr) => {
    const newVal = new Array(lines[0].length).fill(0);
    for (let idx = 0; idx < prev.length; idx++) {
      newVal[idx] = curr[idx].length > prev[idx] ? curr[idx].length : prev[idx];
    }
    return newVal;
  }, new Array(lines[0].length).fill(0));
  return `${lines.map((line) => line.map((v2, idx) => v2.padEnd(maxLengths[idx] + 1, " ")).join("|").trim()).join("\n")}
`;
}
function dryrunTxnResultAppTrace(result, spc) {
  if (!result.appCallTrace || !result.disassembly)
    return "";
  let conf = spc;
  if (spc !== void 0)
    conf = spc;
  else {
    conf = {
      maxValueWidth: defaultMaxWidth,
      topOfStackFirst: false
    };
  }
  return dryrunTrace(result.appCallTrace, result.disassembly, conf);
}
function dryrunTxnResultLogicSigTrace(result, spc) {
  if (!result.logicSigTrace || !result.logicSigDisassembly)
    return "";
  let conf;
  if (spc !== void 0)
    conf = spc;
  else {
    conf = {
      maxValueWidth: defaultMaxWidth,
      topOfStackFirst: true
    };
  }
  return dryrunTrace(result.logicSigTrace, result.logicSigDisassembly, conf);
}

// node_modules/algosdk/dist/esm/makeTxn.js
function makePaymentTxnWithSuggestedParamsFromObject({ sender, receiver, amount, closeRemainderTo, suggestedParams, note, lease, rekeyTo }) {
  return new Transaction({
    type: TransactionType.pay,
    sender,
    note,
    lease,
    rekeyTo,
    suggestedParams,
    paymentParams: {
      receiver,
      amount,
      closeRemainderTo
    }
  });
}
function makeKeyRegistrationTxnWithSuggestedParamsFromObject({ sender, voteKey, selectionKey, stateProofKey, voteFirst, voteLast, voteKeyDilution, nonParticipation, suggestedParams, note, lease, rekeyTo }) {
  return new Transaction({
    type: TransactionType.keyreg,
    sender,
    note,
    lease,
    rekeyTo,
    suggestedParams,
    keyregParams: {
      voteKey,
      selectionKey,
      stateProofKey,
      voteFirst,
      voteLast,
      voteKeyDilution,
      nonParticipation
    }
  });
}
function makeBaseAssetConfigTxn({ sender, assetIndex, total, decimals, defaultFrozen, manager, reserve, freeze, clawback, unitName, assetName, assetURL, assetMetadataHash, note, lease, rekeyTo, suggestedParams }) {
  return new Transaction({
    type: TransactionType.acfg,
    sender,
    note,
    lease,
    rekeyTo,
    suggestedParams,
    assetConfigParams: {
      assetIndex,
      total,
      decimals,
      defaultFrozen,
      manager,
      reserve,
      freeze,
      clawback,
      unitName,
      assetName,
      assetURL,
      assetMetadataHash
    }
  });
}
function makeAssetCreateTxnWithSuggestedParamsFromObject({ sender, total, decimals, defaultFrozen, manager, reserve, freeze, clawback, unitName, assetName, assetURL, assetMetadataHash, note, lease, rekeyTo, suggestedParams }) {
  return makeBaseAssetConfigTxn({
    sender,
    total,
    decimals,
    defaultFrozen,
    manager,
    reserve,
    freeze,
    clawback,
    unitName,
    assetName,
    assetURL,
    assetMetadataHash,
    note,
    lease,
    rekeyTo,
    suggestedParams
  });
}
function makeAssetConfigTxnWithSuggestedParamsFromObject({ sender, assetIndex, manager, reserve, freeze, clawback, strictEmptyAddressChecking, note, lease, rekeyTo, suggestedParams }) {
  if (!assetIndex) {
    throw Error("assetIndex must be provided");
  }
  const strictChecking = strictEmptyAddressChecking ?? true;
  if (strictChecking && (manager == null || reserve == null || freeze == null || clawback == null)) {
    throw Error("strictEmptyAddressChecking is enabled, but an address is empty. If this is intentional, set strictEmptyAddressChecking to false.");
  }
  return makeBaseAssetConfigTxn({
    sender,
    assetIndex,
    manager,
    reserve,
    freeze,
    clawback,
    note,
    lease,
    rekeyTo,
    suggestedParams
  });
}
function makeAssetDestroyTxnWithSuggestedParamsFromObject({ sender, assetIndex, note, lease, rekeyTo, suggestedParams }) {
  if (!assetIndex) {
    throw Error("assetIndex must be provided");
  }
  return makeBaseAssetConfigTxn({
    sender,
    assetIndex,
    note,
    lease,
    rekeyTo,
    suggestedParams
  });
}
function makeAssetFreezeTxnWithSuggestedParamsFromObject({ sender, assetIndex, freezeTarget, frozen, suggestedParams, note, lease, rekeyTo }) {
  return new Transaction({
    type: TransactionType.afrz,
    sender,
    note,
    lease,
    rekeyTo,
    suggestedParams,
    assetFreezeParams: {
      assetIndex,
      freezeTarget,
      frozen
    }
  });
}
function makeAssetTransferTxnWithSuggestedParamsFromObject({ sender, receiver, amount, closeRemainderTo, assetSender, note, assetIndex, suggestedParams, rekeyTo, lease }) {
  if (!assetIndex) {
    throw Error("assetIndex must be provided");
  }
  return new Transaction({
    type: TransactionType.axfer,
    sender,
    note,
    lease,
    rekeyTo,
    suggestedParams,
    assetTransferParams: {
      assetIndex,
      receiver,
      amount,
      assetSender,
      closeRemainderTo
    }
  });
}
function makeApplicationCallTxnFromObject({ sender, appIndex, onComplete, appArgs, accounts, foreignApps, foreignAssets, boxes, convertToAccess, holdings, locals, access, approvalProgram, clearProgram, numLocalInts, numLocalByteSlices, numGlobalInts, numGlobalByteSlices, extraPages, rejectVersion, note, lease, rekeyTo, suggestedParams }) {
  if (onComplete == null) {
    throw Error("onComplete must be provided");
  }
  if (access && (accounts || foreignApps || foreignAssets || boxes || holdings || locals)) {
    throw Error("cannot specify both access and other access fields");
  }
  let access2 = access;
  if (convertToAccess) {
    access2 = foreignArraysToResourceReferences({
      appIndex,
      accounts,
      foreignApps,
      foreignAssets,
      holdings,
      locals,
      boxes
    });
  }
  return new Transaction({
    type: TransactionType.appl,
    sender,
    note,
    lease,
    rekeyTo,
    suggestedParams,
    appCallParams: {
      appIndex,
      onComplete,
      appArgs,
      // Only pass legacy foreign arrays if access is not provided
      accounts: access2 ? void 0 : accounts,
      foreignAssets: access2 ? void 0 : foreignAssets,
      foreignApps: access2 ? void 0 : foreignApps,
      boxes: access2 ? void 0 : boxes,
      access: access2,
      approvalProgram,
      clearProgram,
      numLocalInts,
      numLocalByteSlices,
      numGlobalInts,
      numGlobalByteSlices,
      extraPages,
      rejectVersion
    }
  });
}
function makeApplicationCreateTxnFromObject({ sender, onComplete, appArgs, accounts, foreignApps, foreignAssets, boxes, convertToAccess, holdings, locals, access, approvalProgram, clearProgram, numLocalInts, numLocalByteSlices, numGlobalInts, numGlobalByteSlices, extraPages, note, lease, rekeyTo, suggestedParams }) {
  if (!approvalProgram || !clearProgram) {
    throw Error("approvalProgram and clearProgram must be provided");
  }
  if (onComplete == null) {
    throw Error("onComplete must be provided");
  }
  return makeApplicationCallTxnFromObject({
    sender,
    appIndex: 0,
    onComplete,
    appArgs,
    accounts,
    foreignApps,
    foreignAssets,
    boxes,
    convertToAccess,
    holdings,
    locals,
    access,
    approvalProgram,
    clearProgram,
    numLocalInts,
    numLocalByteSlices,
    numGlobalInts,
    numGlobalByteSlices,
    extraPages,
    note,
    lease,
    rekeyTo,
    suggestedParams
  });
}
function makeApplicationUpdateTxnFromObject({ sender, appIndex, appArgs, accounts, foreignApps, foreignAssets, boxes, convertToAccess, holdings, locals, access, approvalProgram, clearProgram, note, lease, rekeyTo, suggestedParams }) {
  if (!appIndex) {
    throw Error("appIndex must be provided");
  }
  if (!approvalProgram || !clearProgram) {
    throw Error("approvalProgram and clearProgram must be provided");
  }
  return makeApplicationCallTxnFromObject({
    sender,
    appIndex,
    onComplete: OnApplicationComplete.UpdateApplicationOC,
    appArgs,
    accounts,
    foreignApps,
    foreignAssets,
    boxes,
    convertToAccess,
    holdings,
    locals,
    access,
    approvalProgram,
    clearProgram,
    note,
    lease,
    rekeyTo,
    suggestedParams
  });
}
function makeApplicationDeleteTxnFromObject({ sender, appIndex, appArgs, accounts, foreignApps, foreignAssets, boxes, convertToAccess, holdings, locals, access, note, lease, rekeyTo, suggestedParams }) {
  if (!appIndex) {
    throw Error("appIndex must be provided");
  }
  return makeApplicationCallTxnFromObject({
    sender,
    appIndex,
    onComplete: OnApplicationComplete.DeleteApplicationOC,
    appArgs,
    accounts,
    foreignApps,
    foreignAssets,
    boxes,
    convertToAccess,
    holdings,
    locals,
    access,
    note,
    lease,
    rekeyTo,
    suggestedParams
  });
}
function makeApplicationOptInTxnFromObject({ sender, appIndex, appArgs, accounts, foreignApps, foreignAssets, boxes, convertToAccess, holdings, locals, access, note, lease, rekeyTo, suggestedParams }) {
  if (!appIndex) {
    throw Error("appIndex must be provided");
  }
  return makeApplicationCallTxnFromObject({
    sender,
    appIndex,
    onComplete: OnApplicationComplete.OptInOC,
    appArgs,
    accounts,
    foreignApps,
    foreignAssets,
    boxes,
    note,
    convertToAccess,
    holdings,
    locals,
    access,
    lease,
    rekeyTo,
    suggestedParams
  });
}
function makeApplicationCloseOutTxnFromObject({ sender, appIndex, appArgs, accounts, foreignApps, foreignAssets, boxes, convertToAccess, holdings, locals, access, note, lease, rekeyTo, suggestedParams }) {
  if (!appIndex) {
    throw Error("appIndex must be provided");
  }
  return makeApplicationCallTxnFromObject({
    sender,
    appIndex,
    onComplete: OnApplicationComplete.CloseOutOC,
    appArgs,
    accounts,
    foreignApps,
    foreignAssets,
    boxes,
    convertToAccess,
    holdings,
    locals,
    access,
    note,
    lease,
    rekeyTo,
    suggestedParams
  });
}
function makeApplicationClearStateTxnFromObject({ sender, appIndex, appArgs, accounts, foreignApps, foreignAssets, boxes, convertToAccess, holdings, locals, access, note, lease, rekeyTo, suggestedParams }) {
  if (!appIndex) {
    throw Error("appIndex must be provided");
  }
  return makeApplicationCallTxnFromObject({
    sender,
    appIndex,
    onComplete: OnApplicationComplete.ClearStateOC,
    appArgs,
    accounts,
    foreignApps,
    foreignAssets,
    boxes,
    convertToAccess,
    holdings,
    locals,
    access,
    note,
    lease,
    rekeyTo,
    suggestedParams
  });
}
function makeApplicationNoOpTxnFromObject({ sender, appIndex, appArgs, accounts, foreignApps, foreignAssets, boxes, convertToAccess, holdings, locals, access, note, lease, rekeyTo, suggestedParams }) {
  if (!appIndex) {
    throw Error("appIndex must be provided");
  }
  return makeApplicationCallTxnFromObject({
    sender,
    appIndex,
    onComplete: OnApplicationComplete.NoOpOC,
    appArgs,
    accounts,
    foreignApps,
    foreignAssets,
    boxes,
    convertToAccess,
    holdings,
    locals,
    access,
    note,
    lease,
    rekeyTo,
    suggestedParams
  });
}

// node_modules/algosdk/dist/esm/signer.js
function makeBasicAccountTransactionSigner(account) {
  return (txnGroup, indexesToSign) => {
    const signed = [];
    for (const index of indexesToSign) {
      signed.push(txnGroup[index].signTxn(account.sk));
    }
    return Promise.resolve(signed);
  };
}
function makeLogicSigAccountTransactionSigner(account) {
  return (txnGroup, indexesToSign) => {
    const signed = [];
    for (const index of indexesToSign) {
      const { blob } = signLogicSigTransactionObject(txnGroup[index], account);
      signed.push(blob);
    }
    return Promise.resolve(signed);
  };
}
function makeMultiSigAccountTransactionSigner(msig, sks) {
  return (txnGroup, indexesToSign) => {
    const signed = [];
    for (const index of indexesToSign) {
      const txn = txnGroup[index];
      const partialSigs = [];
      for (const sk of sks) {
        const { blob } = signMultisigTransaction(txn, msig, sk);
        partialSigs.push(blob);
      }
      if (partialSigs.length > 1) {
        signed.push(mergeMultisigTransactions(partialSigs));
      } else {
        signed.push(partialSigs[0]);
      }
    }
    return Promise.resolve(signed);
  };
}
function makeEmptyTransactionSigner() {
  return (txnGroup, indexesToSign) => {
    const unsigned = [];
    for (const index of indexesToSign) {
      unsigned.push(encodeUnsignedSimulateTransaction(txnGroup[index]));
    }
    return Promise.resolve(unsigned);
  };
}
function isTransactionWithSigner(value) {
  return typeof value === "object" && Object.keys(value).length === 2 && typeof value.txn === "object" && typeof value.signer === "function";
}

// node_modules/algosdk/dist/esm/abi/abi_type.js
var MAX_LEN = 2 ** 16 - 1;
var ADDR_BYTE_SIZE = 32;
var SINGLE_BYTE_SIZE = 1;
var SINGLE_BOOL_SIZE = 1;
var LENGTH_ENCODE_BYTE_SIZE = 2;
var staticArrayRegexp = /^([a-z\d[\](),]+)\[(0|[1-9][\d]*)]$/;
var ufixedRegexp = /^ufixed([1-9][\d]*)x([1-9][\d]*)$/;
var ABIType = class _ABIType {
  // De-serializes the ABI type from a string using the ABI specs
  static from(str) {
    if (str.endsWith("[]")) {
      const arrayArgType = _ABIType.from(str.slice(0, str.length - 2));
      return new ABIArrayDynamicType(arrayArgType);
    }
    if (str.endsWith("]")) {
      const stringMatches = str.match(staticArrayRegexp);
      if (!stringMatches || stringMatches.length !== 3) {
        throw new Error(`malformed static array string: ${str}`);
      }
      const arrayLengthStr = stringMatches[2];
      const arrayLength = parseInt(arrayLengthStr, 10);
      if (arrayLength > MAX_LEN) {
        throw new Error(`array length exceeds limit ${MAX_LEN}`);
      }
      const arrayType = _ABIType.from(stringMatches[1]);
      return new ABIArrayStaticType(arrayType, arrayLength);
    }
    if (str.startsWith("uint")) {
      const digitsOnly = (s2) => [...s2].every((c2) => "0123456789".includes(c2));
      const typeSizeStr = str.slice(4, str.length);
      if (!digitsOnly(typeSizeStr)) {
        throw new Error(`malformed uint string: ${typeSizeStr}`);
      }
      const typeSize = parseInt(typeSizeStr, 10);
      if (typeSize > MAX_LEN) {
        throw new Error(`malformed uint string: ${typeSize}`);
      }
      return new ABIUintType(typeSize);
    }
    if (str === "byte") {
      return new ABIByteType();
    }
    if (str.startsWith("ufixed")) {
      const stringMatches = str.match(ufixedRegexp);
      if (!stringMatches || stringMatches.length !== 3) {
        throw new Error(`malformed ufixed type: ${str}`);
      }
      const ufixedSize = parseInt(stringMatches[1], 10);
      const ufixedPrecision = parseInt(stringMatches[2], 10);
      return new ABIUfixedType(ufixedSize, ufixedPrecision);
    }
    if (str === "bool") {
      return new ABIBoolType();
    }
    if (str === "address") {
      return new ABIAddressType();
    }
    if (str === "string") {
      return new ABIStringType();
    }
    if (str.length >= 2 && str[0] === "(" && str[str.length - 1] === ")") {
      const tupleContent = ABITupleType.parseTupleContent(str.slice(1, str.length - 1));
      const tupleTypes = [];
      for (let i2 = 0; i2 < tupleContent.length; i2++) {
        const ti = _ABIType.from(tupleContent[i2]);
        tupleTypes.push(ti);
      }
      return new ABITupleType(tupleTypes);
    }
    throw new Error(`cannot convert a string ${str} to an ABI type`);
  }
};
var ABIUintType = class _ABIUintType extends ABIType {
  constructor(size) {
    super();
    if (size % 8 !== 0 || size < 8 || size > 512) {
      throw new Error(`unsupported uint type bitSize: ${size}`);
    }
    this.bitSize = size;
  }
  toString() {
    return `uint${this.bitSize}`;
  }
  equals(other) {
    return other instanceof _ABIUintType && this.bitSize === other.bitSize;
  }
  isDynamic() {
    return false;
  }
  byteLen() {
    return this.bitSize / 8;
  }
  encode(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new Error(`Cannot encode value as uint${this.bitSize}: ${value}`);
    }
    if (value >= BigInt(2 ** this.bitSize) || value < BigInt(0)) {
      throw new Error(`${value} is not a non-negative int or too big to fit in size uint${this.bitSize}`);
    }
    if (typeof value === "number" && !Number.isSafeInteger(value)) {
      throw new Error(`${value} should be converted into a BigInt before it is encoded`);
    }
    return bigIntToBytes(value, this.bitSize / 8);
  }
  decode(byteString) {
    if (byteString.length !== this.bitSize / 8) {
      throw new Error(`byte string must correspond to a uint${this.bitSize}`);
    }
    return bytesToBigInt(byteString);
  }
};
var ABIUfixedType = class _ABIUfixedType extends ABIType {
  constructor(size, denominator) {
    super();
    if (size % 8 !== 0 || size < 8 || size > 512) {
      throw new Error(`unsupported ufixed type bitSize: ${size}`);
    }
    if (denominator > 160 || denominator < 1) {
      throw new Error(`unsupported ufixed type precision: ${denominator}`);
    }
    this.bitSize = size;
    this.precision = denominator;
  }
  toString() {
    return `ufixed${this.bitSize}x${this.precision}`;
  }
  equals(other) {
    return other instanceof _ABIUfixedType && this.bitSize === other.bitSize && this.precision === other.precision;
  }
  isDynamic() {
    return false;
  }
  byteLen() {
    return this.bitSize / 8;
  }
  encode(value) {
    if (typeof value !== "bigint" && typeof value !== "number") {
      throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);
    }
    if (value >= BigInt(2 ** this.bitSize) || value < BigInt(0)) {
      throw new Error(`${value} is not a non-negative int or too big to fit in size ${this.toString()}`);
    }
    if (typeof value === "number" && !Number.isSafeInteger(value)) {
      throw new Error(`${value} should be converted into a BigInt before it is encoded`);
    }
    return bigIntToBytes(value, this.bitSize / 8);
  }
  decode(byteString) {
    if (byteString.length !== this.bitSize / 8) {
      throw new Error(`byte string must correspond to a ${this.toString()}`);
    }
    return bytesToBigInt(byteString);
  }
};
var ABIAddressType = class _ABIAddressType extends ABIType {
  toString() {
    return "address";
  }
  equals(other) {
    return other instanceof _ABIAddressType;
  }
  isDynamic() {
    return false;
  }
  byteLen() {
    return ADDR_BYTE_SIZE;
  }
  encode(value) {
    if (typeof value === "string") {
      const decodedAddress = decodeAddress(value);
      return decodedAddress.publicKey;
    }
    if (value instanceof Address) {
      return value.publicKey;
    }
    if (value instanceof Uint8Array) {
      if (value.byteLength !== 32) {
        throw new Error(`byte string must be 32 bytes long for an address`);
      }
      return value;
    }
    throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);
  }
  decode(byteString) {
    if (byteString.byteLength !== 32) {
      throw new Error(`byte string must be 32 bytes long for an address`);
    }
    return encodeAddress(byteString);
  }
};
var ABIBoolType = class _ABIBoolType extends ABIType {
  toString() {
    return "bool";
  }
  equals(other) {
    return other instanceof _ABIBoolType;
  }
  isDynamic() {
    return false;
  }
  byteLen() {
    return SINGLE_BOOL_SIZE;
  }
  encode(value) {
    if (typeof value !== "boolean") {
      throw new Error(`Cannot encode value as bool: ${value}`);
    }
    if (value) {
      return new Uint8Array([128]);
    }
    return new Uint8Array([0]);
  }
  decode(byteString) {
    if (byteString.byteLength !== 1) {
      throw new Error(`bool string must be 1 byte long`);
    }
    const value = byteString[0];
    if (value === 128) {
      return true;
    }
    if (value === 0) {
      return false;
    }
    throw new Error(`boolean could not be decoded from the byte string`);
  }
};
var ABIByteType = class _ABIByteType extends ABIType {
  toString() {
    return "byte";
  }
  equals(other) {
    return other instanceof _ABIByteType;
  }
  isDynamic() {
    return false;
  }
  byteLen() {
    return SINGLE_BYTE_SIZE;
  }
  encode(value) {
    if (typeof value !== "number" && typeof value !== "bigint") {
      throw new Error(`Cannot encode value as byte: ${value}`);
    }
    if (typeof value === "bigint") {
      value = Number(value);
    }
    if (value < 0 || value > 255) {
      throw new Error(`${value} cannot be encoded into a byte`);
    }
    return new Uint8Array([value]);
  }
  decode(byteString) {
    if (byteString.byteLength !== 1) {
      throw new Error(`byte string must be 1 byte long`);
    }
    return byteString[0];
  }
};
var ABIStringType = class _ABIStringType extends ABIType {
  toString() {
    return "string";
  }
  equals(other) {
    return other instanceof _ABIStringType;
  }
  isDynamic() {
    return true;
  }
  byteLen() {
    throw new Error(`${this.toString()} is a dynamic type`);
  }
  encode(value) {
    if (typeof value !== "string" && !(value instanceof Uint8Array)) {
      throw new Error(`Cannot encode value as string: ${value}`);
    }
    let encodedBytes;
    if (typeof value === "string") {
      encodedBytes = new TextEncoder().encode(value);
    } else {
      encodedBytes = value;
    }
    const encodedLength = bigIntToBytes(encodedBytes.length, LENGTH_ENCODE_BYTE_SIZE);
    const mergedBytes = new Uint8Array(encodedBytes.length + LENGTH_ENCODE_BYTE_SIZE);
    mergedBytes.set(encodedLength);
    mergedBytes.set(encodedBytes, LENGTH_ENCODE_BYTE_SIZE);
    return mergedBytes;
  }
  decode(byteString) {
    if (byteString.length < LENGTH_ENCODE_BYTE_SIZE) {
      throw new Error(`byte string is too short to be decoded. Actual length is ${byteString.length}, but expected at least ${LENGTH_ENCODE_BYTE_SIZE}`);
    }
    const view = new DataView(byteString.buffer, byteString.byteOffset, LENGTH_ENCODE_BYTE_SIZE);
    const byteLength = view.getUint16(0);
    const byteValue = byteString.slice(LENGTH_ENCODE_BYTE_SIZE, byteString.length);
    if (byteLength !== byteValue.length) {
      throw new Error(`string length bytes do not match the actual length of string. Expected ${byteLength}, got ${byteValue.length}`);
    }
    return new TextDecoder("utf-8").decode(byteValue);
  }
};
var ABIArrayStaticType = class _ABIArrayStaticType extends ABIType {
  constructor(argType, arrayLength) {
    super();
    if (arrayLength < 0) {
      throw new Error(`static array must have a non negative length: ${arrayLength}`);
    }
    this.childType = argType;
    this.staticLength = arrayLength;
  }
  toString() {
    return `${this.childType.toString()}[${this.staticLength}]`;
  }
  equals(other) {
    return other instanceof _ABIArrayStaticType && this.staticLength === other.staticLength && this.childType.equals(other.childType);
  }
  isDynamic() {
    return this.childType.isDynamic();
  }
  byteLen() {
    if (this.childType.constructor === ABIBoolType) {
      return Math.ceil(this.staticLength / 8);
    }
    return this.staticLength * this.childType.byteLen();
  }
  encode(value) {
    if (!Array.isArray(value) && !(value instanceof Uint8Array)) {
      throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);
    }
    if (value.length !== this.staticLength) {
      throw new Error(`Value array does not match static array length. Expected ${this.staticLength}, got ${value.length}`);
    }
    const convertedTuple = this.toABITupleType();
    return convertedTuple.encode(value);
  }
  decode(byteString) {
    const convertedTuple = this.toABITupleType();
    return convertedTuple.decode(byteString);
  }
  toABITupleType() {
    return new ABITupleType(Array(this.staticLength).fill(this.childType));
  }
};
var ABIArrayDynamicType = class _ABIArrayDynamicType extends ABIType {
  constructor(argType) {
    super();
    this.childType = argType;
  }
  toString() {
    return `${this.childType.toString()}[]`;
  }
  equals(other) {
    return other instanceof _ABIArrayDynamicType && this.childType.equals(other.childType);
  }
  isDynamic() {
    return true;
  }
  byteLen() {
    throw new Error(`${this.toString()} is a dynamic type`);
  }
  encode(value) {
    if (!Array.isArray(value) && !(value instanceof Uint8Array)) {
      throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);
    }
    const convertedTuple = this.toABITupleType(value.length);
    const encodedTuple = convertedTuple.encode(value);
    const encodedLength = bigIntToBytes(convertedTuple.childTypes.length, LENGTH_ENCODE_BYTE_SIZE);
    const mergedBytes = concatArrays2(encodedLength, encodedTuple);
    return mergedBytes;
  }
  decode(byteString) {
    const view = new DataView(byteString.buffer, 0, LENGTH_ENCODE_BYTE_SIZE);
    const byteLength = view.getUint16(0);
    const convertedTuple = this.toABITupleType(byteLength);
    return convertedTuple.decode(byteString.slice(LENGTH_ENCODE_BYTE_SIZE, byteString.length));
  }
  toABITupleType(length) {
    return new ABITupleType(Array(length).fill(this.childType));
  }
};
var ABITupleType = class _ABITupleType extends ABIType {
  constructor(argTypes) {
    super();
    if (argTypes.length >= MAX_LEN) {
      throw new Error("tuple type child type number larger than maximum uint16 error");
    }
    this.childTypes = argTypes;
  }
  toString() {
    const typeStrings = [];
    for (let i2 = 0; i2 < this.childTypes.length; i2++) {
      typeStrings[i2] = this.childTypes[i2].toString();
    }
    return `(${typeStrings.join(",")})`;
  }
  equals(other) {
    return other instanceof _ABITupleType && this.childTypes.length === other.childTypes.length && this.childTypes.every((child, index) => child.equals(other.childTypes[index]));
  }
  isDynamic() {
    const isDynamic = (child) => child.isDynamic();
    return this.childTypes.some(isDynamic);
  }
  byteLen() {
    let size = 0;
    for (let i2 = 0; i2 < this.childTypes.length; i2++) {
      if (this.childTypes[i2].constructor === ABIBoolType) {
        const after = findBoolLR(this.childTypes, i2, 1);
        const boolNum = after + 1;
        i2 += after;
        size += Math.trunc((boolNum + 7) / 8);
      } else {
        const childByteSize = this.childTypes[i2].byteLen();
        size += childByteSize;
      }
    }
    return size;
  }
  encode(value) {
    if (!Array.isArray(value) && !(value instanceof Uint8Array)) {
      throw new Error(`Cannot encode value as ${this.toString()}: ${value}`);
    }
    const values = Array.from(value);
    if (value.length > MAX_LEN) {
      throw new Error("length of tuple array should not exceed a uint16");
    }
    const tupleTypes = this.childTypes;
    const heads = [];
    const tails = [];
    const isDynamicIndex = /* @__PURE__ */ new Map();
    let i2 = 0;
    while (i2 < tupleTypes.length) {
      const tupleType = tupleTypes[i2];
      if (tupleType.isDynamic()) {
        isDynamicIndex.set(heads.length, true);
        heads.push(new Uint8Array([0, 0]));
        tails.push(tupleType.encode(values[i2]));
      } else {
        if (tupleType.constructor === ABIBoolType) {
          const before = findBoolLR(tupleTypes, i2, -1);
          let after = findBoolLR(tupleTypes, i2, 1);
          if (before % 8 !== 0) {
            throw new Error("expected before index should have number of bool mod 8 equal 0");
          }
          after = Math.min(7, after);
          const compressedInt = compressMultipleBool(values.slice(i2, i2 + after + 1));
          heads.push(bigIntToBytes(compressedInt, 1));
          i2 += after;
        } else {
          const encodedTupleValue = tupleType.encode(values[i2]);
          heads.push(encodedTupleValue);
        }
        isDynamicIndex.set(i2, false);
        tails.push(new Uint8Array());
      }
      i2 += 1;
    }
    let headLength = 0;
    for (const headElement of heads) {
      headLength += headElement.length;
    }
    let tailLength = 0;
    for (let j2 = 0; j2 < heads.length; j2++) {
      if (isDynamicIndex.get(j2)) {
        const headValue = headLength + tailLength;
        if (headValue > MAX_LEN) {
          throw new Error(`byte length of ${headValue} should not exceed a uint16`);
        }
        heads[j2] = bigIntToBytes(headValue, LENGTH_ENCODE_BYTE_SIZE);
      }
      tailLength += tails[j2].length;
    }
    return concatArrays2(...heads, ...tails);
  }
  decode(byteString) {
    const tupleTypes = this.childTypes;
    const dynamicSegments = [];
    const valuePartition = [];
    let i2 = 0;
    let iterIndex = 0;
    const view = new DataView(byteString.buffer);
    while (i2 < tupleTypes.length) {
      const tupleType = tupleTypes[i2];
      if (tupleType.isDynamic()) {
        if (byteString.slice(iterIndex, byteString.length).length < LENGTH_ENCODE_BYTE_SIZE) {
          throw new Error("dynamic type in tuple is too short to be decoded");
        }
        const dynamicIndex = view.getUint16(iterIndex);
        if (dynamicSegments.length > 0) {
          dynamicSegments[dynamicSegments.length - 1].right = dynamicIndex;
          if (dynamicIndex < dynamicSegments[dynamicSegments.length - 1].left) {
            throw new Error("dynamic index segment miscalculation: left is greater than right index");
          }
        }
        const seg = {
          left: dynamicIndex,
          right: -1
        };
        dynamicSegments.push(seg);
        valuePartition.push(null);
        iterIndex += LENGTH_ENCODE_BYTE_SIZE;
      } else {
        if (tupleType.constructor === ABIBoolType) {
          const before = findBoolLR(this.childTypes, i2, -1);
          let after = findBoolLR(this.childTypes, i2, 1);
          if (before % 8 !== 0) {
            throw new Error("expected before bool number mod 8 === 0");
          }
          after = Math.min(7, after);
          for (let boolIndex = 0; boolIndex <= after; boolIndex++) {
            const boolMask = 128 >> boolIndex;
            if ((byteString[iterIndex] & boolMask) > 0) {
              valuePartition.push(new Uint8Array([128]));
            } else {
              valuePartition.push(new Uint8Array([0]));
            }
          }
          i2 += after;
          iterIndex += 1;
        } else {
          const currLen = tupleType.byteLen();
          valuePartition.push(byteString.slice(iterIndex, iterIndex + currLen));
          iterIndex += currLen;
        }
      }
      if (i2 !== tupleTypes.length - 1 && iterIndex >= byteString.length) {
        throw new Error("input byte not enough to decode");
      }
      i2 += 1;
    }
    if (dynamicSegments.length > 0) {
      dynamicSegments[dynamicSegments.length - 1].right = byteString.length;
      iterIndex = byteString.length;
    }
    if (iterIndex < byteString.length) {
      throw new Error("input byte not fully consumed");
    }
    for (let j2 = 0; j2 < dynamicSegments.length; j2++) {
      const seg = dynamicSegments[j2];
      if (seg.left > seg.right) {
        throw new Error("dynamic segment should display a [l, r] space with l <= r");
      }
      if (j2 !== dynamicSegments.length - 1 && seg.right !== dynamicSegments[j2 + 1].left) {
        throw new Error("dynamic segment should be consecutive");
      }
    }
    let segIndex = 0;
    for (let j2 = 0; j2 < tupleTypes.length; j2++) {
      if (tupleTypes[j2].isDynamic()) {
        valuePartition[j2] = byteString.slice(dynamicSegments[segIndex].left, dynamicSegments[segIndex].right);
        segIndex += 1;
      }
    }
    const returnValues = [];
    for (let j2 = 0; j2 < tupleTypes.length; j2++) {
      const valueTi = tupleTypes[j2].decode(valuePartition[j2]);
      returnValues.push(valueTi);
    }
    return returnValues;
  }
  static parseTupleContent(str) {
    if (str.length === 0) {
      return [];
    }
    if (str.endsWith(",") || str.startsWith(",")) {
      throw new Error("tuple string should not start with comma");
    }
    if (str.includes(",,")) {
      throw new Error("tuple string should not have consecutive commas");
    }
    const tupleStrings = [];
    let depth = 0;
    let word = "";
    for (const char of str) {
      word += char;
      if (char === "(") {
        depth += 1;
      } else if (char === ")") {
        depth -= 1;
      } else if (char === ",") {
        if (depth === 0) {
          tupleStrings.push(word.slice(0, word.length - 1));
          word = "";
        }
      }
    }
    if (word.length !== 0) {
      tupleStrings.push(word);
    }
    if (depth !== 0) {
      throw new Error("tuple string has mismatched parentheses");
    }
    return tupleStrings;
  }
};
function compressMultipleBool(valueList) {
  let res = 0;
  if (valueList.length > 8) {
    throw new Error("value list passed in should be no greater than length 8");
  }
  for (let i2 = 0; i2 < valueList.length; i2++) {
    const boolVal = valueList[i2];
    if (typeof boolVal !== "boolean") {
      throw new Error("non-boolean values cannot be compressed into a byte");
    }
    if (boolVal) {
      res |= 1 << 7 - i2;
    }
  }
  return res;
}
function findBoolLR(typeList, index, delta) {
  let until = 0;
  while (true) {
    const curr = index + delta * until;
    if (typeList[curr].constructor === ABIBoolType) {
      if (curr !== typeList.length - 1 && delta === 1) {
        until += 1;
      } else if (curr > 0 && delta === -1) {
        until += 1;
      } else {
        break;
      }
    } else {
      until -= 1;
      break;
    }
  }
  return until;
}

// node_modules/algosdk/dist/esm/abi/transaction.js
var ABITransactionType;
(function(ABITransactionType2) {
  ABITransactionType2["any"] = "txn";
  ABITransactionType2["pay"] = "pay";
  ABITransactionType2["keyreg"] = "keyreg";
  ABITransactionType2["acfg"] = "acfg";
  ABITransactionType2["axfer"] = "axfer";
  ABITransactionType2["afrz"] = "afrz";
  ABITransactionType2["appl"] = "appl";
})(ABITransactionType || (ABITransactionType = {}));
function abiTypeIsTransaction(type) {
  return type === ABITransactionType.any || type === ABITransactionType.pay || type === ABITransactionType.keyreg || type === ABITransactionType.acfg || type === ABITransactionType.axfer || type === ABITransactionType.afrz || type === ABITransactionType.appl;
}
function abiCheckTransactionType(type, txn) {
  if (type === ABITransactionType.any) {
    return true;
  }
  return txn.type ? txn.type.toString() === type.toString() : false;
}

// node_modules/algosdk/dist/esm/abi/reference.js
var ABIReferenceType;
(function(ABIReferenceType2) {
  ABIReferenceType2["account"] = "account";
  ABIReferenceType2["application"] = "application";
  ABIReferenceType2["asset"] = "asset";
})(ABIReferenceType || (ABIReferenceType = {}));
function abiTypeIsReference(type) {
  return type === ABIReferenceType.account || type === ABIReferenceType.application || type === ABIReferenceType.asset;
}

// node_modules/algosdk/dist/esm/abi/method.js
function parseMethodSignature(signature) {
  const argsStart = signature.indexOf("(");
  if (argsStart === -1) {
    throw new Error(`Invalid method signature: ${signature}`);
  }
  let argsEnd = -1;
  let depth = 0;
  for (let i2 = argsStart; i2 < signature.length; i2++) {
    const char = signature[i2];
    if (char === "(") {
      depth += 1;
    } else if (char === ")") {
      if (depth === 0) {
        break;
      }
      depth -= 1;
      if (depth === 0) {
        argsEnd = i2;
        break;
      }
    }
  }
  if (argsEnd === -1) {
    throw new Error(`Invalid method signature: ${signature}`);
  }
  return {
    name: signature.slice(0, argsStart),
    args: ABITupleType.parseTupleContent(signature.slice(argsStart + 1, argsEnd)),
    returns: signature.slice(argsEnd + 1)
  };
}
var ABIMethod = class _ABIMethod {
  constructor(params) {
    if (typeof params.name !== "string" || typeof params.returns !== "object" || !Array.isArray(params.args)) {
      throw new Error("Invalid ABIMethod parameters");
    }
    this.name = params.name;
    this.description = params.desc;
    this.args = params.args.map(({ type, name, desc }) => {
      if (abiTypeIsTransaction(type) || abiTypeIsReference(type)) {
        return {
          type,
          name,
          description: desc
        };
      }
      return {
        type: ABIType.from(type),
        name,
        description: desc
      };
    });
    this.returns = {
      type: params.returns.type === "void" ? params.returns.type : ABIType.from(params.returns.type),
      description: params.returns.desc
    };
    this.events = params.events;
    this.readonly = params.readonly;
  }
  getSignature() {
    const args = this.args.map((arg) => arg.type.toString()).join(",");
    const returns = this.returns.type.toString();
    return `${this.name}(${args})${returns}`;
  }
  getSelector() {
    const hash = genericHash(this.getSignature());
    return new Uint8Array(hash.slice(0, 4));
  }
  txnCount() {
    let count = 1;
    for (const arg of this.args) {
      if (typeof arg.type === "string" && abiTypeIsTransaction(arg.type)) {
        count += 1;
      }
    }
    return count;
  }
  toJSON() {
    return {
      name: this.name,
      desc: this.description,
      args: this.args.map(({ type, name, description }) => ({
        type: type.toString(),
        name,
        desc: description
      })),
      returns: {
        type: this.returns.type.toString(),
        desc: this.returns.description
      },
      events: this.events,
      readonly: this.readonly
    };
  }
  static fromSignature(signature) {
    const { name, args, returns } = parseMethodSignature(signature);
    return new _ABIMethod({
      name,
      args: args.map((arg) => ({ type: arg })),
      returns: { type: returns }
    });
  }
};
function getMethodByName(methods, name) {
  if (methods === null || !Array.isArray(methods) || !methods.every((item) => item instanceof ABIMethod))
    throw new Error("Methods list provided is null or not the correct type");
  const filteredMethods = methods.filter((m2) => m2.name === name);
  if (filteredMethods.length > 1)
    throw new Error(`found ${filteredMethods.length} methods with the same name ${filteredMethods.map((m2) => m2.getSignature()).join(",")}`);
  if (filteredMethods.length === 0)
    throw new Error(`found 0 methods with the name ${name}`);
  return filteredMethods[0];
}

// node_modules/algosdk/dist/esm/abi/contract.js
var ABIContract = class {
  constructor(params) {
    if (typeof params.name !== "string" || !Array.isArray(params.methods) || params.networks && typeof params.networks !== "object") {
      throw new Error("Invalid ABIContract parameters");
    }
    this.name = params.name;
    this.description = params.desc;
    this.networks = params.networks ? { ...params.networks } : {};
    this.methods = params.methods.map((method) => new ABIMethod(method));
    this.events = params.events;
  }
  toJSON() {
    return {
      name: this.name,
      desc: this.description,
      networks: this.networks,
      methods: this.methods.map((method) => method.toJSON()),
      events: this.events
    };
  }
  getMethodByName(name) {
    return getMethodByName(this.methods, name);
  }
};

// node_modules/algosdk/dist/esm/abi/interface.js
var ABIInterface = class {
  constructor(params) {
    if (typeof params.name !== "string" || !Array.isArray(params.methods)) {
      throw new Error("Invalid ABIInterface parameters");
    }
    this.name = params.name;
    this.description = params.desc;
    this.methods = params.methods.map((method) => new ABIMethod(method));
  }
  toJSON() {
    return {
      name: this.name,
      desc: this.description,
      methods: this.methods.map((method) => method.toJSON())
    };
  }
  getMethodByName(name) {
    return getMethodByName(this.methods, name);
  }
};

// node_modules/algosdk/dist/esm/composer.js
var RETURN_PREFIX = new Uint8Array([21, 31, 124, 117]);
var MAX_APP_ARGS = 16;
var AtomicTransactionComposerStatus;
(function(AtomicTransactionComposerStatus2) {
  AtomicTransactionComposerStatus2[AtomicTransactionComposerStatus2["BUILDING"] = 0] = "BUILDING";
  AtomicTransactionComposerStatus2[AtomicTransactionComposerStatus2["BUILT"] = 1] = "BUILT";
  AtomicTransactionComposerStatus2[AtomicTransactionComposerStatus2["SIGNED"] = 2] = "SIGNED";
  AtomicTransactionComposerStatus2[AtomicTransactionComposerStatus2["SUBMITTED"] = 3] = "SUBMITTED";
  AtomicTransactionComposerStatus2[AtomicTransactionComposerStatus2["COMMITTED"] = 4] = "COMMITTED";
})(AtomicTransactionComposerStatus || (AtomicTransactionComposerStatus = {}));
function populateForeignArray(valueToAdd, array, zeroValue) {
  if (zeroValue != null && valueToAdd === zeroValue) {
    return 0;
  }
  const offset = zeroValue == null ? 0 : 1;
  for (let i2 = 0; i2 < array.length; i2++) {
    if (valueToAdd === array[i2]) {
      return i2 + offset;
    }
  }
  array.push(valueToAdd);
  return array.length - 1 + offset;
}
var AtomicTransactionComposer = class _AtomicTransactionComposer {
  constructor() {
    this.status = AtomicTransactionComposerStatus.BUILDING;
    this.transactions = [];
    this.methodCalls = /* @__PURE__ */ new Map();
    this.signedTxns = [];
    this.txIDs = [];
  }
  /**
   * Get the status of this composer's transaction group.
   */
  getStatus() {
    return this.status;
  }
  /**
   * Get the number of transactions currently in this atomic group.
   */
  count() {
    return this.transactions.length;
  }
  /**
   * Create a new composer with the same underlying transactions. The new composer's status will be
   * BUILDING, so additional transactions may be added to it.
   */
  clone() {
    const theClone = new _AtomicTransactionComposer();
    theClone.transactions = this.transactions.map(({ txn, signer }) => {
      const txnMap = txn.toEncodingData();
      txnMap.delete("grp");
      return {
        // not quite a deep copy, but good enough for our purposes (modifying txn.group in buildGroup)
        txn: Transaction.fromEncodingData(txnMap),
        signer
      };
    });
    theClone.methodCalls = new Map(this.methodCalls);
    return theClone;
  }
  /**
   * Add a transaction to this atomic group.
   *
   * An error will be thrown if the transaction has a nonzero group ID, the composer's status is
   * not BUILDING, or if adding this transaction causes the current group to exceed MAX_GROUP_SIZE.
   */
  addTransaction(txnAndSigner) {
    if (this.status !== AtomicTransactionComposerStatus.BUILDING) {
      throw new Error("Cannot add transactions when composer status is not BUILDING");
    }
    if (this.transactions.length === _AtomicTransactionComposer.MAX_GROUP_SIZE) {
      throw new Error(`Adding an additional transaction exceeds the maximum atomic group size of ${_AtomicTransactionComposer.MAX_GROUP_SIZE}`);
    }
    if (txnAndSigner.txn.group && txnAndSigner.txn.group.some((v2) => v2 !== 0)) {
      throw new Error("Cannot add a transaction with nonzero group ID");
    }
    this.transactions.push(txnAndSigner);
  }
  /**
   * Add a smart contract method call to this atomic group.
   *
   * An error will be thrown if the composer's status is not BUILDING, if adding this transaction
   * causes the current group to exceed MAX_GROUP_SIZE, or if the provided arguments are invalid
   * for the given method.
   */
  addMethodCall({ appID, method, methodArgs, sender, suggestedParams, onComplete, approvalProgram, clearProgram, numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices, extraPages, appAccounts, appForeignApps, appForeignAssets, boxes, access, note, lease, rekeyTo, rejectVersion, signer }) {
    if (this.status !== AtomicTransactionComposerStatus.BUILDING) {
      throw new Error("Cannot add transactions when composer status is not BUILDING");
    }
    if (this.transactions.length + method.txnCount() > _AtomicTransactionComposer.MAX_GROUP_SIZE) {
      throw new Error(`Adding additional transactions exceeds the maximum atomic group size of ${_AtomicTransactionComposer.MAX_GROUP_SIZE}`);
    }
    if (BigInt(appID) === BigInt(0)) {
      if (approvalProgram == null || clearProgram == null || numGlobalInts == null || numGlobalByteSlices == null || numLocalInts == null || numLocalByteSlices == null) {
        throw new Error("One of the following required parameters for application creation is missing: approvalProgram, clearProgram, numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices");
      }
    } else if (onComplete === OnApplicationComplete.UpdateApplicationOC) {
      if (approvalProgram == null || clearProgram == null) {
        throw new Error("One of the following required parameters for OnApplicationComplete.UpdateApplicationOC is missing: approvalProgram, clearProgram");
      }
      if (numGlobalInts != null || numGlobalByteSlices != null || numLocalInts != null || numLocalByteSlices != null || extraPages != null) {
        throw new Error("One of the following application creation parameters were set on a non-creation call: numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices, extraPages");
      }
    } else if (approvalProgram != null || clearProgram != null || numGlobalInts != null || numGlobalByteSlices != null || numLocalInts != null || numLocalByteSlices != null || extraPages != null) {
      throw new Error("One of the following application creation parameters were set on a non-creation call: approvalProgram, clearProgram, numGlobalInts, numGlobalByteSlices, numLocalInts, numLocalByteSlices, extraPages");
    }
    if (access && (appAccounts || appForeignApps || appForeignAssets || boxes)) {
      throw new Error("Cannot specify both access and legacy foreign arrays (appAccounts, appForeignApps, appForeignAssets, boxes)");
    }
    if (methodArgs == null) {
      methodArgs = [];
    }
    if (methodArgs.length !== method.args.length) {
      throw new Error(`Incorrect number of method arguments. Expected ${method.args.length}, got ${methodArgs.length}`);
    }
    let basicArgTypes = [];
    let basicArgValues = [];
    const txnArgs = [];
    const refArgTypes = [];
    const refArgValues = [];
    const refArgIndexToBasicArgIndex = /* @__PURE__ */ new Map();
    const boxReferences = !boxes ? [] : boxes;
    for (let i2 = 0; i2 < methodArgs.length; i2++) {
      let argType = method.args[i2].type;
      const argValue = methodArgs[i2];
      if (abiTypeIsTransaction(argType)) {
        if (!isTransactionWithSigner(argValue) || !abiCheckTransactionType(argType, argValue.txn)) {
          throw new Error(`Expected ${argType} TransactionWithSigner for argument at index ${i2}`);
        }
        if (argValue.txn.group && argValue.txn.group.some((v2) => v2 !== 0)) {
          throw new Error("Cannot add a transaction with nonzero group ID");
        }
        txnArgs.push(argValue);
        continue;
      }
      if (isTransactionWithSigner(argValue)) {
        throw new Error(`Expected non-transaction value for argument at index ${i2}`);
      }
      if (abiTypeIsReference(argType)) {
        refArgIndexToBasicArgIndex.set(refArgTypes.length, basicArgTypes.length);
        refArgTypes.push(argType);
        refArgValues.push(argValue);
        argType = new ABIUintType(8);
      }
      if (typeof argType === "string") {
        throw new Error(`Unknown ABI type: ${argType}`);
      }
      basicArgTypes.push(argType);
      basicArgValues.push(argValue);
    }
    const resolvedRefIndexes = [];
    const foreignAccounts = appAccounts == null ? [] : appAccounts.map((addr) => addr.toString());
    const foreignApps = appForeignApps == null ? [] : appForeignApps.map(ensureUint64);
    const foreignAssets = appForeignAssets == null ? [] : appForeignAssets.map(ensureUint64);
    for (let i2 = 0; i2 < refArgTypes.length; i2++) {
      const refType = refArgTypes[i2];
      const refValue = refArgValues[i2];
      let resolved = 0;
      switch (refType) {
        case ABIReferenceType.account: {
          const addressType = new ABIAddressType();
          const address = addressType.decode(addressType.encode(refValue));
          resolved = populateForeignArray(address, foreignAccounts, sender.toString());
          break;
        }
        case ABIReferenceType.application: {
          const uint64Type = new ABIUintType(64);
          const refAppID = uint64Type.decode(uint64Type.encode(refValue));
          if (refAppID > Number.MAX_SAFE_INTEGER) {
            throw new Error(`Expected safe integer for application value, got ${refAppID}`);
          }
          resolved = populateForeignArray(refAppID, foreignApps, ensureUint64(appID));
          break;
        }
        case ABIReferenceType.asset: {
          const uint64Type = new ABIUintType(64);
          const refAssetID = uint64Type.decode(uint64Type.encode(refValue));
          if (refAssetID > Number.MAX_SAFE_INTEGER) {
            throw new Error(`Expected safe integer for asset value, got ${refAssetID}`);
          }
          resolved = populateForeignArray(refAssetID, foreignAssets);
          break;
        }
        default:
          throw new Error(`Unknown reference type: ${refType}`);
      }
      resolvedRefIndexes.push(resolved);
    }
    for (let i2 = 0; i2 < resolvedRefIndexes.length; i2++) {
      const basicArgIndex = refArgIndexToBasicArgIndex.get(i2);
      basicArgValues[basicArgIndex] = resolvedRefIndexes[i2];
    }
    if (basicArgTypes.length > MAX_APP_ARGS - 1) {
      const lastArgTupleTypes = basicArgTypes.slice(MAX_APP_ARGS - 2);
      const lastArgTupleValues = basicArgValues.slice(MAX_APP_ARGS - 2);
      basicArgTypes = basicArgTypes.slice(0, MAX_APP_ARGS - 2);
      basicArgValues = basicArgValues.slice(0, MAX_APP_ARGS - 2);
      basicArgTypes.push(new ABITupleType(lastArgTupleTypes));
      basicArgValues.push(lastArgTupleValues);
    }
    const appArgsEncoded = [method.getSelector()];
    for (let i2 = 0; i2 < basicArgTypes.length; i2++) {
      appArgsEncoded.push(basicArgTypes[i2].encode(basicArgValues[i2]));
    }
    const appCall = {
      txn: makeApplicationCallTxnFromObject({
        sender,
        appIndex: appID,
        appArgs: appArgsEncoded,
        // Only pass legacy foreign arrays if access is not provided
        accounts: access ? void 0 : foreignAccounts,
        foreignApps: access ? void 0 : foreignApps,
        foreignAssets: access ? void 0 : foreignAssets,
        boxes: access ? void 0 : boxReferences,
        access,
        onComplete: onComplete == null ? OnApplicationComplete.NoOpOC : onComplete,
        approvalProgram,
        clearProgram,
        numGlobalInts,
        numGlobalByteSlices,
        numLocalInts,
        numLocalByteSlices,
        extraPages,
        rejectVersion,
        lease,
        note,
        rekeyTo,
        suggestedParams
      }),
      signer
    };
    this.transactions.push(...txnArgs, appCall);
    this.methodCalls.set(this.transactions.length - 1, method);
  }
  /**
   * Finalize the transaction group and returned the finalized transactions.
   *
   * The composer's status will be at least BUILT after executing this method.
   */
  buildGroup() {
    if (this.status === AtomicTransactionComposerStatus.BUILDING) {
      if (this.transactions.length === 0) {
        throw new Error("Cannot build a group with 0 transactions");
      }
      if (this.transactions.length > 1) {
        assignGroupID(this.transactions.map((txnWithSigner) => txnWithSigner.txn));
      }
      this.status = AtomicTransactionComposerStatus.BUILT;
    }
    return this.transactions;
  }
  /**
   * Obtain signatures for each transaction in this group. If signatures have already been obtained,
   * this method will return cached versions of the signatures.
   *
   * The composer's status will be at least SIGNED after executing this method.
   *
   * An error will be thrown if signing any of the transactions fails.
   *
   * @returns A promise that resolves to an array of signed transactions.
   */
  async gatherSignatures() {
    if (this.status >= AtomicTransactionComposerStatus.SIGNED) {
      return this.signedTxns;
    }
    const txnsWithSigners = this.buildGroup();
    const txnGroup = txnsWithSigners.map((txnWithSigner) => txnWithSigner.txn);
    const indexesPerSigner = /* @__PURE__ */ new Map();
    for (let i2 = 0; i2 < txnsWithSigners.length; i2++) {
      const { signer } = txnsWithSigners[i2];
      if (!indexesPerSigner.has(signer)) {
        indexesPerSigner.set(signer, []);
      }
      indexesPerSigner.get(signer).push(i2);
    }
    const orderedSigners = Array.from(indexesPerSigner);
    const batchedSigs = await Promise.all(orderedSigners.map(([signer, indexes]) => signer(txnGroup, indexes)));
    const signedTxns = txnsWithSigners.map(() => null);
    for (let signerIndex = 0; signerIndex < orderedSigners.length; signerIndex++) {
      const indexes = orderedSigners[signerIndex][1];
      const sigs = batchedSigs[signerIndex];
      for (let i2 = 0; i2 < indexes.length; i2++) {
        signedTxns[indexes[i2]] = sigs[i2];
      }
    }
    function fullyPopulated(a2) {
      return a2.every((v2) => v2 != null);
    }
    if (!fullyPopulated(signedTxns)) {
      throw new Error(`Missing signatures. Got ${signedTxns}`);
    }
    const txIDs = signedTxns.map((stxn, index) => {
      try {
        return decodeMsgpack(stxn, SignedTransaction).txn.txID();
      } catch (err) {
        throw new Error(`Cannot decode signed transaction at index ${index}. ${err}`);
      }
    });
    this.signedTxns = signedTxns;
    this.txIDs = txIDs;
    this.status = AtomicTransactionComposerStatus.SIGNED;
    return signedTxns;
  }
  /**
   * Send the transaction group to the network, but don't wait for it to be committed to a block. An
   * error will be thrown if submission fails.
   *
   * The composer's status must be SUBMITTED or lower before calling this method. If submission is
   * successful, this composer's status will update to SUBMITTED.
   *
   * Note: a group can only be submitted again if it fails.
   *
   * @param client - An Algodv2 client
   *
   * @returns A promise that, upon success, resolves to a list of TxIDs of the submitted transactions.
   */
  async submit(client) {
    if (this.status > AtomicTransactionComposerStatus.SUBMITTED) {
      throw new Error("Transaction group cannot be resubmitted");
    }
    const stxns = await this.gatherSignatures();
    await client.sendRawTransaction(stxns).do();
    this.status = AtomicTransactionComposerStatus.SUBMITTED;
    return this.txIDs;
  }
  /**
   * Simulates the transaction group in the network.
   *
   * The composer will try to sign any transactions in the group, then simulate
   * the results.
   * Simulating the group will not change the composer's status.
   *
   * @param client - An Algodv2 client
   * @param request - SimulateRequest with options in simulation.
   *   If provided, the request's transaction group will be overrwritten by the composer's group,
   *   only simulation related options will be used.
   *
   * @returns A promise that, upon success, resolves to an object containing an
   *   array of results containing one element for each method call transaction
   *   in this group (ABIResult[]) and the SimulateResponse object.
   */
  async simulate(client, request) {
    if (this.status > AtomicTransactionComposerStatus.SUBMITTED) {
      throw new Error("Simulated Transaction group has already been submitted to the network");
    }
    const stxns = await this.gatherSignatures();
    const txnObjects = stxns.map((stxn) => decodeMsgpack(stxn, SignedTransaction));
    const currentRequest = request == null ? new SimulateRequest({ txnGroups: [] }) : request;
    currentRequest.txnGroups = [
      new SimulateRequestTransactionGroup({
        txns: txnObjects
      })
    ];
    const simulateResponse = await client.simulateTransactions(currentRequest).do();
    const methodResults = [];
    for (const [txnIndex, method] of this.methodCalls) {
      const txID = this.txIDs[txnIndex];
      const pendingInfo = simulateResponse.txnGroups[0].txnResults[txnIndex].txnResult;
      const methodResult = {
        txID,
        rawReturnValue: new Uint8Array(),
        method
      };
      methodResults.push(_AtomicTransactionComposer.parseMethodResponse(method, methodResult, pendingInfo));
    }
    return { methodResults, simulateResponse };
  }
  /**
   * Send the transaction group to the network and wait until it's committed to a block. An error
   * will be thrown if submission or execution fails.
   *
   * The composer's status must be SUBMITTED or lower before calling this method, since execution is
   * only allowed once. If submission is successful, this composer's status will update to SUBMITTED.
   * If the execution is also successful, this composer's status will update to COMMITTED.
   *
   * Note: a group can only be submitted again if it fails.
   *
   * @param client - An Algodv2 client
   * @param waitRounds - The maximum number of rounds to wait for transaction confirmation
   *
   * @returns A promise that, upon success, resolves to an object containing the confirmed round for
   *   this transaction, the txIDs of the submitted transactions, and an array of results containing
   *   one element for each method call transaction in this group.
   */
  async execute(client, waitRounds) {
    if (this.status === AtomicTransactionComposerStatus.COMMITTED) {
      throw new Error("Transaction group has already been executed successfully");
    }
    const txIDs = await this.submit(client);
    this.status = AtomicTransactionComposerStatus.SUBMITTED;
    const firstMethodCallIndex = this.transactions.findIndex((_2, index) => this.methodCalls.has(index));
    const indexToWaitFor = firstMethodCallIndex === -1 ? 0 : firstMethodCallIndex;
    const confirmedTxnInfo = await waitForConfirmation(client, txIDs[indexToWaitFor], waitRounds);
    this.status = AtomicTransactionComposerStatus.COMMITTED;
    const confirmedRound = confirmedTxnInfo.confirmedRound;
    const methodResults = [];
    for (const [txnIndex, method] of this.methodCalls) {
      const txID = txIDs[txnIndex];
      let methodResult = {
        txID,
        rawReturnValue: new Uint8Array(),
        method
      };
      try {
        const pendingInfo = txnIndex === firstMethodCallIndex ? confirmedTxnInfo : (
          // eslint-disable-next-line no-await-in-loop
          await client.pendingTransactionInformation(txID).do()
        );
        methodResult = _AtomicTransactionComposer.parseMethodResponse(method, methodResult, pendingInfo);
      } catch (err) {
        methodResult.decodeError = err;
      }
      methodResults.push(methodResult);
    }
    return {
      confirmedRound,
      txIDs,
      methodResults
    };
  }
  /**
   * Parses a single ABI Method transaction log into a ABI result object.
   *
   * @param method
   * @param methodResult
   * @param pendingInfo
   * @returns An ABIResult object
   */
  static parseMethodResponse(method, methodResult, pendingInfo) {
    const returnedResult = methodResult;
    try {
      returnedResult.txInfo = pendingInfo;
      if (method.returns.type !== "void") {
        const logs = pendingInfo.logs || [];
        if (logs.length === 0) {
          throw new Error(`App call transaction did not log a return value ${stringifyJSON(pendingInfo)}`);
        }
        const lastLog = logs[logs.length - 1];
        if (lastLog.byteLength < 4 || !arrayEqual(lastLog.slice(0, 4), RETURN_PREFIX)) {
          throw new Error(`App call transaction did not log a ABI return value ${stringifyJSON(pendingInfo)}`);
        }
        returnedResult.rawReturnValue = new Uint8Array(lastLog.slice(4));
        returnedResult.returnValue = method.returns.type.decode(methodResult.rawReturnValue);
      }
    } catch (err) {
      returnedResult.decodeError = err;
    }
    return returnedResult;
  }
};
AtomicTransactionComposer.MAX_GROUP_SIZE = 16;

// node_modules/algosdk/dist/esm/main.js
var SIGN_BYTES_PREFIX = Uint8Array.from([77, 88]);
var MULTISIG_BAD_SENDER_ERROR_MSG = "The transaction sender address and multisig preimage do not match.";
function signTransaction(txn, sk) {
  return {
    txID: txn.txID(),
    blob: txn.signTxn(sk)
  };
}
function signBytes(bytes, sk) {
  const toBeSigned = concatArrays2(SIGN_BYTES_PREFIX, bytes);
  const sig = sign(toBeSigned, sk);
  return sig;
}
function verifyBytes(bytes, signature, addr) {
  const toBeVerified = concatArrays2(SIGN_BYTES_PREFIX, bytes);
  const addrObj = typeof addr === "string" ? Address.fromString(addr) : addr;
  return verify(toBeVerified, signature, addrObj.publicKey);
}
var ERROR_MULTISIG_BAD_SENDER = new Error(MULTISIG_BAD_SENDER_ERROR_MSG);
var ERROR_INVALID_MICROALGOS = new Error(INVALID_MICROALGOS_ERROR_MSG);

// node_modules/algosdk/dist/esm/index.js
var esm_default4 = main_exports;

// node_modules/bowser/src/constants.js
var BROWSER_ALIASES_MAP = {
  "Amazon Silk": "amazon_silk",
  "Android Browser": "android",
  Bada: "bada",
  BlackBerry: "blackberry",
  Chrome: "chrome",
  Chromium: "chromium",
  Electron: "electron",
  Epiphany: "epiphany",
  Firefox: "firefox",
  Focus: "focus",
  Generic: "generic",
  "Google Search": "google_search",
  Googlebot: "googlebot",
  "Internet Explorer": "ie",
  "K-Meleon": "k_meleon",
  Maxthon: "maxthon",
  "Microsoft Edge": "edge",
  "MZ Browser": "mz",
  "NAVER Whale Browser": "naver",
  Opera: "opera",
  "Opera Coast": "opera_coast",
  PhantomJS: "phantomjs",
  Puffin: "puffin",
  QupZilla: "qupzilla",
  QQ: "qq",
  QQLite: "qqlite",
  Safari: "safari",
  Sailfish: "sailfish",
  "Samsung Internet for Android": "samsung_internet",
  SeaMonkey: "seamonkey",
  Sleipnir: "sleipnir",
  Swing: "swing",
  Tizen: "tizen",
  "UC Browser": "uc",
  Vivaldi: "vivaldi",
  "WebOS Browser": "webos",
  WeChat: "wechat",
  "Yandex Browser": "yandex",
  Roku: "roku"
};
var BROWSER_MAP = {
  amazon_silk: "Amazon Silk",
  android: "Android Browser",
  bada: "Bada",
  blackberry: "BlackBerry",
  chrome: "Chrome",
  chromium: "Chromium",
  electron: "Electron",
  epiphany: "Epiphany",
  firefox: "Firefox",
  focus: "Focus",
  generic: "Generic",
  googlebot: "Googlebot",
  google_search: "Google Search",
  ie: "Internet Explorer",
  k_meleon: "K-Meleon",
  maxthon: "Maxthon",
  edge: "Microsoft Edge",
  mz: "MZ Browser",
  naver: "NAVER Whale Browser",
  opera: "Opera",
  opera_coast: "Opera Coast",
  phantomjs: "PhantomJS",
  puffin: "Puffin",
  qupzilla: "QupZilla",
  qq: "QQ Browser",
  qqlite: "QQ Browser Lite",
  safari: "Safari",
  sailfish: "Sailfish",
  samsung_internet: "Samsung Internet for Android",
  seamonkey: "SeaMonkey",
  sleipnir: "Sleipnir",
  swing: "Swing",
  tizen: "Tizen",
  uc: "UC Browser",
  vivaldi: "Vivaldi",
  webos: "WebOS Browser",
  wechat: "WeChat",
  yandex: "Yandex Browser"
};
var PLATFORMS_MAP = {
  tablet: "tablet",
  mobile: "mobile",
  desktop: "desktop",
  tv: "tv"
};
var OS_MAP = {
  WindowsPhone: "Windows Phone",
  Windows: "Windows",
  MacOS: "macOS",
  iOS: "iOS",
  Android: "Android",
  WebOS: "WebOS",
  BlackBerry: "BlackBerry",
  Bada: "Bada",
  Tizen: "Tizen",
  Linux: "Linux",
  ChromeOS: "Chrome OS",
  PlayStation4: "PlayStation 4",
  Roku: "Roku"
};
var ENGINE_MAP = {
  EdgeHTML: "EdgeHTML",
  Blink: "Blink",
  Trident: "Trident",
  Presto: "Presto",
  Gecko: "Gecko",
  WebKit: "WebKit"
};

// node_modules/bowser/src/utils.js
var Utils = class _Utils {
  /**
   * Get first matched item for a string
   * @param {RegExp} regexp
   * @param {String} ua
   * @return {Array|{index: number, input: string}|*|boolean|string}
   */
  static getFirstMatch(regexp, ua) {
    const match = ua.match(regexp);
    return match && match.length > 0 && match[1] || "";
  }
  /**
   * Get second matched item for a string
   * @param regexp
   * @param {String} ua
   * @return {Array|{index: number, input: string}|*|boolean|string}
   */
  static getSecondMatch(regexp, ua) {
    const match = ua.match(regexp);
    return match && match.length > 1 && match[2] || "";
  }
  /**
   * Match a regexp and return a constant or undefined
   * @param {RegExp} regexp
   * @param {String} ua
   * @param {*} _const Any const that will be returned if regexp matches the string
   * @return {*}
   */
  static matchAndReturnConst(regexp, ua, _const) {
    if (regexp.test(ua)) {
      return _const;
    }
    return void 0;
  }
  static getWindowsVersionName(version) {
    switch (version) {
      case "NT":
        return "NT";
      case "XP":
        return "XP";
      case "NT 5.0":
        return "2000";
      case "NT 5.1":
        return "XP";
      case "NT 5.2":
        return "2003";
      case "NT 6.0":
        return "Vista";
      case "NT 6.1":
        return "7";
      case "NT 6.2":
        return "8";
      case "NT 6.3":
        return "8.1";
      case "NT 10.0":
        return "10";
      default:
        return void 0;
    }
  }
  /**
   * Get macOS version name
   *    10.5 - Leopard
   *    10.6 - Snow Leopard
   *    10.7 - Lion
   *    10.8 - Mountain Lion
   *    10.9 - Mavericks
   *    10.10 - Yosemite
   *    10.11 - El Capitan
   *    10.12 - Sierra
   *    10.13 - High Sierra
   *    10.14 - Mojave
   *    10.15 - Catalina
   *
   * @example
   *   getMacOSVersionName("10.14") // 'Mojave'
   *
   * @param  {string} version
   * @return {string} versionName
   */
  static getMacOSVersionName(version) {
    const v2 = version.split(".").splice(0, 2).map((s2) => parseInt(s2, 10) || 0);
    v2.push(0);
    if (v2[0] !== 10) return void 0;
    switch (v2[1]) {
      case 5:
        return "Leopard";
      case 6:
        return "Snow Leopard";
      case 7:
        return "Lion";
      case 8:
        return "Mountain Lion";
      case 9:
        return "Mavericks";
      case 10:
        return "Yosemite";
      case 11:
        return "El Capitan";
      case 12:
        return "Sierra";
      case 13:
        return "High Sierra";
      case 14:
        return "Mojave";
      case 15:
        return "Catalina";
      default:
        return void 0;
    }
  }
  /**
   * Get Android version name
   *    1.5 - Cupcake
   *    1.6 - Donut
   *    2.0 - Eclair
   *    2.1 - Eclair
   *    2.2 - Froyo
   *    2.x - Gingerbread
   *    3.x - Honeycomb
   *    4.0 - Ice Cream Sandwich
   *    4.1 - Jelly Bean
   *    4.4 - KitKat
   *    5.x - Lollipop
   *    6.x - Marshmallow
   *    7.x - Nougat
   *    8.x - Oreo
   *    9.x - Pie
   *
   * @example
   *   getAndroidVersionName("7.0") // 'Nougat'
   *
   * @param  {string} version
   * @return {string} versionName
   */
  static getAndroidVersionName(version) {
    const v2 = version.split(".").splice(0, 2).map((s2) => parseInt(s2, 10) || 0);
    v2.push(0);
    if (v2[0] === 1 && v2[1] < 5) return void 0;
    if (v2[0] === 1 && v2[1] < 6) return "Cupcake";
    if (v2[0] === 1 && v2[1] >= 6) return "Donut";
    if (v2[0] === 2 && v2[1] < 2) return "Eclair";
    if (v2[0] === 2 && v2[1] === 2) return "Froyo";
    if (v2[0] === 2 && v2[1] > 2) return "Gingerbread";
    if (v2[0] === 3) return "Honeycomb";
    if (v2[0] === 4 && v2[1] < 1) return "Ice Cream Sandwich";
    if (v2[0] === 4 && v2[1] < 4) return "Jelly Bean";
    if (v2[0] === 4 && v2[1] >= 4) return "KitKat";
    if (v2[0] === 5) return "Lollipop";
    if (v2[0] === 6) return "Marshmallow";
    if (v2[0] === 7) return "Nougat";
    if (v2[0] === 8) return "Oreo";
    if (v2[0] === 9) return "Pie";
    return void 0;
  }
  /**
   * Get version precisions count
   *
   * @example
   *   getVersionPrecision("1.10.3") // 3
   *
   * @param  {string} version
   * @return {number}
   */
  static getVersionPrecision(version) {
    return version.split(".").length;
  }
  /**
   * Calculate browser version weight
   *
   * @example
   *   compareVersions('1.10.2.1',  '1.8.2.1.90')    // 1
   *   compareVersions('1.010.2.1', '1.09.2.1.90');  // 1
   *   compareVersions('1.10.2.1',  '1.10.2.1');     // 0
   *   compareVersions('1.10.2.1',  '1.0800.2');     // -1
   *   compareVersions('1.10.2.1',  '1.10',  true);  // 0
   *
   * @param {String} versionA versions versions to compare
   * @param {String} versionB versions versions to compare
   * @param {boolean} [isLoose] enable loose comparison
   * @return {Number} comparison result: -1 when versionA is lower,
   * 1 when versionA is bigger, 0 when both equal
   */
  /* eslint consistent-return: 1 */
  static compareVersions(versionA, versionB, isLoose = false) {
    const versionAPrecision = _Utils.getVersionPrecision(versionA);
    const versionBPrecision = _Utils.getVersionPrecision(versionB);
    let precision = Math.max(versionAPrecision, versionBPrecision);
    let lastPrecision = 0;
    const chunks = _Utils.map([versionA, versionB], (version) => {
      const delta = precision - _Utils.getVersionPrecision(version);
      const _version = version + new Array(delta + 1).join(".0");
      return _Utils.map(_version.split("."), (chunk) => new Array(20 - chunk.length).join("0") + chunk).reverse();
    });
    if (isLoose) {
      lastPrecision = precision - Math.min(versionAPrecision, versionBPrecision);
    }
    precision -= 1;
    while (precision >= lastPrecision) {
      if (chunks[0][precision] > chunks[1][precision]) {
        return 1;
      }
      if (chunks[0][precision] === chunks[1][precision]) {
        if (precision === lastPrecision) {
          return 0;
        }
        precision -= 1;
      } else if (chunks[0][precision] < chunks[1][precision]) {
        return -1;
      }
    }
    return void 0;
  }
  /**
   * Array::map polyfill
   *
   * @param  {Array} arr
   * @param  {Function} iterator
   * @return {Array}
   */
  static map(arr, iterator) {
    const result = [];
    let i2;
    if (Array.prototype.map) {
      return Array.prototype.map.call(arr, iterator);
    }
    for (i2 = 0; i2 < arr.length; i2 += 1) {
      result.push(iterator(arr[i2]));
    }
    return result;
  }
  /**
   * Array::find polyfill
   *
   * @param  {Array} arr
   * @param  {Function} predicate
   * @return {Array}
   */
  static find(arr, predicate) {
    let i2;
    let l2;
    if (Array.prototype.find) {
      return Array.prototype.find.call(arr, predicate);
    }
    for (i2 = 0, l2 = arr.length; i2 < l2; i2 += 1) {
      const value = arr[i2];
      if (predicate(value, i2)) {
        return value;
      }
    }
    return void 0;
  }
  /**
   * Object::assign polyfill
   *
   * @param  {Object} obj
   * @param  {Object} ...objs
   * @return {Object}
   */
  static assign(obj, ...assigners) {
    const result = obj;
    let i2;
    let l2;
    if (Object.assign) {
      return Object.assign(obj, ...assigners);
    }
    for (i2 = 0, l2 = assigners.length; i2 < l2; i2 += 1) {
      const assigner = assigners[i2];
      if (typeof assigner === "object" && assigner !== null) {
        const keys = Object.keys(assigner);
        keys.forEach((key) => {
          result[key] = assigner[key];
        });
      }
    }
    return obj;
  }
  /**
   * Get short version/alias for a browser name
   *
   * @example
   *   getBrowserAlias('Microsoft Edge') // edge
   *
   * @param  {string} browserName
   * @return {string}
   */
  static getBrowserAlias(browserName) {
    return BROWSER_ALIASES_MAP[browserName];
  }
  /**
   * Get short version/alias for a browser name
   *
   * @example
   *   getBrowserAlias('edge') // Microsoft Edge
   *
   * @param  {string} browserAlias
   * @return {string}
   */
  static getBrowserTypeByAlias(browserAlias) {
    return BROWSER_MAP[browserAlias] || "";
  }
};

// node_modules/bowser/src/parser-browsers.js
var commonVersionIdentifier = /version\/(\d+(\.?_?\d+)+)/i;
var browsersList = [
  /* Googlebot */
  {
    test: [/googlebot/i],
    describe(ua) {
      const browser = {
        name: "Googlebot"
      };
      const version = Utils.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  /* Opera < 13.0 */
  {
    test: [/opera/i],
    describe(ua) {
      const browser = {
        name: "Opera"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  /* Opera > 13.0 */
  {
    test: [/opr\/|opios/i],
    describe(ua) {
      const browser = {
        name: "Opera"
      };
      const version = Utils.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/SamsungBrowser/i],
    describe(ua) {
      const browser = {
        name: "Samsung Internet for Android"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/Whale/i],
    describe(ua) {
      const browser = {
        name: "NAVER Whale Browser"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/MZBrowser/i],
    describe(ua) {
      const browser = {
        name: "MZ Browser"
      };
      const version = Utils.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/focus/i],
    describe(ua) {
      const browser = {
        name: "Focus"
      };
      const version = Utils.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/swing/i],
    describe(ua) {
      const browser = {
        name: "Swing"
      };
      const version = Utils.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/coast/i],
    describe(ua) {
      const browser = {
        name: "Opera Coast"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/opt\/\d+(?:.?_?\d+)+/i],
    describe(ua) {
      const browser = {
        name: "Opera Touch"
      };
      const version = Utils.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/yabrowser/i],
    describe(ua) {
      const browser = {
        name: "Yandex Browser"
      };
      const version = Utils.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/ucbrowser/i],
    describe(ua) {
      const browser = {
        name: "UC Browser"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/Maxthon|mxios/i],
    describe(ua) {
      const browser = {
        name: "Maxthon"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/epiphany/i],
    describe(ua) {
      const browser = {
        name: "Epiphany"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/puffin/i],
    describe(ua) {
      const browser = {
        name: "Puffin"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/sleipnir/i],
    describe(ua) {
      const browser = {
        name: "Sleipnir"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/k-meleon/i],
    describe(ua) {
      const browser = {
        name: "K-Meleon"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/micromessenger/i],
    describe(ua) {
      const browser = {
        name: "WeChat"
      };
      const version = Utils.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/qqbrowser/i],
    describe(ua) {
      const browser = {
        name: /qqbrowserlite/i.test(ua) ? "QQ Browser Lite" : "QQ Browser"
      };
      const version = Utils.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/msie|trident/i],
    describe(ua) {
      const browser = {
        name: "Internet Explorer"
      };
      const version = Utils.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/\sedg\//i],
    describe(ua) {
      const browser = {
        name: "Microsoft Edge"
      };
      const version = Utils.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/edg([ea]|ios)/i],
    describe(ua) {
      const browser = {
        name: "Microsoft Edge"
      };
      const version = Utils.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/vivaldi/i],
    describe(ua) {
      const browser = {
        name: "Vivaldi"
      };
      const version = Utils.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/seamonkey/i],
    describe(ua) {
      const browser = {
        name: "SeaMonkey"
      };
      const version = Utils.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/sailfish/i],
    describe(ua) {
      const browser = {
        name: "Sailfish"
      };
      const version = Utils.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/silk/i],
    describe(ua) {
      const browser = {
        name: "Amazon Silk"
      };
      const version = Utils.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/phantom/i],
    describe(ua) {
      const browser = {
        name: "PhantomJS"
      };
      const version = Utils.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/slimerjs/i],
    describe(ua) {
      const browser = {
        name: "SlimerJS"
      };
      const version = Utils.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
    describe(ua) {
      const browser = {
        name: "BlackBerry"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/(web|hpw)[o0]s/i],
    describe(ua) {
      const browser = {
        name: "WebOS Browser"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/bada/i],
    describe(ua) {
      const browser = {
        name: "Bada"
      };
      const version = Utils.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/tizen/i],
    describe(ua) {
      const browser = {
        name: "Tizen"
      };
      const version = Utils.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/qupzilla/i],
    describe(ua) {
      const browser = {
        name: "QupZilla"
      };
      const version = Utils.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/firefox|iceweasel|fxios/i],
    describe(ua) {
      const browser = {
        name: "Firefox"
      };
      const version = Utils.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/electron/i],
    describe(ua) {
      const browser = {
        name: "Electron"
      };
      const version = Utils.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/MiuiBrowser/i],
    describe(ua) {
      const browser = {
        name: "Miui"
      };
      const version = Utils.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/chromium/i],
    describe(ua) {
      const browser = {
        name: "Chromium"
      };
      const version = Utils.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/chrome|crios|crmo/i],
    describe(ua) {
      const browser = {
        name: "Chrome"
      };
      const version = Utils.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  {
    test: [/GSA/i],
    describe(ua) {
      const browser = {
        name: "Google Search"
      };
      const version = Utils.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  /* Android Browser */
  {
    test(parser) {
      const notLikeAndroid = !parser.test(/like android/i);
      const butAndroid = parser.test(/android/i);
      return notLikeAndroid && butAndroid;
    },
    describe(ua) {
      const browser = {
        name: "Android Browser"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  /* PlayStation 4 */
  {
    test: [/playstation 4/i],
    describe(ua) {
      const browser = {
        name: "PlayStation 4"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  /* Safari */
  {
    test: [/safari|applewebkit/i],
    describe(ua) {
      const browser = {
        name: "Safari"
      };
      const version = Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version) {
        browser.version = version;
      }
      return browser;
    }
  },
  /* Something else */
  {
    test: [/.*/i],
    describe(ua) {
      const regexpWithoutDeviceSpec = /^(.*)\/(.*) /;
      const regexpWithDeviceSpec = /^(.*)\/(.*)[ \t]\((.*)/;
      const hasDeviceSpec = ua.search("\\(") !== -1;
      const regexp = hasDeviceSpec ? regexpWithDeviceSpec : regexpWithoutDeviceSpec;
      return {
        name: Utils.getFirstMatch(regexp, ua),
        version: Utils.getSecondMatch(regexp, ua)
      };
    }
  }
];
var parser_browsers_default = browsersList;

// node_modules/bowser/src/parser-os.js
var parser_os_default = [
  /* Roku */
  {
    test: [/Roku\/DVP/],
    describe(ua) {
      const version = Utils.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, ua);
      return {
        name: OS_MAP.Roku,
        version
      };
    }
  },
  /* Windows Phone */
  {
    test: [/windows phone/i],
    describe(ua) {
      const version = Utils.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, ua);
      return {
        name: OS_MAP.WindowsPhone,
        version
      };
    }
  },
  /* Windows */
  {
    test: [/windows /i],
    describe(ua) {
      const version = Utils.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, ua);
      const versionName = Utils.getWindowsVersionName(version);
      return {
        name: OS_MAP.Windows,
        version,
        versionName
      };
    }
  },
  /* Firefox on iPad */
  {
    test: [/Macintosh(.*?) FxiOS(.*?)\//],
    describe(ua) {
      const result = {
        name: OS_MAP.iOS
      };
      const version = Utils.getSecondMatch(/(Version\/)(\d[\d.]+)/, ua);
      if (version) {
        result.version = version;
      }
      return result;
    }
  },
  /* macOS */
  {
    test: [/macintosh/i],
    describe(ua) {
      const version = Utils.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, ua).replace(/[_\s]/g, ".");
      const versionName = Utils.getMacOSVersionName(version);
      const os = {
        name: OS_MAP.MacOS,
        version
      };
      if (versionName) {
        os.versionName = versionName;
      }
      return os;
    }
  },
  /* iOS */
  {
    test: [/(ipod|iphone|ipad)/i],
    describe(ua) {
      const version = Utils.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, ua).replace(/[_\s]/g, ".");
      return {
        name: OS_MAP.iOS,
        version
      };
    }
  },
  /* Android */
  {
    test(parser) {
      const notLikeAndroid = !parser.test(/like android/i);
      const butAndroid = parser.test(/android/i);
      return notLikeAndroid && butAndroid;
    },
    describe(ua) {
      const version = Utils.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, ua);
      const versionName = Utils.getAndroidVersionName(version);
      const os = {
        name: OS_MAP.Android,
        version
      };
      if (versionName) {
        os.versionName = versionName;
      }
      return os;
    }
  },
  /* WebOS */
  {
    test: [/(web|hpw)[o0]s/i],
    describe(ua) {
      const version = Utils.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, ua);
      const os = {
        name: OS_MAP.WebOS
      };
      if (version && version.length) {
        os.version = version;
      }
      return os;
    }
  },
  /* BlackBerry */
  {
    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
    describe(ua) {
      const version = Utils.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, ua) || Utils.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, ua) || Utils.getFirstMatch(/\bbb(\d+)/i, ua);
      return {
        name: OS_MAP.BlackBerry,
        version
      };
    }
  },
  /* Bada */
  {
    test: [/bada/i],
    describe(ua) {
      const version = Utils.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, ua);
      return {
        name: OS_MAP.Bada,
        version
      };
    }
  },
  /* Tizen */
  {
    test: [/tizen/i],
    describe(ua) {
      const version = Utils.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, ua);
      return {
        name: OS_MAP.Tizen,
        version
      };
    }
  },
  /* Linux */
  {
    test: [/linux/i],
    describe() {
      return {
        name: OS_MAP.Linux
      };
    }
  },
  /* Chrome OS */
  {
    test: [/CrOS/],
    describe() {
      return {
        name: OS_MAP.ChromeOS
      };
    }
  },
  /* Playstation 4 */
  {
    test: [/PlayStation 4/],
    describe(ua) {
      const version = Utils.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, ua);
      return {
        name: OS_MAP.PlayStation4,
        version
      };
    }
  }
];

// node_modules/bowser/src/parser-platforms.js
var parser_platforms_default = [
  /* Googlebot */
  {
    test: [/googlebot/i],
    describe() {
      return {
        type: "bot",
        vendor: "Google"
      };
    }
  },
  /* Huawei */
  {
    test: [/huawei/i],
    describe(ua) {
      const model = Utils.getFirstMatch(/(can-l01)/i, ua) && "Nova";
      const platform = {
        type: PLATFORMS_MAP.mobile,
        vendor: "Huawei"
      };
      if (model) {
        platform.model = model;
      }
      return platform;
    }
  },
  /* Nexus Tablet */
  {
    test: [/nexus\s*(?:7|8|9|10).*/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Nexus"
      };
    }
  },
  /* iPad */
  {
    test: [/ipad/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Apple",
        model: "iPad"
      };
    }
  },
  /* Firefox on iPad */
  {
    test: [/Macintosh(.*?) FxiOS(.*?)\//],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Apple",
        model: "iPad"
      };
    }
  },
  /* Amazon Kindle Fire */
  {
    test: [/kftt build/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Amazon",
        model: "Kindle Fire HD 7"
      };
    }
  },
  /* Another Amazon Tablet with Silk */
  {
    test: [/silk/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Amazon"
      };
    }
  },
  /* Tablet */
  {
    test: [/tablet(?! pc)/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet
      };
    }
  },
  /* iPod/iPhone */
  {
    test(parser) {
      const iDevice = parser.test(/ipod|iphone/i);
      const likeIDevice = parser.test(/like (ipod|iphone)/i);
      return iDevice && !likeIDevice;
    },
    describe(ua) {
      const model = Utils.getFirstMatch(/(ipod|iphone)/i, ua);
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "Apple",
        model
      };
    }
  },
  /* Nexus Mobile */
  {
    test: [/nexus\s*[0-6].*/i, /galaxy nexus/i],
    describe() {
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "Nexus"
      };
    }
  },
  /* Mobile */
  {
    test: [/[^-]mobi/i],
    describe() {
      return {
        type: PLATFORMS_MAP.mobile
      };
    }
  },
  /* BlackBerry */
  {
    test(parser) {
      return parser.getBrowserName(true) === "blackberry";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "BlackBerry"
      };
    }
  },
  /* Bada */
  {
    test(parser) {
      return parser.getBrowserName(true) === "bada";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile
      };
    }
  },
  /* Windows Phone */
  {
    test(parser) {
      return parser.getBrowserName() === "windows phone";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "Microsoft"
      };
    }
  },
  /* Android Tablet */
  {
    test(parser) {
      const osMajorVersion = Number(String(parser.getOSVersion()).split(".")[0]);
      return parser.getOSName(true) === "android" && osMajorVersion >= 3;
    },
    describe() {
      return {
        type: PLATFORMS_MAP.tablet
      };
    }
  },
  /* Android Mobile */
  {
    test(parser) {
      return parser.getOSName(true) === "android";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile
      };
    }
  },
  /* desktop */
  {
    test(parser) {
      return parser.getOSName(true) === "macos";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.desktop,
        vendor: "Apple"
      };
    }
  },
  /* Windows */
  {
    test(parser) {
      return parser.getOSName(true) === "windows";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.desktop
      };
    }
  },
  /* Linux */
  {
    test(parser) {
      return parser.getOSName(true) === "linux";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.desktop
      };
    }
  },
  /* PlayStation 4 */
  {
    test(parser) {
      return parser.getOSName(true) === "playstation 4";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.tv
      };
    }
  },
  /* Roku */
  {
    test(parser) {
      return parser.getOSName(true) === "roku";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.tv
      };
    }
  }
];

// node_modules/bowser/src/parser-engines.js
var parser_engines_default = [
  /* EdgeHTML */
  {
    test(parser) {
      return parser.getBrowserName(true) === "microsoft edge";
    },
    describe(ua) {
      const isBlinkBased = /\sedg\//i.test(ua);
      if (isBlinkBased) {
        return {
          name: ENGINE_MAP.Blink
        };
      }
      const version = Utils.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, ua);
      return {
        name: ENGINE_MAP.EdgeHTML,
        version
      };
    }
  },
  /* Trident */
  {
    test: [/trident/i],
    describe(ua) {
      const engine = {
        name: ENGINE_MAP.Trident
      };
      const version = Utils.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        engine.version = version;
      }
      return engine;
    }
  },
  /* Presto */
  {
    test(parser) {
      return parser.test(/presto/i);
    },
    describe(ua) {
      const engine = {
        name: ENGINE_MAP.Presto
      };
      const version = Utils.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        engine.version = version;
      }
      return engine;
    }
  },
  /* Gecko */
  {
    test(parser) {
      const isGecko = parser.test(/gecko/i);
      const likeGecko = parser.test(/like gecko/i);
      return isGecko && !likeGecko;
    },
    describe(ua) {
      const engine = {
        name: ENGINE_MAP.Gecko
      };
      const version = Utils.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        engine.version = version;
      }
      return engine;
    }
  },
  /* Blink */
  {
    test: [/(apple)?webkit\/537\.36/i],
    describe() {
      return {
        name: ENGINE_MAP.Blink
      };
    }
  },
  /* WebKit */
  {
    test: [/(apple)?webkit/i],
    describe(ua) {
      const engine = {
        name: ENGINE_MAP.WebKit
      };
      const version = Utils.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, ua);
      if (version) {
        engine.version = version;
      }
      return engine;
    }
  }
];

// node_modules/bowser/src/parser.js
var Parser = class {
  /**
   * Create instance of Parser
   *
   * @param {String} UA User-Agent string
   * @param {Boolean} [skipParsing=false] parser can skip parsing in purpose of performance
   * improvements if you need to make a more particular parsing
   * like {@link Parser#parseBrowser} or {@link Parser#parsePlatform}
   *
   * @throw {Error} in case of empty UA String
   *
   * @constructor
   */
  constructor(UA, skipParsing = false) {
    if (UA === void 0 || UA === null || UA === "") {
      throw new Error("UserAgent parameter can't be empty");
    }
    this._ua = UA;
    this.parsedResult = {};
    if (skipParsing !== true) {
      this.parse();
    }
  }
  /**
   * Get UserAgent string of current Parser instance
   * @return {String} User-Agent String of the current <Parser> object
   *
   * @public
   */
  getUA() {
    return this._ua;
  }
  /**
   * Test a UA string for a regexp
   * @param {RegExp} regex
   * @return {Boolean}
   */
  test(regex) {
    return regex.test(this._ua);
  }
  /**
   * Get parsed browser object
   * @return {Object}
   */
  parseBrowser() {
    this.parsedResult.browser = {};
    const browserDescriptor = Utils.find(parser_browsers_default, (_browser) => {
      if (typeof _browser.test === "function") {
        return _browser.test(this);
      }
      if (_browser.test instanceof Array) {
        return _browser.test.some((condition) => this.test(condition));
      }
      throw new Error("Browser's test function is not valid");
    });
    if (browserDescriptor) {
      this.parsedResult.browser = browserDescriptor.describe(this.getUA());
    }
    return this.parsedResult.browser;
  }
  /**
   * Get parsed browser object
   * @return {Object}
   *
   * @public
   */
  getBrowser() {
    if (this.parsedResult.browser) {
      return this.parsedResult.browser;
    }
    return this.parseBrowser();
  }
  /**
   * Get browser's name
   * @return {String} Browser's name or an empty string
   *
   * @public
   */
  getBrowserName(toLowerCase) {
    if (toLowerCase) {
      return String(this.getBrowser().name).toLowerCase() || "";
    }
    return this.getBrowser().name || "";
  }
  /**
   * Get browser's version
   * @return {String} version of browser
   *
   * @public
   */
  getBrowserVersion() {
    return this.getBrowser().version;
  }
  /**
   * Get OS
   * @return {Object}
   *
   * @example
   * this.getOS();
   * {
   *   name: 'macOS',
   *   version: '10.11.12'
   * }
   */
  getOS() {
    if (this.parsedResult.os) {
      return this.parsedResult.os;
    }
    return this.parseOS();
  }
  /**
   * Parse OS and save it to this.parsedResult.os
   * @return {*|{}}
   */
  parseOS() {
    this.parsedResult.os = {};
    const os = Utils.find(parser_os_default, (_os) => {
      if (typeof _os.test === "function") {
        return _os.test(this);
      }
      if (_os.test instanceof Array) {
        return _os.test.some((condition) => this.test(condition));
      }
      throw new Error("Browser's test function is not valid");
    });
    if (os) {
      this.parsedResult.os = os.describe(this.getUA());
    }
    return this.parsedResult.os;
  }
  /**
   * Get OS name
   * @param {Boolean} [toLowerCase] return lower-cased value
   * @return {String} name of the OS — macOS, Windows, Linux, etc.
   */
  getOSName(toLowerCase) {
    const { name } = this.getOS();
    if (toLowerCase) {
      return String(name).toLowerCase() || "";
    }
    return name || "";
  }
  /**
   * Get OS version
   * @return {String} full version with dots ('10.11.12', '5.6', etc)
   */
  getOSVersion() {
    return this.getOS().version;
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  getPlatform() {
    if (this.parsedResult.platform) {
      return this.parsedResult.platform;
    }
    return this.parsePlatform();
  }
  /**
   * Get platform name
   * @param {Boolean} [toLowerCase=false]
   * @return {*}
   */
  getPlatformType(toLowerCase = false) {
    const { type } = this.getPlatform();
    if (toLowerCase) {
      return String(type).toLowerCase() || "";
    }
    return type || "";
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  parsePlatform() {
    this.parsedResult.platform = {};
    const platform = Utils.find(parser_platforms_default, (_platform) => {
      if (typeof _platform.test === "function") {
        return _platform.test(this);
      }
      if (_platform.test instanceof Array) {
        return _platform.test.some((condition) => this.test(condition));
      }
      throw new Error("Browser's test function is not valid");
    });
    if (platform) {
      this.parsedResult.platform = platform.describe(this.getUA());
    }
    return this.parsedResult.platform;
  }
  /**
   * Get parsed engine
   * @return {{}}
   */
  getEngine() {
    if (this.parsedResult.engine) {
      return this.parsedResult.engine;
    }
    return this.parseEngine();
  }
  /**
   * Get engines's name
   * @return {String} Engines's name or an empty string
   *
   * @public
   */
  getEngineName(toLowerCase) {
    if (toLowerCase) {
      return String(this.getEngine().name).toLowerCase() || "";
    }
    return this.getEngine().name || "";
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  parseEngine() {
    this.parsedResult.engine = {};
    const engine = Utils.find(parser_engines_default, (_engine) => {
      if (typeof _engine.test === "function") {
        return _engine.test(this);
      }
      if (_engine.test instanceof Array) {
        return _engine.test.some((condition) => this.test(condition));
      }
      throw new Error("Browser's test function is not valid");
    });
    if (engine) {
      this.parsedResult.engine = engine.describe(this.getUA());
    }
    return this.parsedResult.engine;
  }
  /**
   * Parse full information about the browser
   * @returns {Parser}
   */
  parse() {
    this.parseBrowser();
    this.parseOS();
    this.parsePlatform();
    this.parseEngine();
    return this;
  }
  /**
   * Get parsed result
   * @return {ParsedResult}
   */
  getResult() {
    return Utils.assign({}, this.parsedResult);
  }
  /**
   * Check if parsed browser matches certain conditions
   *
   * @param {Object} checkTree It's one or two layered object,
   * which can include a platform or an OS on the first layer
   * and should have browsers specs on the bottom-laying layer
   *
   * @returns {Boolean|undefined} Whether the browser satisfies the set conditions or not.
   * Returns `undefined` when the browser is no described in the checkTree object.
   *
   * @example
   * const browser = Bowser.getParser(window.navigator.userAgent);
   * if (browser.satisfies({chrome: '>118.01.1322' }))
   * // or with os
   * if (browser.satisfies({windows: { chrome: '>118.01.1322' } }))
   * // or with platforms
   * if (browser.satisfies({desktop: { chrome: '>118.01.1322' } }))
   */
  satisfies(checkTree) {
    const platformsAndOSes = {};
    let platformsAndOSCounter = 0;
    const browsers = {};
    let browsersCounter = 0;
    const allDefinitions = Object.keys(checkTree);
    allDefinitions.forEach((key) => {
      const currentDefinition = checkTree[key];
      if (typeof currentDefinition === "string") {
        browsers[key] = currentDefinition;
        browsersCounter += 1;
      } else if (typeof currentDefinition === "object") {
        platformsAndOSes[key] = currentDefinition;
        platformsAndOSCounter += 1;
      }
    });
    if (platformsAndOSCounter > 0) {
      const platformsAndOSNames = Object.keys(platformsAndOSes);
      const OSMatchingDefinition = Utils.find(platformsAndOSNames, (name) => this.isOS(name));
      if (OSMatchingDefinition) {
        const osResult = this.satisfies(platformsAndOSes[OSMatchingDefinition]);
        if (osResult !== void 0) {
          return osResult;
        }
      }
      const platformMatchingDefinition = Utils.find(
        platformsAndOSNames,
        (name) => this.isPlatform(name)
      );
      if (platformMatchingDefinition) {
        const platformResult = this.satisfies(platformsAndOSes[platformMatchingDefinition]);
        if (platformResult !== void 0) {
          return platformResult;
        }
      }
    }
    if (browsersCounter > 0) {
      const browserNames = Object.keys(browsers);
      const matchingDefinition = Utils.find(browserNames, (name) => this.isBrowser(name, true));
      if (matchingDefinition !== void 0) {
        return this.compareVersion(browsers[matchingDefinition]);
      }
    }
    return void 0;
  }
  /**
   * Check if the browser name equals the passed string
   * @param browserName The string to compare with the browser name
   * @param [includingAlias=false] The flag showing whether alias will be included into comparison
   * @returns {boolean}
   */
  isBrowser(browserName, includingAlias = false) {
    const defaultBrowserName = this.getBrowserName().toLowerCase();
    let browserNameLower = browserName.toLowerCase();
    const alias = Utils.getBrowserTypeByAlias(browserNameLower);
    if (includingAlias && alias) {
      browserNameLower = alias.toLowerCase();
    }
    return browserNameLower === defaultBrowserName;
  }
  compareVersion(version) {
    let expectedResults = [0];
    let comparableVersion = version;
    let isLoose = false;
    const currentBrowserVersion = this.getBrowserVersion();
    if (typeof currentBrowserVersion !== "string") {
      return void 0;
    }
    if (version[0] === ">" || version[0] === "<") {
      comparableVersion = version.substr(1);
      if (version[1] === "=") {
        isLoose = true;
        comparableVersion = version.substr(2);
      } else {
        expectedResults = [];
      }
      if (version[0] === ">") {
        expectedResults.push(1);
      } else {
        expectedResults.push(-1);
      }
    } else if (version[0] === "=") {
      comparableVersion = version.substr(1);
    } else if (version[0] === "~") {
      isLoose = true;
      comparableVersion = version.substr(1);
    }
    return expectedResults.indexOf(
      Utils.compareVersions(currentBrowserVersion, comparableVersion, isLoose)
    ) > -1;
  }
  isOS(osName) {
    return this.getOSName(true) === String(osName).toLowerCase();
  }
  isPlatform(platformType) {
    return this.getPlatformType(true) === String(platformType).toLowerCase();
  }
  isEngine(engineName) {
    return this.getEngineName(true) === String(engineName).toLowerCase();
  }
  /**
   * Is anything? Check if the browser is called "anything",
   * the OS called "anything" or the platform called "anything"
   * @param {String} anything
   * @param [includingAlias=false] The flag showing whether alias will be included into comparison
   * @returns {Boolean}
   */
  is(anything, includingAlias = false) {
    return this.isBrowser(anything, includingAlias) || this.isOS(anything) || this.isPlatform(anything);
  }
  /**
   * Check if any of the given values satisfies this.is(anything)
   * @param {String[]} anythings
   * @returns {Boolean}
   */
  some(anythings = []) {
    return anythings.some((anything) => this.is(anything));
  }
};
var parser_default = Parser;

// node_modules/bowser/src/bowser.js
var Bowser = class {
  /**
   * Creates a {@link Parser} instance
   *
   * @param {String} UA UserAgent string
   * @param {Boolean} [skipParsing=false] Will make the Parser postpone parsing until you ask it
   * explicitly. Same as `skipParsing` for {@link Parser}.
   * @returns {Parser}
   * @throws {Error} when UA is not a String
   *
   * @example
   * const parser = Bowser.getParser(window.navigator.userAgent);
   * const result = parser.getResult();
   */
  static getParser(UA, skipParsing = false) {
    if (typeof UA !== "string") {
      throw new Error("UserAgent should be a string");
    }
    return new parser_default(UA, skipParsing);
  }
  /**
   * Creates a {@link Parser} instance and runs {@link Parser.getResult} immediately
   *
   * @param UA
   * @return {ParsedResult}
   *
   * @example
   * const result = Bowser.parse(window.navigator.userAgent);
   */
  static parse(UA) {
    return new parser_default(UA).getResult();
  }
  static get BROWSER_MAP() {
    return BROWSER_MAP;
  }
  static get ENGINE_MAP() {
    return ENGINE_MAP;
  }
  static get OS_MAP() {
    return OS_MAP;
  }
  static get PLATFORMS_MAP() {
    return PLATFORMS_MAP;
  }
};
var bowser_default = Bowser;

// node_modules/@perawallet/connect/dist/index-87e811df.js
var r2 = "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {};
var o2 = [];
var i = [];
var s = "undefined" != typeof Uint8Array ? Uint8Array : Array;
var a = false;
function l() {
  a = true;
  for (var t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", e2 = 0; e2 < 64; ++e2) o2[e2] = t[e2], i[t.charCodeAt(e2)] = e2;
  i["-".charCodeAt(0)] = 62, i["_".charCodeAt(0)] = 63;
}
function u(t, e2, n2) {
  for (var r3, i2, s2 = [], a2 = e2; a2 < n2; a2 += 3) r3 = (t[a2] << 16) + (t[a2 + 1] << 8) + t[a2 + 2], s2.push(o2[(i2 = r3) >> 18 & 63] + o2[i2 >> 12 & 63] + o2[i2 >> 6 & 63] + o2[63 & i2]);
  return s2.join("");
}
function c(t) {
  var e2;
  a || l();
  for (var n2 = t.length, r3 = n2 % 3, i2 = "", s2 = [], c2 = 16383, h2 = 0, f2 = n2 - r3; h2 < f2; h2 += c2) s2.push(u(t, h2, h2 + c2 > f2 ? f2 : h2 + c2));
  return 1 === r3 ? (e2 = t[n2 - 1], i2 += o2[e2 >> 2], i2 += o2[e2 << 4 & 63], i2 += "==") : 2 === r3 && (e2 = (t[n2 - 2] << 8) + t[n2 - 1], i2 += o2[e2 >> 10], i2 += o2[e2 >> 4 & 63], i2 += o2[e2 << 2 & 63], i2 += "="), s2.push(i2), s2.join("");
}
function h(t, e2, n2, r3, o3) {
  var i2, s2, a2 = 8 * o3 - r3 - 1, l2 = (1 << a2) - 1, u2 = l2 >> 1, c2 = -7, h2 = n2 ? o3 - 1 : 0, f2 = n2 ? -1 : 1, d2 = t[e2 + h2];
  for (h2 += f2, i2 = d2 & (1 << -c2) - 1, d2 >>= -c2, c2 += a2; c2 > 0; i2 = 256 * i2 + t[e2 + h2], h2 += f2, c2 -= 8) ;
  for (s2 = i2 & (1 << -c2) - 1, i2 >>= -c2, c2 += r3; c2 > 0; s2 = 256 * s2 + t[e2 + h2], h2 += f2, c2 -= 8) ;
  if (0 === i2) i2 = 1 - u2;
  else {
    if (i2 === l2) return s2 ? NaN : 1 / 0 * (d2 ? -1 : 1);
    s2 += Math.pow(2, r3), i2 -= u2;
  }
  return (d2 ? -1 : 1) * s2 * Math.pow(2, i2 - r3);
}
function f(t, e2, n2, r3, o3, i2) {
  var s2, a2, l2, u2 = 8 * i2 - o3 - 1, c2 = (1 << u2) - 1, h2 = c2 >> 1, f2 = 23 === o3 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, d2 = r3 ? 0 : i2 - 1, p2 = r3 ? 1 : -1, g2 = e2 < 0 || 0 === e2 && 1 / e2 < 0 ? 1 : 0;
  for (e2 = Math.abs(e2), isNaN(e2) || e2 === 1 / 0 ? (a2 = isNaN(e2) ? 1 : 0, s2 = c2) : (s2 = Math.floor(Math.log(e2) / Math.LN2), e2 * (l2 = Math.pow(2, -s2)) < 1 && (s2--, l2 *= 2), (e2 += s2 + h2 >= 1 ? f2 / l2 : f2 * Math.pow(2, 1 - h2)) * l2 >= 2 && (s2++, l2 /= 2), s2 + h2 >= c2 ? (a2 = 0, s2 = c2) : s2 + h2 >= 1 ? (a2 = (e2 * l2 - 1) * Math.pow(2, o3), s2 += h2) : (a2 = e2 * Math.pow(2, h2 - 1) * Math.pow(2, o3), s2 = 0)); o3 >= 8; t[n2 + d2] = 255 & a2, d2 += p2, a2 /= 256, o3 -= 8) ;
  for (s2 = s2 << o3 | a2, u2 += o3; u2 > 0; t[n2 + d2] = 255 & s2, d2 += p2, s2 /= 256, u2 -= 8) ;
  t[n2 + d2 - p2] |= 128 * g2;
}
var d = {}.toString;
var p = Array.isArray || function(t) {
  return "[object Array]" == d.call(t);
};
function g() {
  return y.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function w(t, e2) {
  if (g() < e2) throw new RangeError("Invalid typed array length");
  return y.TYPED_ARRAY_SUPPORT ? (t = new Uint8Array(e2)).__proto__ = y.prototype : (null === t && (t = new y(e2)), t.length = e2), t;
}
function y(t, e2, n2) {
  if (!(y.TYPED_ARRAY_SUPPORT || this instanceof y)) return new y(t, e2, n2);
  if ("number" == typeof t) {
    if ("string" == typeof e2) throw new Error("If encoding is specified then the first argument must be a string");
    return b(this, t);
  }
  return v(this, t, e2, n2);
}
function v(t, e2, n2, r3) {
  if ("number" == typeof e2) throw new TypeError('"value" argument must not be a number');
  return "undefined" != typeof ArrayBuffer && e2 instanceof ArrayBuffer ? (function(t2, e3, n3, r4) {
    if (e3.byteLength, n3 < 0 || e3.byteLength < n3) throw new RangeError("'offset' is out of bounds");
    if (e3.byteLength < n3 + (r4 || 0)) throw new RangeError("'length' is out of bounds");
    e3 = void 0 === n3 && void 0 === r4 ? new Uint8Array(e3) : void 0 === r4 ? new Uint8Array(e3, n3) : new Uint8Array(e3, n3, r4);
    y.TYPED_ARRAY_SUPPORT ? (t2 = e3).__proto__ = y.prototype : t2 = A(t2, e3);
    return t2;
  })(t, e2, n2, r3) : "string" == typeof e2 ? (function(t2, e3, n3) {
    "string" == typeof n3 && "" !== n3 || (n3 = "utf8");
    if (!y.isEncoding(n3)) throw new TypeError('"encoding" must be a valid string encoding');
    var r4 = 0 | _(e3, n3);
    t2 = w(t2, r4);
    var o3 = t2.write(e3, n3);
    o3 !== r4 && (t2 = t2.slice(0, o3));
    return t2;
  })(t, e2, n2) : (function(t2, e3) {
    if (T(e3)) {
      var n3 = 0 | E(e3.length);
      return 0 === (t2 = w(t2, n3)).length || e3.copy(t2, 0, 0, n3), t2;
    }
    if (e3) {
      if ("undefined" != typeof ArrayBuffer && e3.buffer instanceof ArrayBuffer || "length" in e3) return "number" != typeof e3.length || (r4 = e3.length) != r4 ? w(t2, 0) : A(t2, e3);
      if ("Buffer" === e3.type && p(e3.data)) return A(t2, e3.data);
    }
    var r4;
    throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
  })(t, e2);
}
function m(t) {
  if ("number" != typeof t) throw new TypeError('"size" argument must be a number');
  if (t < 0) throw new RangeError('"size" argument must not be negative');
}
function b(t, e2) {
  if (m(e2), t = w(t, e2 < 0 ? 0 : 0 | E(e2)), !y.TYPED_ARRAY_SUPPORT) for (var n2 = 0; n2 < e2; ++n2) t[n2] = 0;
  return t;
}
function A(t, e2) {
  var n2 = e2.length < 0 ? 0 : 0 | E(e2.length);
  t = w(t, n2);
  for (var r3 = 0; r3 < n2; r3 += 1) t[r3] = 255 & e2[r3];
  return t;
}
function E(t) {
  if (t >= g()) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + g().toString(16) + " bytes");
  return 0 | t;
}
function T(t) {
  return !(null == t || !t._isBuffer);
}
function _(t, e2) {
  if (T(t)) return t.length;
  if ("undefined" != typeof ArrayBuffer && "function" == typeof ArrayBuffer.isView && (ArrayBuffer.isView(t) || t instanceof ArrayBuffer)) return t.byteLength;
  "string" != typeof t && (t = "" + t);
  var n2 = t.length;
  if (0 === n2) return 0;
  for (var r3 = false; ; ) switch (e2) {
    case "ascii":
    case "latin1":
    case "binary":
      return n2;
    case "utf8":
    case "utf-8":
    case void 0:
      return V(t).length;
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return 2 * n2;
    case "hex":
      return n2 >>> 1;
    case "base64":
      return Z(t).length;
    default:
      if (r3) return V(t).length;
      e2 = ("" + e2).toLowerCase(), r3 = true;
  }
}
function R(t, e2, n2) {
  var r3 = false;
  if ((void 0 === e2 || e2 < 0) && (e2 = 0), e2 > this.length) return "";
  if ((void 0 === n2 || n2 > this.length) && (n2 = this.length), n2 <= 0) return "";
  if ((n2 >>>= 0) <= (e2 >>>= 0)) return "";
  for (t || (t = "utf8"); ; ) switch (t) {
    case "hex":
      return k(this, e2, n2);
    case "utf8":
    case "utf-8":
      return W(this, e2, n2);
    case "ascii":
      return x(this, e2, n2);
    case "latin1":
    case "binary":
      return Y(this, e2, n2);
    case "base64":
      return B(this, e2, n2);
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return j(this, e2, n2);
    default:
      if (r3) throw new TypeError("Unknown encoding: " + t);
      t = (t + "").toLowerCase(), r3 = true;
  }
}
function S(t, e2, n2) {
  var r3 = t[e2];
  t[e2] = t[n2], t[n2] = r3;
}
function N(t, e2, n2, r3, o3) {
  if (0 === t.length) return -1;
  if ("string" == typeof n2 ? (r3 = n2, n2 = 0) : n2 > 2147483647 ? n2 = 2147483647 : n2 < -2147483648 && (n2 = -2147483648), n2 = +n2, isNaN(n2) && (n2 = o3 ? 0 : t.length - 1), n2 < 0 && (n2 = t.length + n2), n2 >= t.length) {
    if (o3) return -1;
    n2 = t.length - 1;
  } else if (n2 < 0) {
    if (!o3) return -1;
    n2 = 0;
  }
  if ("string" == typeof e2 && (e2 = y.from(e2, r3)), T(e2)) return 0 === e2.length ? -1 : C(t, e2, n2, r3, o3);
  if ("number" == typeof e2) return e2 &= 255, y.TYPED_ARRAY_SUPPORT && "function" == typeof Uint8Array.prototype.indexOf ? o3 ? Uint8Array.prototype.indexOf.call(t, e2, n2) : Uint8Array.prototype.lastIndexOf.call(t, e2, n2) : C(t, [e2], n2, r3, o3);
  throw new TypeError("val must be string, number or Buffer");
}
function C(t, e2, n2, r3, o3) {
  var i2, s2 = 1, a2 = t.length, l2 = e2.length;
  if (void 0 !== r3 && ("ucs2" === (r3 = String(r3).toLowerCase()) || "ucs-2" === r3 || "utf16le" === r3 || "utf-16le" === r3)) {
    if (t.length < 2 || e2.length < 2) return -1;
    s2 = 2, a2 /= 2, l2 /= 2, n2 /= 2;
  }
  function u2(t2, e3) {
    return 1 === s2 ? t2[e3] : t2.readUInt16BE(e3 * s2);
  }
  if (o3) {
    var c2 = -1;
    for (i2 = n2; i2 < a2; i2++) if (u2(t, i2) === u2(e2, -1 === c2 ? 0 : i2 - c2)) {
      if (-1 === c2 && (c2 = i2), i2 - c2 + 1 === l2) return c2 * s2;
    } else -1 !== c2 && (i2 -= i2 - c2), c2 = -1;
  } else for (n2 + l2 > a2 && (n2 = a2 - l2), i2 = n2; i2 >= 0; i2--) {
    for (var h2 = true, f2 = 0; f2 < l2; f2++) if (u2(t, i2 + f2) !== u2(e2, f2)) {
      h2 = false;
      break;
    }
    if (h2) return i2;
  }
  return -1;
}
function I(t, e2, n2, r3) {
  n2 = Number(n2) || 0;
  var o3 = t.length - n2;
  r3 ? (r3 = Number(r3)) > o3 && (r3 = o3) : r3 = o3;
  var i2 = e2.length;
  if (i2 % 2 != 0) throw new TypeError("Invalid hex string");
  r3 > i2 / 2 && (r3 = i2 / 2);
  for (var s2 = 0; s2 < r3; ++s2) {
    var a2 = parseInt(e2.substr(2 * s2, 2), 16);
    if (isNaN(a2)) return s2;
    t[n2 + s2] = a2;
  }
  return s2;
}
function P(t, e2, n2, r3) {
  return Q(V(e2, t.length - n2), t, n2, r3);
}
function O(t, e2, n2, r3) {
  return Q((function(t2) {
    for (var e3 = [], n3 = 0; n3 < t2.length; ++n3) e3.push(255 & t2.charCodeAt(n3));
    return e3;
  })(e2), t, n2, r3);
}
function L(t, e2, n2, r3) {
  return O(t, e2, n2, r3);
}
function M(t, e2, n2, r3) {
  return Q(Z(e2), t, n2, r3);
}
function U(t, e2, n2, r3) {
  return Q((function(t2, e3) {
    for (var n3, r4, o3, i2 = [], s2 = 0; s2 < t2.length && !((e3 -= 2) < 0); ++s2) r4 = (n3 = t2.charCodeAt(s2)) >> 8, o3 = n3 % 256, i2.push(o3), i2.push(r4);
    return i2;
  })(e2, t.length - n2), t, n2, r3);
}
function B(t, e2, n2) {
  return 0 === e2 && n2 === t.length ? c(t) : c(t.slice(e2, n2));
}
function W(t, e2, n2) {
  n2 = Math.min(t.length, n2);
  for (var r3 = [], o3 = e2; o3 < n2; ) {
    var i2, s2, a2, l2, u2 = t[o3], c2 = null, h2 = u2 > 239 ? 4 : u2 > 223 ? 3 : u2 > 191 ? 2 : 1;
    if (o3 + h2 <= n2) switch (h2) {
      case 1:
        u2 < 128 && (c2 = u2);
        break;
      case 2:
        128 == (192 & (i2 = t[o3 + 1])) && (l2 = (31 & u2) << 6 | 63 & i2) > 127 && (c2 = l2);
        break;
      case 3:
        i2 = t[o3 + 1], s2 = t[o3 + 2], 128 == (192 & i2) && 128 == (192 & s2) && (l2 = (15 & u2) << 12 | (63 & i2) << 6 | 63 & s2) > 2047 && (l2 < 55296 || l2 > 57343) && (c2 = l2);
        break;
      case 4:
        i2 = t[o3 + 1], s2 = t[o3 + 2], a2 = t[o3 + 3], 128 == (192 & i2) && 128 == (192 & s2) && 128 == (192 & a2) && (l2 = (15 & u2) << 18 | (63 & i2) << 12 | (63 & s2) << 6 | 63 & a2) > 65535 && l2 < 1114112 && (c2 = l2);
    }
    null === c2 ? (c2 = 65533, h2 = 1) : c2 > 65535 && (c2 -= 65536, r3.push(c2 >>> 10 & 1023 | 55296), c2 = 56320 | 1023 & c2), r3.push(c2), o3 += h2;
  }
  return (function(t2) {
    var e3 = t2.length;
    if (e3 <= D) return String.fromCharCode.apply(String, t2);
    var n3 = "", r4 = 0;
    for (; r4 < e3; ) n3 += String.fromCharCode.apply(String, t2.slice(r4, r4 += D));
    return n3;
  })(r3);
}
y.TYPED_ARRAY_SUPPORT = void 0 === r2.TYPED_ARRAY_SUPPORT || r2.TYPED_ARRAY_SUPPORT, g(), y.poolSize = 8192, y._augment = function(t) {
  return t.__proto__ = y.prototype, t;
}, y.from = function(t, e2, n2) {
  return v(null, t, e2, n2);
}, y.TYPED_ARRAY_SUPPORT && (y.prototype.__proto__ = Uint8Array.prototype, y.__proto__ = Uint8Array), y.alloc = function(t, e2, n2) {
  return (function(t2, e3, n3, r3) {
    return m(e3), e3 <= 0 ? w(t2, e3) : void 0 !== n3 ? "string" == typeof r3 ? w(t2, e3).fill(n3, r3) : w(t2, e3).fill(n3) : w(t2, e3);
  })(null, t, e2, n2);
}, y.allocUnsafe = function(t) {
  return b(null, t);
}, y.allocUnsafeSlow = function(t) {
  return b(null, t);
}, y.isBuffer = function(t) {
  return null != t && (!!t._isBuffer || tt(t) || (function(t2) {
    return "function" == typeof t2.readFloatLE && "function" == typeof t2.slice && tt(t2.slice(0, 0));
  })(t));
}, y.compare = function(t, e2) {
  if (!T(t) || !T(e2)) throw new TypeError("Arguments must be Buffers");
  if (t === e2) return 0;
  for (var n2 = t.length, r3 = e2.length, o3 = 0, i2 = Math.min(n2, r3); o3 < i2; ++o3) if (t[o3] !== e2[o3]) {
    n2 = t[o3], r3 = e2[o3];
    break;
  }
  return n2 < r3 ? -1 : r3 < n2 ? 1 : 0;
}, y.isEncoding = function(t) {
  switch (String(t).toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "latin1":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return true;
    default:
      return false;
  }
}, y.concat = function(t, e2) {
  if (!p(t)) throw new TypeError('"list" argument must be an Array of Buffers');
  if (0 === t.length) return y.alloc(0);
  var n2;
  if (void 0 === e2) for (e2 = 0, n2 = 0; n2 < t.length; ++n2) e2 += t[n2].length;
  var r3 = y.allocUnsafe(e2), o3 = 0;
  for (n2 = 0; n2 < t.length; ++n2) {
    var i2 = t[n2];
    if (!T(i2)) throw new TypeError('"list" argument must be an Array of Buffers');
    i2.copy(r3, o3), o3 += i2.length;
  }
  return r3;
}, y.byteLength = _, y.prototype._isBuffer = true, y.prototype.swap16 = function() {
  var t = this.length;
  if (t % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
  for (var e2 = 0; e2 < t; e2 += 2) S(this, e2, e2 + 1);
  return this;
}, y.prototype.swap32 = function() {
  var t = this.length;
  if (t % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
  for (var e2 = 0; e2 < t; e2 += 4) S(this, e2, e2 + 3), S(this, e2 + 1, e2 + 2);
  return this;
}, y.prototype.swap64 = function() {
  var t = this.length;
  if (t % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
  for (var e2 = 0; e2 < t; e2 += 8) S(this, e2, e2 + 7), S(this, e2 + 1, e2 + 6), S(this, e2 + 2, e2 + 5), S(this, e2 + 3, e2 + 4);
  return this;
}, y.prototype.toString = function() {
  var t = 0 | this.length;
  return 0 === t ? "" : 0 === arguments.length ? W(this, 0, t) : R.apply(this, arguments);
}, y.prototype.equals = function(t) {
  if (!T(t)) throw new TypeError("Argument must be a Buffer");
  return this === t || 0 === y.compare(this, t);
}, y.prototype.inspect = function() {
  var t = "";
  return this.length > 0 && (t = this.toString("hex", 0, 50).match(/.{2}/g).join(" "), this.length > 50 && (t += " ... ")), "<Buffer " + t + ">";
}, y.prototype.compare = function(t, e2, n2, r3, o3) {
  if (!T(t)) throw new TypeError("Argument must be a Buffer");
  if (void 0 === e2 && (e2 = 0), void 0 === n2 && (n2 = t ? t.length : 0), void 0 === r3 && (r3 = 0), void 0 === o3 && (o3 = this.length), e2 < 0 || n2 > t.length || r3 < 0 || o3 > this.length) throw new RangeError("out of range index");
  if (r3 >= o3 && e2 >= n2) return 0;
  if (r3 >= o3) return -1;
  if (e2 >= n2) return 1;
  if (this === t) return 0;
  for (var i2 = (o3 >>>= 0) - (r3 >>>= 0), s2 = (n2 >>>= 0) - (e2 >>>= 0), a2 = Math.min(i2, s2), l2 = this.slice(r3, o3), u2 = t.slice(e2, n2), c2 = 0; c2 < a2; ++c2) if (l2[c2] !== u2[c2]) {
    i2 = l2[c2], s2 = u2[c2];
    break;
  }
  return i2 < s2 ? -1 : s2 < i2 ? 1 : 0;
}, y.prototype.includes = function(t, e2, n2) {
  return -1 !== this.indexOf(t, e2, n2);
}, y.prototype.indexOf = function(t, e2, n2) {
  return N(this, t, e2, n2, true);
}, y.prototype.lastIndexOf = function(t, e2, n2) {
  return N(this, t, e2, n2, false);
}, y.prototype.write = function(t, e2, n2, r3) {
  if (void 0 === e2) r3 = "utf8", n2 = this.length, e2 = 0;
  else if (void 0 === n2 && "string" == typeof e2) r3 = e2, n2 = this.length, e2 = 0;
  else {
    if (!isFinite(e2)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    e2 |= 0, isFinite(n2) ? (n2 |= 0, void 0 === r3 && (r3 = "utf8")) : (r3 = n2, n2 = void 0);
  }
  var o3 = this.length - e2;
  if ((void 0 === n2 || n2 > o3) && (n2 = o3), t.length > 0 && (n2 < 0 || e2 < 0) || e2 > this.length) throw new RangeError("Attempt to write outside buffer bounds");
  r3 || (r3 = "utf8");
  for (var i2 = false; ; ) switch (r3) {
    case "hex":
      return I(this, t, e2, n2);
    case "utf8":
    case "utf-8":
      return P(this, t, e2, n2);
    case "ascii":
      return O(this, t, e2, n2);
    case "latin1":
    case "binary":
      return L(this, t, e2, n2);
    case "base64":
      return M(this, t, e2, n2);
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return U(this, t, e2, n2);
    default:
      if (i2) throw new TypeError("Unknown encoding: " + r3);
      r3 = ("" + r3).toLowerCase(), i2 = true;
  }
}, y.prototype.toJSON = function() {
  return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
};
var D = 4096;
function x(t, e2, n2) {
  var r3 = "";
  n2 = Math.min(t.length, n2);
  for (var o3 = e2; o3 < n2; ++o3) r3 += String.fromCharCode(127 & t[o3]);
  return r3;
}
function Y(t, e2, n2) {
  var r3 = "";
  n2 = Math.min(t.length, n2);
  for (var o3 = e2; o3 < n2; ++o3) r3 += String.fromCharCode(t[o3]);
  return r3;
}
function k(t, e2, n2) {
  var r3 = t.length;
  (!e2 || e2 < 0) && (e2 = 0), (!n2 || n2 < 0 || n2 > r3) && (n2 = r3);
  for (var o3 = "", i2 = e2; i2 < n2; ++i2) o3 += J(t[i2]);
  return o3;
}
function j(t, e2, n2) {
  for (var r3 = t.slice(e2, n2), o3 = "", i2 = 0; i2 < r3.length; i2 += 2) o3 += String.fromCharCode(r3[i2] + 256 * r3[i2 + 1]);
  return o3;
}
function $(t, e2, n2) {
  if (t % 1 != 0 || t < 0) throw new RangeError("offset is not uint");
  if (t + e2 > n2) throw new RangeError("Trying to access beyond buffer length");
}
function G(t, e2, n2, r3, o3, i2) {
  if (!T(t)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (e2 > o3 || e2 < i2) throw new RangeError('"value" argument is out of bounds');
  if (n2 + r3 > t.length) throw new RangeError("Index out of range");
}
function q(t, e2, n2, r3) {
  e2 < 0 && (e2 = 65535 + e2 + 1);
  for (var o3 = 0, i2 = Math.min(t.length - n2, 2); o3 < i2; ++o3) t[n2 + o3] = (e2 & 255 << 8 * (r3 ? o3 : 1 - o3)) >>> 8 * (r3 ? o3 : 1 - o3);
}
function z(t, e2, n2, r3) {
  e2 < 0 && (e2 = 4294967295 + e2 + 1);
  for (var o3 = 0, i2 = Math.min(t.length - n2, 4); o3 < i2; ++o3) t[n2 + o3] = e2 >>> 8 * (r3 ? o3 : 3 - o3) & 255;
}
function F(t, e2, n2, r3, o3, i2) {
  if (n2 + r3 > t.length) throw new RangeError("Index out of range");
  if (n2 < 0) throw new RangeError("Index out of range");
}
function H(t, e2, n2, r3, o3) {
  return o3 || F(t, 0, n2, 4), f(t, e2, n2, r3, 23, 4), n2 + 4;
}
function K(t, e2, n2, r3, o3) {
  return o3 || F(t, 0, n2, 8), f(t, e2, n2, r3, 52, 8), n2 + 8;
}
y.prototype.slice = function(t, e2) {
  var n2, r3 = this.length;
  if ((t = ~~t) < 0 ? (t += r3) < 0 && (t = 0) : t > r3 && (t = r3), (e2 = void 0 === e2 ? r3 : ~~e2) < 0 ? (e2 += r3) < 0 && (e2 = 0) : e2 > r3 && (e2 = r3), e2 < t && (e2 = t), y.TYPED_ARRAY_SUPPORT) (n2 = this.subarray(t, e2)).__proto__ = y.prototype;
  else {
    var o3 = e2 - t;
    n2 = new y(o3, void 0);
    for (var i2 = 0; i2 < o3; ++i2) n2[i2] = this[i2 + t];
  }
  return n2;
}, y.prototype.readUIntLE = function(t, e2, n2) {
  t |= 0, e2 |= 0, n2 || $(t, e2, this.length);
  for (var r3 = this[t], o3 = 1, i2 = 0; ++i2 < e2 && (o3 *= 256); ) r3 += this[t + i2] * o3;
  return r3;
}, y.prototype.readUIntBE = function(t, e2, n2) {
  t |= 0, e2 |= 0, n2 || $(t, e2, this.length);
  for (var r3 = this[t + --e2], o3 = 1; e2 > 0 && (o3 *= 256); ) r3 += this[t + --e2] * o3;
  return r3;
}, y.prototype.readUInt8 = function(t, e2) {
  return e2 || $(t, 1, this.length), this[t];
}, y.prototype.readUInt16LE = function(t, e2) {
  return e2 || $(t, 2, this.length), this[t] | this[t + 1] << 8;
}, y.prototype.readUInt16BE = function(t, e2) {
  return e2 || $(t, 2, this.length), this[t] << 8 | this[t + 1];
}, y.prototype.readUInt32LE = function(t, e2) {
  return e2 || $(t, 4, this.length), (this[t] | this[t + 1] << 8 | this[t + 2] << 16) + 16777216 * this[t + 3];
}, y.prototype.readUInt32BE = function(t, e2) {
  return e2 || $(t, 4, this.length), 16777216 * this[t] + (this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3]);
}, y.prototype.readIntLE = function(t, e2, n2) {
  t |= 0, e2 |= 0, n2 || $(t, e2, this.length);
  for (var r3 = this[t], o3 = 1, i2 = 0; ++i2 < e2 && (o3 *= 256); ) r3 += this[t + i2] * o3;
  return r3 >= (o3 *= 128) && (r3 -= Math.pow(2, 8 * e2)), r3;
}, y.prototype.readIntBE = function(t, e2, n2) {
  t |= 0, e2 |= 0, n2 || $(t, e2, this.length);
  for (var r3 = e2, o3 = 1, i2 = this[t + --r3]; r3 > 0 && (o3 *= 256); ) i2 += this[t + --r3] * o3;
  return i2 >= (o3 *= 128) && (i2 -= Math.pow(2, 8 * e2)), i2;
}, y.prototype.readInt8 = function(t, e2) {
  return e2 || $(t, 1, this.length), 128 & this[t] ? -1 * (255 - this[t] + 1) : this[t];
}, y.prototype.readInt16LE = function(t, e2) {
  e2 || $(t, 2, this.length);
  var n2 = this[t] | this[t + 1] << 8;
  return 32768 & n2 ? 4294901760 | n2 : n2;
}, y.prototype.readInt16BE = function(t, e2) {
  e2 || $(t, 2, this.length);
  var n2 = this[t + 1] | this[t] << 8;
  return 32768 & n2 ? 4294901760 | n2 : n2;
}, y.prototype.readInt32LE = function(t, e2) {
  return e2 || $(t, 4, this.length), this[t] | this[t + 1] << 8 | this[t + 2] << 16 | this[t + 3] << 24;
}, y.prototype.readInt32BE = function(t, e2) {
  return e2 || $(t, 4, this.length), this[t] << 24 | this[t + 1] << 16 | this[t + 2] << 8 | this[t + 3];
}, y.prototype.readFloatLE = function(t, e2) {
  return e2 || $(t, 4, this.length), h(this, t, true, 23, 4);
}, y.prototype.readFloatBE = function(t, e2) {
  return e2 || $(t, 4, this.length), h(this, t, false, 23, 4);
}, y.prototype.readDoubleLE = function(t, e2) {
  return e2 || $(t, 8, this.length), h(this, t, true, 52, 8);
}, y.prototype.readDoubleBE = function(t, e2) {
  return e2 || $(t, 8, this.length), h(this, t, false, 52, 8);
}, y.prototype.writeUIntLE = function(t, e2, n2, r3) {
  (t = +t, e2 |= 0, n2 |= 0, r3) || G(this, t, e2, n2, Math.pow(2, 8 * n2) - 1, 0);
  var o3 = 1, i2 = 0;
  for (this[e2] = 255 & t; ++i2 < n2 && (o3 *= 256); ) this[e2 + i2] = t / o3 & 255;
  return e2 + n2;
}, y.prototype.writeUIntBE = function(t, e2, n2, r3) {
  (t = +t, e2 |= 0, n2 |= 0, r3) || G(this, t, e2, n2, Math.pow(2, 8 * n2) - 1, 0);
  var o3 = n2 - 1, i2 = 1;
  for (this[e2 + o3] = 255 & t; --o3 >= 0 && (i2 *= 256); ) this[e2 + o3] = t / i2 & 255;
  return e2 + n2;
}, y.prototype.writeUInt8 = function(t, e2, n2) {
  return t = +t, e2 |= 0, n2 || G(this, t, e2, 1, 255, 0), y.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)), this[e2] = 255 & t, e2 + 1;
}, y.prototype.writeUInt16LE = function(t, e2, n2) {
  return t = +t, e2 |= 0, n2 || G(this, t, e2, 2, 65535, 0), y.TYPED_ARRAY_SUPPORT ? (this[e2] = 255 & t, this[e2 + 1] = t >>> 8) : q(this, t, e2, true), e2 + 2;
}, y.prototype.writeUInt16BE = function(t, e2, n2) {
  return t = +t, e2 |= 0, n2 || G(this, t, e2, 2, 65535, 0), y.TYPED_ARRAY_SUPPORT ? (this[e2] = t >>> 8, this[e2 + 1] = 255 & t) : q(this, t, e2, false), e2 + 2;
}, y.prototype.writeUInt32LE = function(t, e2, n2) {
  return t = +t, e2 |= 0, n2 || G(this, t, e2, 4, 4294967295, 0), y.TYPED_ARRAY_SUPPORT ? (this[e2 + 3] = t >>> 24, this[e2 + 2] = t >>> 16, this[e2 + 1] = t >>> 8, this[e2] = 255 & t) : z(this, t, e2, true), e2 + 4;
}, y.prototype.writeUInt32BE = function(t, e2, n2) {
  return t = +t, e2 |= 0, n2 || G(this, t, e2, 4, 4294967295, 0), y.TYPED_ARRAY_SUPPORT ? (this[e2] = t >>> 24, this[e2 + 1] = t >>> 16, this[e2 + 2] = t >>> 8, this[e2 + 3] = 255 & t) : z(this, t, e2, false), e2 + 4;
}, y.prototype.writeIntLE = function(t, e2, n2, r3) {
  if (t = +t, e2 |= 0, !r3) {
    var o3 = Math.pow(2, 8 * n2 - 1);
    G(this, t, e2, n2, o3 - 1, -o3);
  }
  var i2 = 0, s2 = 1, a2 = 0;
  for (this[e2] = 255 & t; ++i2 < n2 && (s2 *= 256); ) t < 0 && 0 === a2 && 0 !== this[e2 + i2 - 1] && (a2 = 1), this[e2 + i2] = (t / s2 | 0) - a2 & 255;
  return e2 + n2;
}, y.prototype.writeIntBE = function(t, e2, n2, r3) {
  if (t = +t, e2 |= 0, !r3) {
    var o3 = Math.pow(2, 8 * n2 - 1);
    G(this, t, e2, n2, o3 - 1, -o3);
  }
  var i2 = n2 - 1, s2 = 1, a2 = 0;
  for (this[e2 + i2] = 255 & t; --i2 >= 0 && (s2 *= 256); ) t < 0 && 0 === a2 && 0 !== this[e2 + i2 + 1] && (a2 = 1), this[e2 + i2] = (t / s2 | 0) - a2 & 255;
  return e2 + n2;
}, y.prototype.writeInt8 = function(t, e2, n2) {
  return t = +t, e2 |= 0, n2 || G(this, t, e2, 1, 127, -128), y.TYPED_ARRAY_SUPPORT || (t = Math.floor(t)), t < 0 && (t = 255 + t + 1), this[e2] = 255 & t, e2 + 1;
}, y.prototype.writeInt16LE = function(t, e2, n2) {
  return t = +t, e2 |= 0, n2 || G(this, t, e2, 2, 32767, -32768), y.TYPED_ARRAY_SUPPORT ? (this[e2] = 255 & t, this[e2 + 1] = t >>> 8) : q(this, t, e2, true), e2 + 2;
}, y.prototype.writeInt16BE = function(t, e2, n2) {
  return t = +t, e2 |= 0, n2 || G(this, t, e2, 2, 32767, -32768), y.TYPED_ARRAY_SUPPORT ? (this[e2] = t >>> 8, this[e2 + 1] = 255 & t) : q(this, t, e2, false), e2 + 2;
}, y.prototype.writeInt32LE = function(t, e2, n2) {
  return t = +t, e2 |= 0, n2 || G(this, t, e2, 4, 2147483647, -2147483648), y.TYPED_ARRAY_SUPPORT ? (this[e2] = 255 & t, this[e2 + 1] = t >>> 8, this[e2 + 2] = t >>> 16, this[e2 + 3] = t >>> 24) : z(this, t, e2, true), e2 + 4;
}, y.prototype.writeInt32BE = function(t, e2, n2) {
  return t = +t, e2 |= 0, n2 || G(this, t, e2, 4, 2147483647, -2147483648), t < 0 && (t = 4294967295 + t + 1), y.TYPED_ARRAY_SUPPORT ? (this[e2] = t >>> 24, this[e2 + 1] = t >>> 16, this[e2 + 2] = t >>> 8, this[e2 + 3] = 255 & t) : z(this, t, e2, false), e2 + 4;
}, y.prototype.writeFloatLE = function(t, e2, n2) {
  return H(this, t, e2, true, n2);
}, y.prototype.writeFloatBE = function(t, e2, n2) {
  return H(this, t, e2, false, n2);
}, y.prototype.writeDoubleLE = function(t, e2, n2) {
  return K(this, t, e2, true, n2);
}, y.prototype.writeDoubleBE = function(t, e2, n2) {
  return K(this, t, e2, false, n2);
}, y.prototype.copy = function(t, e2, n2, r3) {
  if (n2 || (n2 = 0), r3 || 0 === r3 || (r3 = this.length), e2 >= t.length && (e2 = t.length), e2 || (e2 = 0), r3 > 0 && r3 < n2 && (r3 = n2), r3 === n2) return 0;
  if (0 === t.length || 0 === this.length) return 0;
  if (e2 < 0) throw new RangeError("targetStart out of bounds");
  if (n2 < 0 || n2 >= this.length) throw new RangeError("sourceStart out of bounds");
  if (r3 < 0) throw new RangeError("sourceEnd out of bounds");
  r3 > this.length && (r3 = this.length), t.length - e2 < r3 - n2 && (r3 = t.length - e2 + n2);
  var o3, i2 = r3 - n2;
  if (this === t && n2 < e2 && e2 < r3) for (o3 = i2 - 1; o3 >= 0; --o3) t[o3 + e2] = this[o3 + n2];
  else if (i2 < 1e3 || !y.TYPED_ARRAY_SUPPORT) for (o3 = 0; o3 < i2; ++o3) t[o3 + e2] = this[o3 + n2];
  else Uint8Array.prototype.set.call(t, this.subarray(n2, n2 + i2), e2);
  return i2;
}, y.prototype.fill = function(t, e2, n2, r3) {
  if ("string" == typeof t) {
    if ("string" == typeof e2 ? (r3 = e2, e2 = 0, n2 = this.length) : "string" == typeof n2 && (r3 = n2, n2 = this.length), 1 === t.length) {
      var o3 = t.charCodeAt(0);
      o3 < 256 && (t = o3);
    }
    if (void 0 !== r3 && "string" != typeof r3) throw new TypeError("encoding must be a string");
    if ("string" == typeof r3 && !y.isEncoding(r3)) throw new TypeError("Unknown encoding: " + r3);
  } else "number" == typeof t && (t &= 255);
  if (e2 < 0 || this.length < e2 || this.length < n2) throw new RangeError("Out of range index");
  if (n2 <= e2) return this;
  var i2;
  if (e2 >>>= 0, n2 = void 0 === n2 ? this.length : n2 >>> 0, t || (t = 0), "number" == typeof t) for (i2 = e2; i2 < n2; ++i2) this[i2] = t;
  else {
    var s2 = T(t) ? t : V(new y(t, r3).toString()), a2 = s2.length;
    for (i2 = 0; i2 < n2 - e2; ++i2) this[i2 + e2] = s2[i2 % a2];
  }
  return this;
};
var X = /[^+\/0-9A-Za-z-_]/g;
function J(t) {
  return t < 16 ? "0" + t.toString(16) : t.toString(16);
}
function V(t, e2) {
  var n2;
  e2 = e2 || 1 / 0;
  for (var r3 = t.length, o3 = null, i2 = [], s2 = 0; s2 < r3; ++s2) {
    if ((n2 = t.charCodeAt(s2)) > 55295 && n2 < 57344) {
      if (!o3) {
        if (n2 > 56319) {
          (e2 -= 3) > -1 && i2.push(239, 191, 189);
          continue;
        }
        if (s2 + 1 === r3) {
          (e2 -= 3) > -1 && i2.push(239, 191, 189);
          continue;
        }
        o3 = n2;
        continue;
      }
      if (n2 < 56320) {
        (e2 -= 3) > -1 && i2.push(239, 191, 189), o3 = n2;
        continue;
      }
      n2 = 65536 + (o3 - 55296 << 10 | n2 - 56320);
    } else o3 && (e2 -= 3) > -1 && i2.push(239, 191, 189);
    if (o3 = null, n2 < 128) {
      if ((e2 -= 1) < 0) break;
      i2.push(n2);
    } else if (n2 < 2048) {
      if ((e2 -= 2) < 0) break;
      i2.push(n2 >> 6 | 192, 63 & n2 | 128);
    } else if (n2 < 65536) {
      if ((e2 -= 3) < 0) break;
      i2.push(n2 >> 12 | 224, n2 >> 6 & 63 | 128, 63 & n2 | 128);
    } else {
      if (!(n2 < 1114112)) throw new Error("Invalid code point");
      if ((e2 -= 4) < 0) break;
      i2.push(n2 >> 18 | 240, n2 >> 12 & 63 | 128, n2 >> 6 & 63 | 128, 63 & n2 | 128);
    }
  }
  return i2;
}
function Z(t) {
  return (function(t2) {
    var e2, n2, r3, o3, u2, c2;
    a || l();
    var h2 = t2.length;
    if (h2 % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    u2 = "=" === t2[h2 - 2] ? 2 : "=" === t2[h2 - 1] ? 1 : 0, c2 = new s(3 * h2 / 4 - u2), r3 = u2 > 0 ? h2 - 4 : h2;
    var f2 = 0;
    for (e2 = 0, n2 = 0; e2 < r3; e2 += 4, n2 += 3) o3 = i[t2.charCodeAt(e2)] << 18 | i[t2.charCodeAt(e2 + 1)] << 12 | i[t2.charCodeAt(e2 + 2)] << 6 | i[t2.charCodeAt(e2 + 3)], c2[f2++] = o3 >> 16 & 255, c2[f2++] = o3 >> 8 & 255, c2[f2++] = 255 & o3;
    return 2 === u2 ? (o3 = i[t2.charCodeAt(e2)] << 2 | i[t2.charCodeAt(e2 + 1)] >> 4, c2[f2++] = 255 & o3) : 1 === u2 && (o3 = i[t2.charCodeAt(e2)] << 10 | i[t2.charCodeAt(e2 + 1)] << 4 | i[t2.charCodeAt(e2 + 2)] >> 2, c2[f2++] = o3 >> 8 & 255, c2[f2++] = 255 & o3), c2;
  })((function(t2) {
    if ((t2 = (function(t3) {
      return t3.trim ? t3.trim() : t3.replace(/^\s+|\s+$/g, "");
    })(t2).replace(X, "")).length < 2) return "";
    for (; t2.length % 4 != 0; ) t2 += "=";
    return t2;
  })(t));
}
function Q(t, e2, n2, r3) {
  for (var o3 = 0; o3 < r3 && !(o3 + n2 >= e2.length || o3 >= t.length); ++o3) e2[o3 + n2] = t[o3];
  return o3;
}
function tt(t) {
  return !!t.constructor && "function" == typeof t.constructor.isBuffer && t.constructor.isBuffer(t);
}
function et(t, e2, n2, r3) {
  return new (n2 || (n2 = Promise))((function(o3, i2) {
    function s2(t2) {
      try {
        l2(r3.next(t2));
      } catch (t3) {
        i2(t3);
      }
    }
    function a2(t2) {
      try {
        l2(r3.throw(t2));
      } catch (t3) {
        i2(t3);
      }
    }
    function l2(t2) {
      var e3;
      t2.done ? o3(t2.value) : (e3 = t2.value, e3 instanceof n2 ? e3 : new n2((function(t3) {
        t3(e3);
      }))).then(s2, a2);
    }
    l2((r3 = r3.apply(t, e2 || [])).next());
  }));
}
var nt = class _nt extends Error {
  constructor(t, e2, ...n2) {
    super(...n2), Error.captureStackTrace && Error.captureStackTrace(this, _nt), this.name = "PeraWalletConnectError", this.data = t, this.message = e2;
  }
};
var rt = new class {
  constructor(t) {
    this.listener = void 0, this.channel = t.channel;
  }
  setupListener({ onReceiveMessage: t }) {
    this.close(), this.listener = (e2) => {
      if ("object" == typeof e2.data) try {
        e2.data.channel === this.channel && t(e2);
      } catch (t2) {
        console.error(t2);
      }
    }, window.addEventListener("message", this.listener);
  }
  sendMessage({ message: t, targetWindow: e2, origin: n2, timeout: r3 = 1e3 }) {
    setTimeout((() => {
      const r4 = { channel: this.channel, message: t };
      e2.postMessage(r4, { targetOrigin: n2 || "*" });
    }), r3);
  }
  close() {
    this.listener && (window.removeEventListener("message", this.listener), this.listener = void 0);
  }
}({ channel: "pera-web-wallet" });
var ot = 700;
var it = 50;
function st() {
  const t = document.querySelector('meta[name="name"]'), e2 = document.querySelector('meta[name="description"]');
  let { title: n2 } = document, r3 = "";
  return t instanceof HTMLMetaElement && (n2 = t.content), e2 instanceof HTMLMetaElement && (r3 = e2.content), { title: n2, description: r3, url: window.location.origin, favicon: at()[0] };
}
function at() {
  const t = document.getElementsByTagName("link"), e2 = [];
  for (let n2 = 0; n2 < t.length; n2++) {
    const r3 = t[n2], o3 = r3.getAttribute("rel");
    if (o3 && o3.toLowerCase().indexOf("icon") > -1) {
      const t2 = r3.getAttribute("href");
      if (t2 && -1 === t2.toLowerCase().indexOf("https:") && -1 === t2.toLowerCase().indexOf("http:") && 0 !== t2.indexOf("//")) {
        let n3 = `${window.location.protocol}//${window.location.host}`;
        if (0 === t2.indexOf("/")) n3 += t2;
        else {
          const e3 = window.location.pathname.split("/");
          e3.pop();
          n3 += `${e3.join("/")}/${t2}`;
        }
        e2.push(n3);
      } else if (0 === (null == t2 ? void 0 : t2.indexOf("//"))) {
        const n3 = window.location.protocol + t2;
        e2.push(n3);
      } else t2 && e2.push(t2);
    }
  }
  return e2;
}
function lt(t) {
  return new Promise(((e2, n2) => {
    try {
      const r3 = window.open(t, "_blank");
      let o3 = 0;
      const i2 = setInterval((() => {
        if (o3 += 1, o3 === it) return clearInterval(i2), void n2(new nt({ type: "MESSAGE_NOT_RECEIVED" }, "Couldn't open Pera Wallet, please try again."));
        r3 && (true === r3.closed && (clearInterval(i2), n2(new nt({ type: "OPERATION_CANCELLED" }, "Operation cancelled by user"))), rt.sendMessage({ message: { type: "TAB_OPEN" }, origin: t, targetWindow: r3 }));
      }), ot);
      rt.setupListener({ onReceiveMessage: (t2) => {
        "TAB_OPEN_RECEIVED" === t2.data.message.type && (clearInterval(i2), e2(r3));
      } });
    } catch (t2) {
      n2(t2);
    }
  }));
}
var ut = "pera-wallet-connect-modal-wrapper";
var ct = "pera-wallet-redirect-modal-wrapper";
var ht = "pera-wallet-sign-txn-toast-wrapper";
var ft = "pera-wallet-sign-txn-modal-wrapper";
var dt = "pera-wallet-modal";
function pt(t) {
  const e2 = document.createElement("div");
  return e2.setAttribute("id", t), document.body.appendChild(e2), e2;
}
function gt() {
  pt(ct).innerHTML = "<pera-wallet-redirect-modal></pera-wallet-redirect-modal>";
}
function wt() {
  pt(ht).innerHTML = "<pera-wallet-sign-txn-toast></pera-wallet-sign-txn-toast>";
}
function yt() {
  vt(ht);
}
function vt(t) {
  const e2 = document.getElementById(t);
  e2 && e2.remove();
}
var mt = { WALLET: "PeraWallet.Wallet", WALLETCONNECT: "walletconnect" };
function bt() {
  return "undefined" == typeof localStorage ? void 0 : localStorage;
}
function At(t, e2) {
  var n2;
  null === (n2 = bt()) || void 0 === n2 || n2.setItem(mt.WALLET, JSON.stringify({ type: e2 || "pera-wallet", accounts: t, selectedAccount: t[0] }));
}
function Et() {
  var t;
  const e2 = null === (t = bt()) || void 0 === t ? void 0 : t.getItem(mt.WALLET);
  return e2 ? JSON.parse(e2) : null;
}
function Tt() {
  return new Promise(((t, e2) => {
    var n2, r3;
    try {
      null === (n2 = bt()) || void 0 === n2 || n2.removeItem(mt.WALLETCONNECT), null === (r3 = bt()) || void 0 === r3 || r3.removeItem(mt.WALLET), t(void 0);
    } catch (t2) {
      e2(t2);
    }
  }));
}
function _t(t) {
  const e2 = t.slice();
  for (let t2 = e2.length - 1; t2 > 0; t2--) {
    const n2 = Math.floor(Math.random() * (t2 + 1));
    [e2[t2], e2[n2]] = [e2[n2], e2[t2]];
  }
  return e2;
}
var Rt = "https://wc.perawallet.app/config.json";
function St() {
  return (function(t, e2 = {}) {
    return fetch(t, e2).then(((t2) => t2.json())).then(((t2) => t2));
  })(Rt, { cache: "no-store" });
}
function Nt() {
  return et(this, void 0, void 0, (function* () {
    let t = { bridgeURL: "", webWalletURL: "", isWebWalletAvailable: false, shouldDisplayNewBadge: false, shouldUseSound: true, silent: false, promoteMobile: false };
    try {
      const e2 = yield St();
      void 0 !== e2.web_wallet && e2.web_wallet_url && (t.isWebWalletAvailable = e2.web_wallet), void 0 !== e2.display_new_badge && (t.shouldDisplayNewBadge = e2.display_new_badge), void 0 !== e2.use_sound && (t.shouldUseSound = e2.use_sound), void 0 !== e2.silent && (t.silent = e2.silent), void 0 !== e2.promote_mobile && (t.promoteMobile = e2.promote_mobile), t = Object.assign(Object.assign({}, t), { bridgeURL: _t(e2.servers || [])[0] || "", webWalletURL: e2.web_wallet_url || "" });
    } catch (t2) {
      console.log(t2);
    }
    return t;
  }));
}
function Ct(t) {
  return Uint8Array.from(window.atob(t), ((t2) => t2.charCodeAt(0)));
}
function It(t, e2) {
  return { id: Date.now() * Math.pow(10, 3) + Math.floor(Math.random() * Math.pow(10, 3)), jsonrpc: "2.0", method: t, params: e2 };
}
function Pt() {
  return "undefined" != typeof navigator;
}
function Ot() {
  return Pt() && /Android/i.test(navigator.userAgent);
}
function Lt() {
  return Pt() && /iPhone|iPad|iPod/i.test(navigator.userAgent);
}
function Mt() {
  return Pt() && /iPhone|iPod|Android/i.test(navigator.userAgent);
}
function Ut() {
  if (!Pt()) return null;
  const { userAgent: t } = navigator;
  let e2;
  return e2 = t.match(/DuckDuckGo/i) ? "DuckDuckGo" : t.match(/OPX/i) ? "Opera GX" : navigator.brave ? "Brave" : bowser_default.getParser(navigator.userAgent).getBrowserName(), e2;
}
var Bt = "perawallet-wc://";
var Wt = "https://perawallet.app/download/";
function Dt(t) {
  return { ROOT: `https://${t}`, CONNECT: `https://${t}/connect`, TRANSACTION_SIGN: `https://${t}/transaction/sign` };
}
function xt({ method: t, signTxnRequestParams: e2, signer: n2, chainId: r3, webWalletURL: o3, resolve: i2, reject: s2 }) {
  const a2 = Dt(o3);
  !(function() {
    et(this, void 0, void 0, (function* () {
      try {
        const o4 = yield lt(a2.TRANSACTION_SIGN);
        if (o4) {
          let i3;
          "SIGN_TXN" === t ? i3 = { type: "SIGN_TXN", txn: e2 } : "SIGN_DATA" === t && n2 && r3 && (i3 = { type: "SIGN_DATA", data: e2, signer: n2, chainId: r3 }), i3 && rt.sendMessage({ message: i3, origin: a2.TRANSACTION_SIGN, targetWindow: o4 });
        }
        const l2 = setInterval((() => {
          true === (null == o4 ? void 0 : o4.closed) && (s2(new nt({ type: `${t}_CANCELLED` }, "Transaction signing is cancelled by user.")), clearInterval(l2));
        }), 2e3);
        rt.setupListener({ onReceiveMessage: (e3) => (function({ event: t2, newPeraWalletTab: e4, method: n3, resolve: r4, reject: o5 }) {
          switch (t2.data.message.type) {
            case "SIGN_TXN_CALLBACK":
              null == e4 || e4.close(), r4(t2.data.message.signedTxns.map(((t3) => Ct(t3.signedTxn))));
              break;
            case "SIGN_DATA_CALLBACK":
              null == e4 || e4.close(), r4(t2.data.message.signedData.map(((t3) => Ct(t3.signedData))));
              break;
            case "SIGN_TXN_NETWORK_MISMATCH":
              o5(new nt({ type: `${n3}_NETWORK_MISMATCH`, detail: t2.data.message.error }, t2.data.message.error || "Network mismatch"));
              break;
            case "SIGN_TXN_CALLBACK_ERROR":
              null == e4 || e4.close(), o5(new nt({ type: `${n3}_CANCELLED` }, t2.data.message.error));
              break;
            case "SESSION_DISCONNECTED":
              null == e4 || e4.close(), Tt(), o5(new nt({ type: "SESSION_DISCONNECTED", detail: t2.data.message.error }, t2.data.message.error));
          }
        })({ event: e3, newPeraWalletTab: o4, method: t, resolve: i2, reject: s2 }) });
      } catch (t2) {
        s2(t2);
      }
    }));
  })();
}
function Yt({ webWalletURL: t, chainId: e2, resolve: n2, reject: r3 }) {
  const o3 = Dt(t);
  return function() {
    return et(this, void 0, void 0, (function* () {
      try {
        const t2 = yield lt(o3.CONNECT);
        t2 && rt.sendMessage({ message: { type: "CONNECT", data: Object.assign(Object.assign({}, st()), { chainId: e2 }) }, origin: o3.CONNECT, targetWindow: t2 });
        const s2 = setInterval((() => {
          true === (null == t2 ? void 0 : t2.closed) && (r3(new nt({ type: "CONNECT_CANCELLED" }, "Connect is cancelled by user")), clearInterval(s2), i2());
        }), 2e3);
        rt.setupListener({ onReceiveMessage: (e3) => (function({ event: t3, newPeraWalletTab: e4, resolve: n3, reject: r4 }) {
          if (n3 && "CONNECT_CALLBACK" === t3.data.message.type) {
            const r5 = t3.data.message.data.addresses;
            At(r5, "pera-wallet-web"), n3(r5), vt(ut), null == e4 || e4.close();
          } else "CONNECT_NETWORK_MISMATCH" === t3.data.message.type && (r4(new nt({ type: "CONNECT_NETWORK_MISMATCH", detail: t3.data.message.error }, t3.data.message.error || "Your wallet is connected to a different network to this dApp. Update your wallet to the correct network (MainNet or TestNet) to continue.")), vt(ut), null == e4 || e4.close());
        })({ event: e3, newPeraWalletTab: t2, resolve: n2, reject: r3 }) });
      } catch (t2) {
        i2(), r3(t2);
      }
    }));
  };
  function i2() {
    vt(ut);
  }
}
function kt({ isWebWalletAvailable: t, shouldDisplayNewBadge: e2, shouldUseSound: n2, compactMode: r3, promoteMobile: o3, singleAccount: i2, selectedAccount: s2 }) {
  return { open: (a2 = { isWebWalletAvailable: t, shouldDisplayNewBadge: e2, shouldUseSound: n2, compactMode: r3, promoteMobile: o3, singleAccount: i2, selectedAccount: s2 }, (t2) => {
    if (!document.getElementById(ut)) {
      const e3 = pt(ut), n3 = `${t2}&algorand=true`, { isWebWalletAvailable: r4, shouldDisplayNewBadge: o4, shouldUseSound: i3, compactMode: s3, promoteMobile: l2, singleAccount: u2, selectedAccount: c2 } = a2;
      e3.innerHTML = `<pera-wallet-connect-modal uri="${n3}" is-web-wallet-avaliable="${r4}" should-display-new-badge="${o4}" should-use-sound="${i3}" compact-mode="${s3}" promote-mobile="${l2}" single-account="${u2}" selected-account="${c2 || ""}"></pera-wallet-connect-modal>`;
    }
  }), close: () => vt(ut) };
  var a2;
}
var jt = class {
  constructor(t) {
    this.bridge = (null == t ? void 0 : t.bridge) || "", this.connector = null, this.shouldShowSignTxnToast = void 0 === (null == t ? void 0 : t.shouldShowSignTxnToast) || t.shouldShowSignTxnToast, this.chainId = null == t ? void 0 : t.chainId, this.compactMode = (null == t ? void 0 : t.compactMode) || false, this.singleAccount = (null == t ? void 0 : t.singleAccount) || false;
  }
  get platform() {
    return (function() {
      const t = Et();
      let e2 = null;
      return "pera-wallet" === (null == t ? void 0 : t.type) ? e2 = "mobile" : "pera-wallet-web" === (null == t ? void 0 : t.type) && (e2 = "web"), e2;
    })();
  }
  get isConnected() {
    var t;
    return "mobile" === this.platform ? !!this.connector : "web" === this.platform && !!(null === (t = Et()) || void 0 === t ? void 0 : t.accounts.length);
  }
  get isPeraDiscoverBrowser() {
    return this.checkIsPeraDiscoverBrowser();
  }
  connect(e2) {
    return new Promise(((n2, r3) => et(this, void 0, void 0, (function* () {
      var o3;
      try {
        if (null === (o3 = this.connector) || void 0 === o3 ? void 0 : o3.connected) try {
          yield this.connector.killSession();
        } catch (t) {
        }
        const { isWebWalletAvailable: i2, bridgeURL: s2, webWalletURL: a2, shouldDisplayNewBadge: l2, shouldUseSound: u2, promoteMobile: c2 } = yield Nt(), h2 = Yt({ resolve: n2, reject: r3, webWalletURL: a2, chainId: this.chainId, isCompactMode: this.compactMode });
        i2 && (window.onWebWalletConnect = h2), this.connector = new esm_default3({ bridge: this.bridge || s2 || "https://bridge.walletconnect.org", qrcodeModal: kt({ isWebWalletAvailable: i2, shouldDisplayNewBadge: l2, shouldUseSound: u2, compactMode: this.compactMode, promoteMobile: c2, singleAccount: this.singleAccount, selectedAccount: null == e2 ? void 0 : e2.selectedAccount }) }), yield this.connector.createSession({ chainId: this.chainId || 4160 }), (function(t, e3) {
          var n3, r4, o4, i3;
          const s3 = document.getElementById(t), a3 = null === (r4 = null === (n3 = null == s3 ? void 0 : s3.querySelector(t.replace("-wrapper", ""))) || void 0 === n3 ? void 0 : n3.shadowRoot) || void 0 === r4 ? void 0 : r4.querySelector(`.${dt}`), l3 = null === (i3 = null === (o4 = null == a3 ? void 0 : a3.querySelector("pera-wallet-modal-header")) || void 0 === o4 ? void 0 : o4.shadowRoot) || void 0 === i3 ? void 0 : i3.getElementById("pera-wallet-modal-header-close-button");
          null == l3 || l3.addEventListener("click", (() => {
            e3(), vt(t);
          }));
        })(ut, (() => r3(new nt({ type: "CONNECT_MODAL_CLOSED" }, "Connect modal is closed by user")))), this.connector.on("connect", ((t, e3) => {
          var o4, i3;
          t && r3(t), n2((null === (o4 = this.connector) || void 0 === o4 ? void 0 : o4.accounts) || []), At((null === (i3 = this.connector) || void 0 === i3 ? void 0 : i3.accounts) || []);
        }));
      } catch (t) {
        console.log(t), r3(new nt({ type: "SESSION_CONNECT", detail: t }, t.message || "There was an error while connecting to Pera Wallet"));
      }
    }))));
  }
  reconnectSession() {
    return new Promise(((e2, n2) => et(this, void 0, void 0, (function* () {
      var r3, o3;
      try {
        const i2 = Et();
        if (!i2) return void e2([]);
        if ("pera-wallet-web" === (null == i2 ? void 0 : i2.type)) {
          const { isWebWalletAvailable: t } = yield Nt();
          t ? e2(i2.accounts || []) : n2(new nt({ type: "SESSION_RECONNECT", detail: "Pera Web is not available" }, "Pera Web is not available"));
        }
        this.connector && e2(this.connector.accounts || []), this.bridge = (null === (r3 = (function() {
          var t;
          const e3 = null === (t = bt()) || void 0 === t ? void 0 : t.getItem(mt.WALLETCONNECT);
          return e3 ? JSON.parse(e3) : null;
        })()) || void 0 === r3 ? void 0 : r3.bridge) || "", this.bridge && (this.connector = new esm_default3({ bridge: this.bridge }), e2((null === (o3 = this.connector) || void 0 === o3 ? void 0 : o3.accounts) || [])), this.isConnected || e2([]);
      } catch (t) {
        yield this.disconnect(), n2(new nt({ type: "SESSION_RECONNECT", detail: t }, t.message || "There was an error while reconnecting to Pera Wallet"));
      }
    }))));
  }
  disconnect() {
    var t;
    return et(this, void 0, void 0, (function* () {
      let e2;
      this.isConnected && "mobile" === this.platform && (e2 = null === (t = this.connector) || void 0 === t ? void 0 : t.killSession(), null == e2 || e2.then((() => {
        this.connector = null;
      }))), yield Tt();
    }));
  }
  signTransactionWithMobile(t) {
    return et(this, void 0, void 0, (function* () {
      const e2 = It("algo_signTxn", [t]);
      try {
        try {
          const { silent: t2 } = yield Nt(), n2 = (yield this.connector.sendCustomRequest(e2, { forcePushNotification: !t2 })).filter(Boolean);
          return "string" == typeof n2[0] ? n2.map(Ct) : n2.map(((t3) => Uint8Array.from(t3)));
        } catch (t2) {
          return yield Promise.reject(new nt({ type: "SIGN_TRANSACTIONS", detail: t2 }, t2.message || "Failed to sign transaction"));
        }
      } finally {
        vt(ct), vt(ht);
      }
    }));
  }
  signTransactionWithWeb(t, e2) {
    return new Promise(((n2, r3) => xt({ signTxnRequestParams: t, webWalletURL: e2, method: "SIGN_TXN", resolve: n2, reject: r3 })));
  }
  signDataWithMobile({ data: t, signer: e2, chainId: n2 }) {
    return et(this, void 0, void 0, (function* () {
      const r3 = It("algo_signData", t.map(((t2) => Object.assign(Object.assign({}, t2), { signer: e2, chainId: n2 }))));
      try {
        try {
          const { silent: t2 } = yield Nt(), e3 = (yield this.connector.sendCustomRequest(r3, { forcePushNotification: !t2 })).filter(Boolean);
          return "string" == typeof e3[0] ? e3.map(Ct) : e3.map(((t3) => Uint8Array.from(t3)));
        } catch (t2) {
          return yield Promise.reject(new nt({ type: "SIGN_TRANSACTIONS", detail: t2 }, t2.message || "Failed to sign transaction"));
        }
      } finally {
        vt(ct), vt(ht);
      }
    }));
  }
  signDataWithWeb({ data: t, signer: e2, chainId: n2, webWalletURL: r3 }) {
    return new Promise(((o3, i2) => xt({ method: "SIGN_DATA", signTxnRequestParams: t, signer: e2, chainId: n2, webWalletURL: r3, resolve: o3, reject: i2 })));
  }
  checkIsPeraDiscoverBrowser() {
    return window.navigator.userAgent.includes("pera");
  }
  signTransaction(t, n2) {
    return et(this, void 0, void 0, (function* () {
      if ("mobile" === this.platform && (Mt() ? gt() : !Mt() && this.shouldShowSignTxnToast && wt(), !this.connector)) throw new Error("PeraWalletConnect was not initialized correctly.");
      const r3 = t.flatMap(((t2) => t2.map(((t3) => (function(t4, n3) {
        let r4;
        n3 && !(t4.signers || []).includes(n3) && (r4 = []);
        const o3 = { txn: (i2 = t4.txn, Buffer.from(esm_default4.encodeUnsignedTransaction(i2)).toString("base64")) };
        var i2;
        return Array.isArray(r4) && (o3.signers = r4), t4.authAddr && (o3.authAddr = t4.authAddr), t4.message && (o3.message = t4.message), t4.msig && (o3.msig = t4.msig), o3;
      })(t3, n2)))));
      if ("web" === this.platform) {
        const { webWalletURL: t2 } = yield Nt();
        return this.signTransactionWithWeb(r3, t2);
      }
      return this.signTransactionWithMobile(r3);
    }));
  }
  signData(t, e2) {
    return et(this, void 0, void 0, (function* () {
      const n2 = this.chainId || 4160;
      if ("mobile" === this.platform && (Mt() ? gt() : !Mt() && this.shouldShowSignTxnToast && wt(), !this.connector)) throw new Error("PeraWalletConnect was not initialized correctly.");
      if ("web" === this.platform) {
        const { webWalletURL: r4 } = yield Nt();
        return this.signDataWithWeb({ data: t, signer: e2, chainId: n2, webWalletURL: r4 });
      }
      const r3 = t.map(((t2) => Object.assign(Object.assign({}, t2), { data: Buffer.from(t2.data).toString("base64") })));
      return this.signDataWithMobile({ data: r3, signer: e2, chainId: n2 });
    }));
  }
};
"undefined" != typeof window && (window.global = window, window.Buffer = window.Buffer || y, import("./App-428f5096-2BZ5RQ2T.js"));

export {
  ut,
  ct,
  ht,
  ft,
  dt,
  yt,
  vt,
  Ot,
  Lt,
  Mt,
  Ut,
  Bt,
  Wt,
  jt
};
/*! Bundled license information:

js-sha3/src/sha3.js:
  (**
   * [js-sha3]{@link https://github.com/emn178/js-sha3}
   *
   * @version 0.8.0
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2015-2018
   * @license MIT
   *)

tslib/tslib.es6.js:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

js-sha512/src/sha512.js:
  (*
   * [js-sha512]{@link https://github.com/emn178/js-sha512}
   *
   * @version 0.8.0
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2014-2018
   * @license MIT
   *)

hi-base32/src/base32.js:
  (*
   * [hi-base32]{@link https://github.com/emn178/hi-base32}
   *
   * @version 0.5.0
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2015-2018
   * @license MIT
   *)

bowser/src/bowser.js:
  (*!
   * Bowser - a browser detector
   * https://github.com/lancedikson/bowser
   * MIT License | (c) Dustin Diaz 2012-2015
   * MIT License | (c) Denis Demchenko 2015-2019
   *)
*/
//# sourceMappingURL=chunk-VT5QJJDL.js.map
